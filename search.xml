<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Typora修改CSS</title>
    <url>/2020/09/06/Typora%E4%BF%AE%E6%94%B9CSS/</url>
    <content><![CDATA[<p><strong>这一期给大家讲讲怎样将Typora设置成自己喜欢的风格，这里以高亮颜色为例！</strong></p>
<blockquote>
<p>打开 视图–&gt;开发者工具（快捷键 Shift+F12）得到网页元素：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/082.png" alt="image-20200828154027327"></p>
<a id="more"></a>

<blockquote>
<p>点亮这个图标：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/083.png" alt="image-20200828154137307"></p>
<blockquote>
<p>移动鼠标至想要修改样式的地方，点击一次</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/084.png" alt="image-20200828154549041"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/085.png" alt="image-20200828154851984"></p>
<blockquote>
<p>一般有两种类型的地址，第一种：</p>
</blockquote>
<ul>
<li>这种地址就直接按照地址中的位置寻找css文件，打开之后如图查找样式名即可</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/086.png" alt="image-20200828154927107"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/087.png" alt="image-20200828155231370"></p>
<blockquote>
<p>第二种：</p>
</blockquote>
<ul>
<li>这种地址存放在<code>C:\Users\Acer\AppData\Roaming\Typora\themes</code> 目录下，修改此处才有效</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/088.png" alt="image-20200828155004523"></p>
<blockquote>
<p>最后修改完成重启Typora即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>个性化设置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>FFmpeg简要使用</title>
    <url>/2020/09/23/ffmpeg/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序（——来源于百度百科）</li>
</ul>
<h2 id="2-下载并配置环境"><a href="#2-下载并配置环境" class="headerlink" title="2.下载并配置环境"></a>2.下载并配置环境</h2><ul>
<li>直接百度进入官网下载即可；</li>
<li>下载完成后将解压后的文件夹重命名为<code>ffmpeg</code>，并且放至自己电脑的环境目录下；</li>
<li>前往配置环境目录<code>PATH</code>，连同ffmpeg目录下的bin目录路径一起粘贴到PATH配置下新的路径即可；</li>
</ul>
<a id="more"></a>

<h2 id="3-简要介绍"><a href="#3-简要介绍" class="headerlink" title="3.简要介绍"></a>3.简要介绍</h2><ul>
<li>在bin目录下有三个文件：<ul>
<li>ffmpeg.exe：用于操作、转换和流式传输多媒体内容；</li>
<li>ffplay.exe：是一个简洁的视频音频播放器；</li>
<li>ffprobe.exe：是一个媒体参数分析工具；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/103.png" alt="image-20200914203342793"></p>
<h2 id="4-简要使用"><a href="#4-简要使用" class="headerlink" title="4.简要使用"></a>4.简要使用</h2><h3 id="4-1-ffmpeg"><a href="#4-1-ffmpeg" class="headerlink" title="4.1 ffmpeg"></a>4.1 ffmpeg</h3><ul>
<li>是一个命令行程序，直接在命令行运行；</li>
<li><code>ffmpeg -h</code>指令用来查看帮助信息，其余功能后续会讲到，其余指令自行百度；</li>
</ul>
<h3 id="4-2-ffplay"><a href="#4-2-ffplay" class="headerlink" title="4.2 ffplay"></a>4.2 ffplay</h3><ul>
<li>在cmd中进入具体文件目录，执行指令<code>ffplay example.mp4</code>即自动播放该视频（程序端口播放，不会调用软件，有牌面）；</li>
<li>播放完自动停留在最后一帧页面，<code>Esc</code>或者<code>q</code>按键退出，<code>p</code>键暂停；</li>
<li>执行命令<code>ffplay example.mp3</code>即自动播放音频文件；</li>
<li>方向键和鼠标都可以跳转播放位置，<code>f</code>键全屏，<code>p</code>键或者空格键暂停，<code>w</code>键切换显示模式；</li>
</ul>
<h3 id="4-3-ffprobe（不用细看……）"><a href="#4-3-ffprobe（不用细看……）" class="headerlink" title="4.3 ffprobe（不用细看……）"></a>4.3 ffprobe（不用细看……）</h3><ul>
<li>在cmd中进入具体文件目录，执行指令<code>ffprobe example.mp4</code>，即可显示媒体文件的头文件，其中包括参数信息等，如图：<ul>
<li>Metadata：媒体信息部分；<ul>
<li>major_brand：容器格式为mp4-v2；</li>
<li>Duration：持续时间，44分59秒44；</li>
<li>start：开始时间，0；</li>
<li>bitrate：比特率，16908kb/s；</li>
</ul>
</li>
<li>Stream #0.0：视频流参数；<ul>
<li>Video：编码，h264高规格编码；</li>
<li>avc1封装；</li>
<li>颜色空间为yuv420p；</li>
<li>分辨率1920*1080；</li>
<li>比特率，16776kb/s；</li>
<li>帧率，29.61帧每秒</li>
</ul>
</li>
<li>Stream #0.1：音频流参数；<ul>
<li>aac编码；</li>
<li>LC规格；</li>
<li>mp4a封装；</li>
<li>采样率，48000Hz；</li>
<li>stereo双声道；</li>
<li>fltp立体声；</li>
<li>比特率，128kb/s；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/104.png" alt="image-20200914205207947"></p>
<h2 id="5-转换格式"><a href="#5-转换格式" class="headerlink" title="5.转换格式"></a>5.转换格式</h2><ul>
<li>文件后缀名是文件的封装格式，不同的封装格式具有不同的标准；</li>
<li>视频文件格式表示封装某种编码格式的视频，如RMVB表示只支持Real、Video编码格式封装的视频；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/105.png" alt="image-20200914211857129"></p>
<ul>
<li>直接执行指令 <code>ffmpeg -i input.mov output.mp4</code>即可；</li>
<li>其中 <code>-i</code>指令的含义是将输入文件转换视频格式为输出文件的格式并且命名；</li>
</ul>
<h2 id="6-改变编码"><a href="#6-改变编码" class="headerlink" title="6.改变编码"></a>6.改变编码</h2><ul>
<li>一般的视频网站都是采用（支持1080p分辨率及以下）：<ul>
<li>mp4封装，H264视频编码+ACC音频编码；</li>
<li>WebM封装，VP8视频编码+Vorbis音频编码；</li>
<li>OGG封装，Theora视频编码+Vorbis音频编码；</li>
</ul>
</li>
</ul>
<h3 id="6-1-音频编码"><a href="#6-1-音频编码" class="headerlink" title="6.1 音频编码"></a>6.1 音频编码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.flac -acodec libmp31ame -ar 44100 -ab 320k -ac 2 out.mp3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -i，表示输入文件，接参数in.flac</span></span><br><span class="line"><span class="comment"># -acodec，其中a是指音频audio，codec是编/解码器，这条指令是用来指定音频文件的编码器，后接参数libmp31ame就是说以mp3格式编码，实际上编码器会自动根据输出文件后缀自动寻找匹配的编码器</span></span><br><span class="line"><span class="comment"># -ar，设置音频采样率，不输入指令默认采用原音频的采样率，一般是44100和48000两种</span></span><br><span class="line"><span class="comment"># -ab，设置音频比特率，不输入指令则默认128k</span></span><br><span class="line"><span class="comment"># -ac，设置声道数，1为单声道，2为双声道立体声，默认采用原音频声道数</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-视频压制"><a href="#6-2-视频压制" class="headerlink" title="6.2 视频压制"></a>6.2 视频压制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.webm -s 1920x1080 -pix_fmt yuv420p -vcodec libx264 -preset medium -profile:v high-level:v4.1 -crf 23 -acodec aac -ar 44100 -ac 2 -b:a 128k out.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s，缩放视频尺寸，1920*1080为新视频的宽高尺寸</span></span><br><span class="line"><span class="comment"># -pix_fmt，用来设置视频颜色空间，YUV（网络视频一般用这个）、NV、RGB等</span></span><br><span class="line"><span class="comment"># -vcodec，设置视频编码器，libx264是H264编码格式，一般都是使用这个编码</span></span><br><span class="line"><span class="comment"># -preset，编码器预设，调节预设可以改变编码算法的精度，精度越高，编码速度越慢，CPU占用率越多，有十个参数可选：ultrafast superfast veryfast faster fast slower veryslow placebo medium slow，默认是medium</span></span><br><span class="line"><span class="comment"># -profile:v，用来指定编码器的配置，主要和压缩比有关，超清视频设置为hegh即可</span></span><br><span class="line"><span class="comment"># -crf，设置码率控制模式</span></span><br></pre></td></tr></table></figure>



<h3 id="6-3-码率控制模式"><a href="#6-3-码率控制模式" class="headerlink" title="6.3 码率控制模式"></a>6.3 码率控制模式</h3><ul>
<li><p>概念：码率控制就是决定为每一个帧画面分配多少比特数，这是在权衡文件体积和画面质量；</p>
</li>
<li><p>三种码率控制模式：</p>
<ul>
<li>-qp：恒定量化器模式，个人手动设置码率，不推荐</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/106.png" alt="image-20200923111749870"></p>
<ul>
<li>-crf：恒定速率因子模式，浮动的qp模式，对某些视觉敏感的画面提高码率，而其余部分降低码率，即可压缩体积，常用；</li>
<li>-b：固定目标码率模式，对码率有限制，常用于视频网站控制视频体积及清晰度</li>
</ul>
</li>
</ul>
<h2 id="7-提取音视频原件"><a href="#7-提取音视频原件" class="headerlink" title="7.提取音视频原件"></a>7.提取音视频原件</h2><h3 id="7-1-提取去音频视频原件"><a href="#7-1-提取去音频视频原件" class="headerlink" title="7.1 提取去音频视频原件"></a>7.1 提取去音频视频原件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -an -acodec copy v.mp4</span><br></pre></td></tr></table></figure>



<h3 id="7-2-提取去视频音频原件"><a href="#7-2-提取去视频音频原件" class="headerlink" title="7.2 提取去视频音频原件"></a>7.2 提取去视频音频原件</h3><ul>
<li>有些音频有特殊格式，使用以下方法不可提取音频，可以观看原视频</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -vn -acodec copy a.mp3</span><br></pre></td></tr></table></figure>



<h3 id="7-3-合并音视频文件"><a href="#7-3-合并音视频文件" class="headerlink" title="7.3 合并音视频文件"></a>7.3 合并音视频文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i v.mp4 -i -a.mp3 -c copy out.mp4 </span><br></pre></td></tr></table></figure>



<h2 id="8-截取连接音视频"><a href="#8-截取连接音视频" class="headerlink" title="8.截取连接音视频"></a>8.截取连接音视频</h2><h3 id="8-1-截取音视频"><a href="#8-1-截取音视频" class="headerlink" title="8.1 截取音视频"></a>8.1 截取音视频</h3><ul>
<li>第一种，其中-ss是开始时间，-to是结束时间，时间取<code>时:分:秒</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp3 -ss 00:01:00 -to 00:01:10 -acodec copy out.mp3</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种，-t是截取时长，单位取秒</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp3 -ss 00:01:00 -t 10 -acodec copy out.mp3</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-sseof指令可以从音视频末尾开始，结合 -t指令，更加灵活</span><br><span class="line">-copyts指令用来保留时间戳</span><br></pre></td></tr></table></figure>



<h3 id="8-2-连接音视频"><a href="#8-2-连接音视频" class="headerlink" title="8.2 连接音视频"></a>8.2 连接音视频</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i <span class="string">&quot;concat:01.mp4|02.mp4|03.mp4&quot;</span> -c copy out.mp4</span><br></pre></td></tr></table></figure>





<blockquote>
<p>实话实说这个太底层了，虽然万能，但还不如直接用图形软件来的简单方便……</p>
</blockquote>
<p>视频链接：</p>
<p><a href="https://www.bilibili.com/video/BV1Ft411s7Xa?p=8">https://www.bilibili.com/video/BV1Ft411s7Xa?p=8</a></p>
]]></content>
      <categories>
        <category>有趣的玩意儿</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>不实用</tag>
      </tags>
  </entry>
  <entry>
    <title>hero等静态网站通过外部cdn引用图片</title>
    <url>/2020/09/10/hero%20Img%E9%80%9A%E8%BF%87%E5%85%8D%E8%B4%B9cdn%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<blockquote>
<p>hexo在上传静态网页的时候markdown文本中的图片却一直无法显示，这个问题如何解决呢？</p>
</blockquote>
<h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h2><ul>
<li>hexo只能上传md文本资源，并且最终转化为静态网页，而同级目录下的Img图片资源却无法上传至服务器；</li>
</ul>
<h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h2><ul>
<li>通过使用外部cdn引用图片即可完美地解决这个问题！但是像七牛云那些大型cdn网站都需要付费使用，这里给大家推荐一个免费且超级好用的cdn加速器：<a href="https://www.jsdelivr.com/">https://www.jsdelivr.com</a></li>
<li>要使用外部cdn引用，必须先将图片从自己个人电脑上传至网站服务器上，这里我们选择github服务器；</li>
</ul>
<a id="more"></a>

<h3 id="2-1-上传图片至github仓库"><a href="#2-1-上传图片至github仓库" class="headerlink" title="2.1 上传图片至github仓库"></a>2.1 上传图片至github仓库</h3><ul>
<li><p>在github上新建仓库，参考博客：<a href="https://blog.csdn.net/weixin_44339531/article/details/103642380">https://blog.csdn.net/weixin_44339531/article/details/103642380</a></p>
</li>
<li><p>在<code>MyHexo</code>文件夹下新建一个文件夹<code>cdn</code>，在<code>cdn</code>文件夹下新建文件<code>CDNBlog</code>专门用来上传博客图片；</p>
</li>
<li><p>在<code>CDNBlog</code>文件目录下打开git bash，通过以下几个命令完成上传：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动将所有已经修改或者新增的文件添加到远程库中</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 添加更新信息，message为更新信息</span></span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="comment"># 将远程库中的文件更新到远程master中</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>高能预警！！！</p>
</blockquote>
<ul>
<li>最后这一行命令可能出现以下问题：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey). fatal: Could not <span class="built_in">read</span> from remote repository.</span><br></pre></td></tr></table></figure>

<ul>
<li>如果出现这样的场景，请执行以下操作：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"><span class="comment"># your_email@example.com 是你自己github绑定的邮箱</span></span><br><span class="line"><span class="comment"># 接着直接以默认路径文件存储到文件中，这个地方亲身试险！！！不能修改默认路径文件名</span></span><br><span class="line"><span class="comment"># 应该是github默认ssh只能配置此文件，可能可以修改该配置，但这里我免得麻烦直接回车</span></span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># 再使用此命令复制下公钥密匙，将此密匙添加到github中，本文前面的链接有细讲</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 使用此命令可以显示出正确的信息即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li>完成这些操作之后重新git push应该就成功了；</li>
</ul>
<h3 id="2-2-markdown引用"><a href="#2-2-markdown引用" class="headerlink" title="2.2 markdown引用"></a>2.2 markdown引用</h3><ul>
<li>使用<code>https://cdn.jsdelivr.net/gh/</code>+github名+仓库名+图片路径 即可正常引用图片啦！</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>个性化设置</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫之Scrapy（2.实战）</title>
    <url>/2020/09/13/Python/scrapy%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="1-新建项目yangguang"><a href="#1-新建项目yangguang" class="headerlink" title="1.新建项目yangguang"></a>1.新建项目yangguang</h2><h3 id="1-1-新建项目"><a href="#1-1-新建项目" class="headerlink" title="1.1 新建项目"></a>1.1 新建项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy startproject yangguang</span><br><span class="line"><span class="built_in">cd</span> yangguang <span class="comment"># 进入新建项目列表</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-新建爬虫文件"><a href="#1-2-新建爬虫文件" class="headerlink" title="1.2 新建爬虫文件"></a>1.2 新建爬虫文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy genspider yg wz.sun0769.com</span><br></pre></td></tr></table></figure>



<h3 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h3><ul>
<li>更改<code>start_urls</code> ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_urls = [<span class="string">&#x27;http://wz.sun0769.com/political/index/politicsNewest?id=1&amp;page=1/&#x27;</span>]</span><br></pre></td></tr></table></figure>


<ul>
<li>在settings.py文件中添加日志过滤配置：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOG_LEVEL = <span class="string">&quot;WARNING&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>（重要！！！）在settings.py文件中添加下载限速配置（笔者由于下载过快直接导致整个宿舍的ip被网站封了……）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0.5是每次下载间隔0.5s</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写入访问请求头的用户代理（每个网站都不同，打开netWork随便选中一个链接都可看到）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">USER_AGENT = <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;</span></span><br></pre></td></tr></table></figure>



<a id="more"></a>

<h2 id="2-items-py"><a href="#2-items-py" class="headerlink" title="2.items.py"></a>2.items.py</h2><ul>
<li>（分析网页）在<code>items.py</code>文件中定义字典元素：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YangguangItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    status = scrapy.Field()             <span class="comment"># 状态</span></span><br><span class="line">    title = scrapy.Field()              <span class="comment"># 标题</span></span><br><span class="line">    href = scrapy.Field()               <span class="comment"># 链接地址</span></span><br><span class="line">    publish_date = scrapy.Field()       <span class="comment"># 发布时间</span></span><br><span class="line">    content_img = scrapy.Field()        <span class="comment"># 内容图片</span></span><br><span class="line">    content_text = scrapy.Field()       <span class="comment"># 内容文本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>yg.py</code>爬虫文件中导入刚刚定义的字典元素：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> yangguang.items <span class="keyword">import</span> YangguangItem</span><br></pre></td></tr></table></figure>



<h2 id="3-正式爬取"><a href="#3-正式爬取" class="headerlink" title="3.正式爬取"></a>3.正式爬取</h2><h3 id="3-1-分组爬取列表页内容"><a href="#3-1-分组爬取列表页内容" class="headerlink" title="3.1 分组爬取列表页内容"></a>3.1 分组爬取列表页内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    <span class="comment"># 分组</span></span><br><span class="line">    url = <span class="string">&quot;http://wz.sun0769.com&quot;</span></span><br><span class="line">    li_list = response.xpath(<span class="string">&#x27;//*[@class=&quot;title-state-ul&quot;]/li&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        item = YangguangItem()  <span class="comment"># 实例化</span></span><br><span class="line">        item[<span class="string">&quot;status&quot;</span>] = li.xpath(<span class="string">&#x27;./*[@class=&quot;state2&quot;]/text()&#x27;</span>).extract_first()</span><br><span class="line">        item[<span class="string">&quot;title&quot;</span>] = li.xpath(<span class="string">&#x27;./*[@class=&quot;state3&quot;]/a/text()&#x27;</span>).extract_first()</span><br><span class="line">        item[<span class="string">&quot;href&quot;</span>] = li.xpath(<span class="string">&#x27;./*[@class=&quot;state3&quot;]/a/@href&#x27;</span>).extract_first()</span><br><span class="line">        item[<span class="string">&quot;publish_date&quot;</span>] = li.xpath(<span class="string">&#x27;./*[@class=&quot;state5 &quot;]/text()&#x27;</span>).extract_first()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># href 不完整</span></span><br><span class="line">        item[<span class="string">&quot;href&quot;</span>] = url + str(item[<span class="string">&quot;href&quot;</span>])</span><br><span class="line">        print(item[<span class="string">&quot;href&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(</span><br><span class="line">            str(item[<span class="string">&quot;href&quot;</span>]),</span><br><span class="line">            callback=self.parse_detail,</span><br><span class="line">            meta=&#123;<span class="string">&quot;item&quot;</span>: item&#125;  <span class="comment"># 将item数据通过meta传输给下一个处理函数</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>



<h3 id="3-2-进一步爬取内容详情页"><a href="#3-2-进一步爬取内容详情页" class="headerlink" title="3.2 进一步爬取内容详情页"></a>3.2 进一步爬取内容详情页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    item = response.meta[<span class="string">&quot;item&quot;</span>]  <span class="comment"># 按照键值对的形式接收meta传过来的数据</span></span><br><span class="line">    <span class="comment"># 文本内容和图片都可能不止一段或一张</span></span><br><span class="line">    item[<span class="string">&quot;content_text&quot;</span>] = response.xpath(<span class="string">&#x27;//*[@class=&quot;details-box&quot;]/pre/text()&#x27;</span>).extract()</span><br><span class="line">    item[<span class="string">&quot;content_img&quot;</span>] = response.xpath(<span class="string">&#x27;//*[@class=&quot;clear details-img-list Picture-img&quot;]/img/@src&#x27;</span>).extract()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果图片链接不完整，执行以下语句(上述图片地址完整)：</span></span><br><span class="line">    <span class="comment"># item[&quot;content_img&quot;] = [&quot;http://wz.sun0769.com&quot;+i for i in item[&quot;content_img&quot;]]</span></span><br><span class="line"></span><br><span class="line">    print(item[<span class="string">&quot;title&quot;</span>])</span><br></pre></td></tr></table></figure>



<h3 id="3-3-在parse函数最后实现翻页请求"><a href="#3-3-在parse函数最后实现翻页请求" class="headerlink" title="3.3 在parse函数最后实现翻页请求"></a>3.3 在parse函数最后实现翻页请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 翻页</span></span><br><span class="line">next_url = response.xpath(<span class="string">&#x27;//*[@class=&quot;arrow-page prov_rota&quot;]/@href&#x27;</span>).extract_first()</span><br><span class="line">next_url = url + next_url</span><br><span class="line"><span class="comment"># if next_url is not None:</span></span><br><span class="line"><span class="comment"># 这里直接从101跳到了第一页，所以不用上述</span></span><br><span class="line"><span class="keyword">if</span> response.xpath(<span class="string">&#x27;//*[@class=&quot;mr-three paging-box&quot;]/a[4]/text()&#x27;</span>) != <span class="string">&quot;3&quot;</span>:</span><br><span class="line">    <span class="keyword">yield</span> scrapy.Request(</span><br><span class="line">        next_url,</span><br><span class="line">        callback=self.parse</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>



<h3 id="3-4-pipelines-py"><a href="#3-4-pipelines-py" class="headerlink" title="3.4 pipelines.py"></a>3.4 pipelines.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YangguangPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        item[<span class="string">&quot;content_img&quot;</span>] = self.content_process(item[<span class="string">&quot;content_img&quot;</span>])</span><br><span class="line">        item[<span class="string">&quot;content_text&quot;</span>] = self.content_process(item[<span class="string">&quot;content_text&quot;</span>])</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">content_process</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        <span class="comment"># re不太会用，可以百度</span></span><br><span class="line">        content = [re.sub(<span class="string">r&quot;\xa0|\s&quot;</span>, <span class="string">&quot;&quot;</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> content]</span><br><span class="line">        content = [i <span class="keyword">for</span> i <span class="keyword">in</span> content <span class="keyword">if</span> len(i) &gt; <span class="number">0</span>]  <span class="comment"># 去除列表中的空字符串</span></span><br><span class="line">        <span class="keyword">return</span> content</span><br></pre></td></tr></table></figure>



<h2 id="4-结果显示"><a href="#4-结果显示" class="headerlink" title="4.结果显示"></a>4.结果显示</h2><p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/102.png" alt="image-20200913213413120"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue（2.开发环境配置(含node.js)）</title>
    <url>/2020/09/06/vue/2.Vue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-Node-js下载"><a href="#1-Node-js下载" class="headerlink" title="1.Node.js下载"></a>1.Node.js下载</h2><p><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<ul>
<li>直接选择.msi 64位安装包下载并且直接安装即可，安装过程略</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/048.png" alt="image-20200903133908554"></p>
<a id="more"></a>


<ul>
<li>注意：选择自动添加到path路径，接着直接往下走不用更改；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/049.png" alt="image-20200903134106262"></p>
<ul>
<li>检查是否安装成功：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v 查看能否正常打印出版本号</span><br><span class="line">npm -v 安装node.js会自动安装npm包，同样查看即可</span><br><span class="line">npm是一个软件包管理工具，用于下载安装</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/050.png" alt="image-20200903142018014"></p>
<hr>
<h2 id="2-安装淘宝镜像加速器（cnpm）"><a href="#2-安装淘宝镜像加速器（cnpm）" class="headerlink" title="2.安装淘宝镜像加速器（cnpm）"></a>2.安装淘宝镜像加速器（cnpm）</h2><ul>
<li>cnpm下载国外程序可能无法正常使用，所以一般都使用npm下载，npm下载无用时再使用cnpm</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g -g是全局安装，建议直接全局安装，安装需要花费一定时间，如果不成功就多次重新安装</span><br><span class="line"></span><br><span class="line">npm install --registry=https://registry.npm.taobao.org 或者每次下载时使用此参数可以单词调用加速器</span><br></pre></td></tr></table></figure>

<p>安装之后的路径：<code>C:\Users\Acer\AppData\Roaming\npm\node_modules\cnpm</code></p>
<ul>
<li>同时与该加速器同级目录下还需下载其它模板：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/051.png" alt="image-20200903142549464"></p>
<h2 id="3-安装vue-cli"><a href="#3-安装vue-cli" class="headerlink" title="3.安装vue-cli"></a>3.安装vue-cli</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install vue-cli -g </span><br></pre></td></tr></table></figure>

<ul>
<li><p>vue-cli官方提供的一个脚手架，用于快速生成一个vue的项目模板;预先定义好的目录结构及基础代码，就好比咱们在创建Maven项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架,我们的开发更加的快速；也是接下来主要使用的部分；</p>
</li>
<li><p>主要的功能：</p>
<ul>
<li>统一的目录结构</li>
<li>本地调试</li>
<li>热部署</li>
<li>单元测试</li>
<li>集成打包上线</li>
</ul>
</li>
<li><p>安装成功后使用<code>vue list</code>命令可以查看模板：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/052.png" alt="image-20200903143231971"></p>
<ul>
<li>如果无法显示该目录，则需要重新配置网络，重启电脑或者开启手机热点切换网络再重试，原因是网络问题，可多次重连尝试；</li>
</ul>
<h2 id="4-使用vue-cli创建vue程序"><a href="#4-使用vue-cli创建vue程序" class="headerlink" title="4.使用vue-cli创建vue程序"></a>4.使用vue-cli创建vue程序</h2><ul>
<li>先切换命令提示符路径至目标路径；</li>
<li>使用命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue init webpack myvue 其中myvue为创建文件名</span><br></pre></td></tr></table></figure>

<ul>
<li><p>加载一会后会出现一系列相关信息，项目名、项目描述等都可以直接回车，使用默认信息即可，之后作者名可以自己更改，再往后Vue build选项选择第一项即可，之后所有选项直接选择 n，表示我们会手动部署其它文件（选择y就会自动部署）；</p>
</li>
<li><p>再进入新文件中：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> myvue</span><br></pre></td></tr></table></figure>

<ul>
<li>进入之后安装模板依赖：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install 自动安装固定依赖</span><br></pre></td></tr></table></figure>

<ul>
<li>接着使用命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev 用于部署服务器，每次运行时都需使用该命令部署服务器</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/053.png" alt="image-20200903144930303"></p>
<ul>
<li>部署成功之后可通过端口8080直接访问：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/054.png" alt="image-20200903145037697"></p>
<ul>
<li>ctrl+c可选择关闭服务器；</li>
</ul>
<hr>
<h2 id="5-IDEA初步认识文件"><a href="#5-IDEA初步认识文件" class="headerlink" title="5.IDEA初步认识文件"></a>5.IDEA初步认识文件</h2><ul>
<li>使用IDEA打开上述新项目，目录结构如图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/055.png" alt="image-20200903145259594"></p>
<ul>
<li><p>目录结构具体功能：</p>
<ul>
<li>index.html：是程序的主入口，内容不能随意修改：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/056.png" alt="image-20200903150423965"></p>
<ul>
<li>static：存放静态资源，如css、js、图片等；</li>
<li>src：开发项目区域：<ul>
<li>main.js：入口</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/057.png" alt="image-20200903150540591"></p>
<ul>
<li>package.json：打包时需要构建的版本信息等，不需修改；</li>
<li>node_modules：存放之前下载的依赖组件；</li>
<li>其余先不细讲，用到时再看；</li>
</ul>
</li>
</ul>
<h2 id="6-安装webpack"><a href="#6-安装webpack" class="headerlink" title="6.安装webpack"></a>6.安装webpack</h2><ul>
<li>安装指令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure>

<ul>
<li>测试安装成功：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack -v</span><br><span class="line">webpack-cli -v</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/058.png" alt="image-20200903165916564"></p>
<h2 id="7-安装vue-router"><a href="#7-安装vue-router" class="headerlink" title="7.安装vue-router"></a>7.安装vue-router</h2><ul>
<li>安装指令（需要在项目目录下执行）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>发生错误按照提示执行指令即可：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/061.png" alt="image-20200904115933531"></p>
<ul>
<li>成功安装到模板内：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/062.png" alt="image-20200904120407376"></p>
<h2 id="8-npm安装命令详解"><a href="#8-npm安装命令详解" class="headerlink" title="8.npm安装命令详解"></a>8.npm安装命令详解</h2><ul>
<li><code>npm install moduleName</code> :安装模块到项目目录下</li>
<li><code>npm install -g moduleName</code> : -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看npm config prefix的位置</li>
<li><code>npm install -save-dev moduleNam e</code>: –save-dev的意思是将模块安装到项目目录下，并在package文件的devDependencies 节点写入依赖，-D为该命令的缩</li>
<li><code>npm install -save moduleName</code> : –save的意思是将模块安装到项目目录下，并在package文件的dependencies 节点写入依赖，-S为该命令的缩写</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>环境配置</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python数据分析遇到的部分问题</title>
    <url>/2020/11/14/Python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><blockquote>
<p>本次数据分析目标是对大量的txt文本匹配查询一系列词汇出现的总频次，并从另一个大型二维数组（第一列元素存储了一系列文件名，需要将第二列和第三列元素相应添加到Excel表格中）中对每个文件名做相应的匹配查询</p>
</blockquote>
<p>使用python进行数据分析工作，主要工作流程如下：</p>
<ol>
<li><p>从<code>a1</code>、<code>a2</code>文本中读取内容（中文情感词汇，积极词汇表和消极词汇表）并以键值对形式存入两个大的字典中，键用取出来的词语表示，值则初始化赋值为0，用来对目标文本进行匹配分析对应词语出现次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">includesPositive = &#123;&#125;</span><br><span class="line">includesNegative = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readNegativeFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> txt:</span><br><span class="line">        key = key.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print(key)</span><br><span class="line">        includesNegative[key] = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readNegativeFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> txt:</span><br><span class="line">        key = key.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print(key)</span><br><span class="line">        includesNegative[key] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>从<code>b</code>文本中读取内容并存入一个大的二维数组中，其中文本每一行以符号<code>,</code>分隔三个字符串，并存入二维数组一行中，其中第一个字符串是文件名，第二个字符串是一段数字代码，第三个字符串是时间，并过滤文件名中特殊符号<code>\n</code>、<code>*</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 问题一：定义全局变量后，在函数中赋值，离开函数后却失效</span></span><br><span class="line">data = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4149</span>)]</span><br><span class="line"><span class="comment"># 实现按行读取文件，并使用分隔符号将每行字符串分割成二维数组一行存储</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_storage</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> txt:</span><br><span class="line">        row = row.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        row = row.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        data[i] = row.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        print(data[i])</span><br><span class="line">        i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>循环遍历目标文件夹下所有目标文件且自动过滤非txt格式以及含有敏感词汇<code>英语</code>的文件，并记录其文件路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环遍历指定目录下所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ergodic</span>():</span></span><br><span class="line">    paths = <span class="string">r&#x27;.\00\005&#x27;</span></span><br><span class="line">    <span class="comment"># paths = r&#x27;.\test&#x27;</span></span><br><span class="line">    fns = [os.path.join(root, fn) <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(paths) <span class="keyword">for</span> fn <span class="keyword">in</span> files]</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> fns:</span><br><span class="line">        <span class="keyword">if</span> path[len(path) - <span class="number">4</span>:len(path)].lower() == <span class="string">&#x27;.txt&#x27;</span>:</span><br><span class="line">            print(path)</span><br><span class="line">            <span class="comment"># 去除英文版</span></span><br><span class="line">            <span class="keyword">if</span> path.find(<span class="string">&quot;英文&quot;</span>) == <span class="number">-1</span>:</span><br><span class="line">                search_word(path)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>对循环得到的每一个有效文件路径实现以下功能：</p>
<ol>
<li>从相应的路径名中取出文件名（不含格式后缀）并存入字符串<code>name</code>中，并对<code>name</code>进行过滤特殊字符操作，该<code>name</code>用来从第二步获取的二维数组中匹配文件名，匹配正确则记录下该行中相应的数字代码和时间；</li>
<li>过滤特殊字符；</li>
<li>创建一个字典用<code>wordAndNum</code>来存储所有积极词汇和消极词汇分别出现的次数；</li>
<li>以该文件路径读取该文件并全部存入<code>txt</code>字符串中；</li>
<li>对<code>txt</code>使用结巴分词并将结果存入<code>words</code>中，对每一个单词分别与积极词汇<code>includesPositive</code>和消极词汇<code>includesNegative</code>进行比对，匹配成功则分别加入积极词汇字典<code>countsOfPositive</code>和消极词汇字典<code>countsOfNegative</code>中，并将字典中每一个键值对分别存入相应的积极消极元组<code>itemsOfPositive</code>、<code>itemsOfNegative</code>中；</li>
<li>分别遍历元组元素，将所有积极词汇出现的次数叠加存入最初的<code>wordAndNum</code>字典中，并计算相应的<code>TONE</code>值；</li>
<li>创建列表<code>li</code>并将文件名、匹配的数字代码、匹配的时间、积极词汇总数、消极词汇总数、TONE存入其中，最后将列表<code>li</code>追加存储到表格中；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_word</span>(<span class="params">path</span>):</span></span><br><span class="line">    name = get_name(path)</span><br><span class="line">    <span class="comment"># 去除特殊字符的干扰</span></span><br><span class="line">    name = name.replace(<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    name = name.replace(<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    name = name.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    data_num = match_name(name)</span><br><span class="line">    data_match = [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span>(data_num == <span class="number">10000</span>):</span><br><span class="line">        data_match = [<span class="string">&#x27;NO&#x27;</span>,<span class="string">&#x27;NO&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(data_num)</span><br><span class="line">        print(data[data_num][<span class="number">0</span>])</span><br><span class="line">        data_match[<span class="number">0</span>] = data[data_num][<span class="number">1</span>]</span><br><span class="line">        data_match[<span class="number">1</span>] = data[data_num][<span class="number">2</span>]</span><br><span class="line">        print(data_match)</span><br><span class="line">        <span class="comment"># 删除已匹配行</span></span><br><span class="line">        <span class="keyword">del</span> data[data_num]</span><br><span class="line">        print(<span class="string">&quot;匹配数据源还剩下:&quot;</span>+str(len(data))+<span class="string">&quot;，加油！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    wordAndNum = &#123;<span class="string">&#x27;Positive&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;Negative&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;TONE&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题二：读取时编码错误则会直接结束进程</span></span><br><span class="line">    encoding = detectCode(path)</span><br><span class="line">    print(encoding)</span><br><span class="line">    print(path)</span><br><span class="line">    <span class="keyword">if</span> encoding == <span class="string">&quot;UTF-16&quot;</span>:</span><br><span class="line">        txt = open(path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-16-le&quot;</span> ).read()</span><br><span class="line">    <span class="keyword">elif</span> encoding == <span class="string">&quot;UTF-8&quot;</span>:</span><br><span class="line">        txt = open(path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        txt = open(path, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">    </span><br><span class="line">    words = jieba.lcut(txt)</span><br><span class="line">    countsOfPositive = &#123;&#125;</span><br><span class="line">    countsOfNegative = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="comment"># 分别处理属于词汇列表中的积极和消极词汇</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> includesPositive:</span><br><span class="line">            countsOfPositive[word] = countsOfPositive.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> includesNegative:</span><br><span class="line">            countsOfNegative[word] = countsOfNegative.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dictsOfPositive = dict(countsOfPositive.items())</span><br><span class="line">    itemsOfPositive = dictsOfPositive.items()</span><br><span class="line"></span><br><span class="line">    dictsOfNegative = dict(countsOfNegative.items())</span><br><span class="line">    itemsOfNegative = dictsOfNegative.items()</span><br><span class="line"></span><br><span class="line">    print(itemsOfPositive)</span><br><span class="line">    print(itemsOfNegative)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> itemsOfPositive:</span><br><span class="line">        ls = list(item)</span><br><span class="line">        <span class="comment"># print(ls)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] = wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] + ls[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> itemsOfNegative:</span><br><span class="line">        ls = list(item)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                wordAndNum[<span class="string">&#x27;Negative&#x27;</span>] = wordAndNum[<span class="string">&#x27;Negative&#x27;</span>] + ls[i]</span><br><span class="line">    <span class="comment"># 问题三：分母不能为0</span></span><br><span class="line">    <span class="keyword">if</span>(wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] + wordAndNum[<span class="string">&#x27;Negative&#x27;</span>] != <span class="number">0</span>):</span><br><span class="line">        wordAndNum[<span class="string">&#x27;TONE&#x27;</span>] = abs(</span><br><span class="line">        (wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] - wordAndNum[<span class="string">&#x27;Negative&#x27;</span>]) / (wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] + wordAndNum[<span class="string">&#x27;Negative&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wordAndNum[<span class="string">&#x27;TONE&#x27;</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    li = [name,data_match[<span class="number">0</span>],data_match[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> wordAndNum:</span><br><span class="line">        li.append(key)</span><br><span class="line">        li.append(str(wordAndNum[key]))</span><br><span class="line">    <span class="comment"># fo = open(&quot;002.csv&quot;, &quot;a&quot;),a表示追加，w表示重新写入</span></span><br><span class="line">    fo = open(<span class="string">&quot;年报数据.csv&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fo.write(<span class="string">&quot;,&quot;</span>.join(li) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    fo.close()</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="问题及解决方法"><a href="#问题及解决方法" class="headerlink" title="问题及解决方法"></a>问题及解决方法</h2><blockquote>
<p>问题一：定义全局变量后，在函数中赋值，离开函数后却失效</p>
</blockquote>
<p><strong>问题具体描述：</strong></p>
<p>二维列表<code>data</code>是用来存储从文件<code>b</code>中获取的文件名、数字代码和时间的，文件中每一行三个字符串要存储为<code>data</code>的一行，从文件中取出来的内容最初存在<code>txt</code>列表中，每一行存储为列表中的一个元素，所以是可以直接计算该<code>txt</code>元素长度并实现自动申请相应的内存给二维列表<code>data</code>，于是我做出了以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_storage</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    data = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(txt))]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> txt:</span><br><span class="line">        row = row.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        row = row.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        data[i] = row.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        print(data[i])</span><br><span class="line">        i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>即定义全局变量<code>data</code>，并且在函数内部对该全局变量<code>data</code>先申请具体空间再进行每一行每一列的赋值操作，结果导致离开该函数后，<code>data</code>元素长度为空。</p>
<p><strong>原因：</strong></p>
<p>这应该是在函数中重新给变量<code>data</code>申请空间这个操作引起的问题，即因为<code>data = [[] for i in range(len(txt))]</code>这段代码的初始化与全局变量<code>data = []</code>初始化冲突了，于是程序将其定义为一个新的局部变量，导致内部使用的<code>data</code>的值无法在该函数之外调用。</p>
<p><strong>解决方法：</strong></p>
<p>就是我们现在代码修改的这样，直接最开始就给全局变量初始化具体空间，优点是简单不费脑，缺点是不够友好。</p>
<blockquote>
<p>问题二：读取文件时由于编码错误直接结束进程</p>
</blockquote>
<p><strong>问题具体描述：</strong></p>
<p>最初是在跑数据的过程中突然中断结束，显示以UTF-16编码格式打开文件时内容编码出错，于是以为是整个文本编码格式是UTF-8，结果发现文本编码格式是UTF-16，但是其中某个数据存储格式不符合UTF-16的编码格式，才报的错。解决方案是直接删掉那一个出错的文本/滑稽。</p>
<p>解决这个出错的问题时使用了二进制读取文本的方式，虽然正常运行程序了，但是最后却发现得不到想要的数据，于是百度了二进制编码以及unicode也就是UTF-8和UTF-16编码的区别。</p>
<p><strong>拓展：</strong>二进制读取文件和Unicode编码以及读取文件的区别：</p>
<p>所有的文件最终存储形式都是二进制，以二进制形式读取文件内容就是不对文本做任何处理而直接读取。Unicode编码是指对文件内容进行固定格式的转换，如UTF-16编码就是对文字以固定两个字节16个比特进行转换存储的，只能通过UTF-16编码格式打开读取，并且会对数据进行转换字符串操作。再简单点来说，二进制形式读取出来的数据就是二进制字符集合，而使用Unicode编码读取出来的数据则是经过转换的字符串集合。所以一般以二进制直接存储的二进制文件最好使用二进制形式读取，而文本文件由于是二进制之上的字符串集合，最好使用Unicode编码格式读取，否则容易出错。UTF-8针对的一般是英文文本内容，UTF-16是针对汉字处理的。</p>
<blockquote>
<p>问题三：分母不能为0</p>
</blockquote>
<p><strong>问题具体描述：</strong></p>
<p>对于<code>wordAndNum[&#39;Positive&#39;] - wordAndNum[&#39;Negative&#39;]) / (wordAndNum[&#39;Positive&#39;] + wordAndNum[&#39;Negative&#39;])</code>语句来说，即使分母相加的两个值都是大于等于0的存在，但同样是有可能出现分母为0的情形的，在本次数据处理中，由于情感词汇表给出的都是中文词汇，而处理的文本数据却有英文版，因此出现了分母为0的情形，于是直接对文件路径做了过滤处理，而且为了防止再出现此类错误，做了简单的出错处理。</p>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line">includesPositive = &#123;&#125;</span><br><span class="line">includesNegative = &#123;&#125;</span><br><span class="line">data = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4149</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readPositiveFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> txt:</span><br><span class="line">        key = key.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print(key)</span><br><span class="line">        includesPositive[key] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readNegativeFile</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> txt:</span><br><span class="line">        key = key.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print(key)</span><br><span class="line">        includesNegative[key] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现按行读取文件，并使用分隔符号将每行字符串分割成二维数组一行存储</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_storage</span>(<span class="params">path</span>):</span></span><br><span class="line">    txt = open(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>).readlines()</span><br><span class="line">    <span class="comment"># data = [[] for i in range(len(txt))]</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> txt:</span><br><span class="line">        row = row.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        row = row.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        data[i] = row.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        print(data[i])</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(len(data))</span></span><br><span class="line">    <span class="comment"># del data[1]</span></span><br><span class="line">    <span class="comment"># print(len(data))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCode</span>(<span class="params">path</span>):</span></span><br><span class="line">	<span class="keyword">with</span> open(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">		data = file.read(<span class="number">200000</span>)</span><br><span class="line">		dicts = chardet.detect(data)</span><br><span class="line">	<span class="keyword">return</span> dicts[<span class="string">&quot;encoding&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>():</span></span><br><span class="line">    readPositiveFile(<span class="string">&#x27;F:\PythonSpiders\Word\_file\_positive_simplified.txt&#x27;</span>)</span><br><span class="line">    readNegativeFile(<span class="string">&#x27;F:\PythonSpiders\Word\_file\_negative_simplified.txt&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(len(includesPositive))</span></span><br><span class="line">    <span class="comment"># print(includesPositive.keys())</span></span><br><span class="line">    <span class="comment"># print(len(includesNegative))</span></span><br><span class="line">    <span class="comment"># print(includesNegative.keys())</span></span><br><span class="line">    data_storage(<span class="string">&#x27;0.txt&#x27;</span>)</span><br><span class="line">    ergodic()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历指定目录下所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ergodic</span>():</span></span><br><span class="line">    paths = <span class="string">r&#x27;.\00\005&#x27;</span></span><br><span class="line">    <span class="comment"># paths = r&#x27;.\test&#x27;</span></span><br><span class="line">    fns = [os.path.join(root, fn) <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(paths) <span class="keyword">for</span> fn <span class="keyword">in</span> files]</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> fns:</span><br><span class="line">        <span class="keyword">if</span> path[len(path) - <span class="number">4</span>:len(path)].lower() == <span class="string">&#x27;.txt&#x27;</span>:</span><br><span class="line">            print(path)</span><br><span class="line">            <span class="comment"># 去除英文版</span></span><br><span class="line">            <span class="keyword">if</span> path.find(<span class="string">&quot;英文&quot;</span>) == <span class="number">-1</span>:</span><br><span class="line">                search_word(path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_word</span>(<span class="params">path</span>):</span></span><br><span class="line">    name = get_name(path)</span><br><span class="line">    <span class="comment"># 去除特殊字符的干扰</span></span><br><span class="line">    name = name.replace(<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    name = name.replace(<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    name = name.replace(<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    data_num = match_name(name)</span><br><span class="line">    data_match = [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span>(data_num == <span class="number">10000</span>):</span><br><span class="line">        data_match = [<span class="string">&#x27;NO&#x27;</span>,<span class="string">&#x27;NO&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(data_num)</span><br><span class="line">        print(data[data_num][<span class="number">0</span>])</span><br><span class="line">        data_match[<span class="number">0</span>] = data[data_num][<span class="number">1</span>]</span><br><span class="line">        data_match[<span class="number">1</span>] = data[data_num][<span class="number">2</span>]</span><br><span class="line">        print(data_match)</span><br><span class="line">        <span class="comment"># 删除已匹配行</span></span><br><span class="line">        <span class="keyword">del</span> data[data_num]</span><br><span class="line">        print(<span class="string">&quot;匹配数据源还剩下:&quot;</span>+str(len(data))+<span class="string">&quot;，加油！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    wordAndNum = &#123;<span class="string">&#x27;Positive&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;Negative&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;TONE&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    encoding = detectCode(path)</span><br><span class="line">    print(encoding)</span><br><span class="line">    print(path)</span><br><span class="line">    <span class="keyword">if</span> encoding == <span class="string">&quot;UTF-16&quot;</span>:</span><br><span class="line">        txt = open(path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-16-le&quot;</span> ).read()</span><br><span class="line">    <span class="keyword">elif</span> encoding == <span class="string">&quot;UTF-8&quot;</span>:</span><br><span class="line">        txt = open(path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        txt = open(path, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">    words = jieba.lcut(txt)</span><br><span class="line">    countsOfPositive = &#123;&#125;</span><br><span class="line">    countsOfNegative = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="comment"># 分别处理属于词汇列表中的积极和消极词汇</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> includesPositive:</span><br><span class="line">            countsOfPositive[word] = countsOfPositive.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> includesNegative:</span><br><span class="line">            countsOfNegative[word] = countsOfNegative.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dictsOfPositive = dict(countsOfPositive.items())</span><br><span class="line">    itemsOfPositive = dictsOfPositive.items()</span><br><span class="line"></span><br><span class="line">    dictsOfNegative = dict(countsOfNegative.items())</span><br><span class="line">    itemsOfNegative = dictsOfNegative.items()</span><br><span class="line"></span><br><span class="line">    print(itemsOfPositive)</span><br><span class="line">    print(itemsOfNegative)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> itemsOfPositive:</span><br><span class="line">        ls = list(item)</span><br><span class="line">        <span class="comment"># print(ls)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] = wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] + ls[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> itemsOfNegative:</span><br><span class="line">        ls = list(item)</span><br><span class="line">        <span class="comment"># print(ls)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ls)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                wordAndNum[<span class="string">&#x27;Negative&#x27;</span>] = wordAndNum[<span class="string">&#x27;Negative&#x27;</span>] + ls[i]</span><br><span class="line">    <span class="keyword">if</span>(wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] + wordAndNum[<span class="string">&#x27;Negative&#x27;</span>] != <span class="number">0</span>):</span><br><span class="line">        wordAndNum[<span class="string">&#x27;TONE&#x27;</span>] = abs(</span><br><span class="line">        (wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] - wordAndNum[<span class="string">&#x27;Negative&#x27;</span>]) / (wordAndNum[<span class="string">&#x27;Positive&#x27;</span>] + wordAndNum[<span class="string">&#x27;Negative&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wordAndNum[<span class="string">&#x27;TONE&#x27;</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    li = [name,data_match[<span class="number">0</span>],data_match[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> wordAndNum:</span><br><span class="line">        li.append(key)</span><br><span class="line">        li.append(str(wordAndNum[key]))</span><br><span class="line">    <span class="comment"># fo = open(&quot;002.csv&quot;, &quot;a&quot;),a表示追加，w表示重新写入</span></span><br><span class="line">    fo = open(<span class="string">&quot;年报数据.csv&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fo.write(<span class="string">&quot;,&quot;</span>.join(li) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    fo.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历data数据中文件名，对比传入name，相同则返回下标，未匹配到则返回固定值10000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(name)</span><br><span class="line">    print(len(data))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">if</span> name == data[i][<span class="number">0</span>]:</span><br><span class="line">            print(data[i][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">elif</span> i==len(data)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">path</span>):</span></span><br><span class="line">    nameNum = last_char(path)</span><br><span class="line">    name = path[nameNum + <span class="number">1</span>:len(path) - <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回最后一次出现该字符的序号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_char</span>(<span class="params">str</span>):</span></span><br><span class="line">    lastNum = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    char = <span class="string">&quot;\\&quot;</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> str:</span><br><span class="line">        <span class="keyword">if</span> char == ch:</span><br><span class="line">            lastNum = num</span><br><span class="line">        num = num + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lastNum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parse()</span><br></pre></td></tr></table></figure>



<blockquote>
<p>问题四：pritf字符串输出的问题</p>
</blockquote>
<p>printf函数传入参数应是字符串格式参数，即不可以为此种类型<code>printf(&quot;num=&quot;+x)</code>其中<code>x=1</code>，这时必须要把变量x转为字符串即<code>printf(&quot;num=&quot;+str(x))</code>格式才能正确输出。</p>
<blockquote>
<p>小彩蛋</p>
</blockquote>
<p>贴上一个批量pdf转txt的代码，实话实说这种简单转换不是很完善，只能当做娱乐，不如使用软件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">importlib.reload(sys)</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfparser <span class="keyword">import</span> PDFParser, PDFDocument</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFResourceManager, PDFPageInterpreter</span><br><span class="line"><span class="keyword">from</span> pdfminer.converter <span class="keyword">import</span> PDFPageAggregator</span><br><span class="line"><span class="keyword">from</span> pdfminer.layout <span class="keyword">import</span> LTTextBoxHorizontal, LAParams</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFTextExtractionNotAllowed</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 解析pdf 文本，保存到txt文件中</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># path = r&#x27;001.pdf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历指定目录下所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>():</span></span><br><span class="line">    paths = <span class="string">r&#x27;F:\年报00\年报01\年报&#x27;</span></span><br><span class="line">    fns = [os.path.join(root, fn) <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(paths) <span class="keyword">for</span> fn <span class="keyword">in</span> files]</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> fns:</span><br><span class="line">        <span class="keyword">if</span> path[len(path)<span class="number">-4</span>:len(path)].lower()==<span class="string">&#x27;.pdf&#x27;</span>:</span><br><span class="line">            print(path)</span><br><span class="line">            parse_next(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">path</span>):</span></span><br><span class="line">    nameNum = last_char(path)</span><br><span class="line">    name = path[nameNum+<span class="number">1</span>:len(path)<span class="number">-4</span>] + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回倒数第二次出现该字符的序号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_char</span>(<span class="params">str</span>):</span></span><br><span class="line">    beforeNum = <span class="number">0</span></span><br><span class="line">    afterNum = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    char = <span class="string">&quot;\\&quot;</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> str:</span><br><span class="line">        <span class="keyword">if</span> char == ch:</span><br><span class="line">            beforeNum = afterNum</span><br><span class="line">            afterNum = num</span><br><span class="line">        num = num + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> beforeNum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_next</span>(<span class="params">path</span>):</span></span><br><span class="line">    name = get_name(path)</span><br><span class="line">    fp = open(path, <span class="string">&#x27;rb&#x27;</span>)  <span class="comment"># 以二进制读模式打开</span></span><br><span class="line">    <span class="comment"># 用文件对象来创建一个pdf文档分析器</span></span><br><span class="line">    praser = PDFParser(fp)</span><br><span class="line">    <span class="comment"># 创建一个PDF文档</span></span><br><span class="line">    doc = PDFDocument()</span><br><span class="line">    <span class="comment"># 连接分析器 与文档对象</span></span><br><span class="line">    praser.set_document(doc)</span><br><span class="line">    doc.set_parser(praser)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提供初始化密码</span></span><br><span class="line">    <span class="comment"># 如果没有密码 就创建一个空的字符串</span></span><br><span class="line">    doc.initialize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测文档是否提供txt转换，不提供就忽略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> doc.is_extractable:</span><br><span class="line">        <span class="keyword">raise</span> PDFTextExtractionNotAllowed</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 创建PDf 资源管理器 来管理共享资源</span></span><br><span class="line">        rsrcmgr = PDFResourceManager()</span><br><span class="line">        <span class="comment"># 创建一个PDF设备对象</span></span><br><span class="line">        laparams = LAParams()</span><br><span class="line">        device = PDFPageAggregator(rsrcmgr, laparams=laparams)</span><br><span class="line">        <span class="comment"># 创建一个PDF解释器对象</span></span><br><span class="line">        interpreter = PDFPageInterpreter(rsrcmgr, device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历列表，每次处理一个page的内容</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> doc.get_pages():  <span class="comment"># doc.get_pages() 获取page列表</span></span><br><span class="line">            interpreter.process_page(page)</span><br><span class="line">            <span class="comment"># 接受该页面的LTPage对象</span></span><br><span class="line">            layout = device.get_result()</span><br><span class="line">            <span class="comment"># 这里layout是一个LTPage对象 里面存放着 这个page解析出的各种对象 一般包括LTTextBox, LTFigure, LTImage, LTTextBoxHorizontal 等等 想要获取文本就获得对象的text属性，</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> layout:</span><br><span class="line">                <span class="keyword">if</span> (isinstance(x, LTTextBoxHorizontal)):</span><br><span class="line">                    <span class="keyword">with</span> open(name, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        results = x.get_text()</span><br><span class="line">                        f.write(results + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parse()</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫之Scrapy（1.简要入门）</title>
    <url>/2020/09/10/Python/scrapy%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1-安装scrapy"><a href="#1-安装scrapy" class="headerlink" title="1.安装scrapy"></a>1.安装scrapy</h2><ul>
<li>在cmd下一条语句即可完成安装；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure>



<blockquote>
<p>据说在安装过程中可能遇到各种问题，由于我自己并没有遇到，所以略过，出现问题请自行百度</p>
</blockquote>
<ul>
<li>直接在命令行输入<code>scrapy</code>可以查看相关指令：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/089.png" alt="image-20200909084009265"></p>
<ul>
<li>输入<code>scrapy bench</code>用来验证安装是否成功，出现error则未成功，请自行百度解决方法；</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="2-scrapy原理"><a href="#2-scrapy原理" class="headerlink" title="2.scrapy原理"></a>2.scrapy原理</h2><ul>
<li>直接上图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/090.png" alt="image-20200910212314248"></p>
<ul>
<li>讲解一下整个项目运行的过程，看完整篇博客再回来这里更有收获哟~<ul>
<li>Spiders文件即为我们主要编写逻辑代码的区域，也就是爬虫文件；</li>
<li>最初start_urls网址请求（request）被发送给引擎（Scrapy Engine）；</li>
<li>引擎通过判断这是一段网址请求而又将网址请求发送给调度器（Scheduler）；</li>
<li>调度器将网址请求进行入队操作（可能有很多网址）排好队再重新发回引擎；</li>
<li>引擎将入队之后再出队的网址请求发送给下载器（Downloader）；</li>
<li>下载器直接从Inernet中下载请求网址对应的网页源代码，即HTML代码，这段代码被称为响应（response），没错就是后续代码中使用的response，下载器将响应返回给引擎；</li>
<li>引擎再将响应返回给爬虫文件（Spiders）；</li>
<li>爬虫文件经过逻辑处理之后，再次发送请求给引擎，但这段请求可能是网址，如果是网址请求则再次重复上述过程，但也可能是数据，如果是数据，则引擎在接受到数据之后则将其转发给管道文件（Pipeline）；</li>
<li>最终由管道文件来确定是否将数据输出并且输出成何种类型的文件，也就是我们后面讲到的pipelines.py中的逻辑操作；</li>
</ul>
</li>
</ul>
<h2 id="3-创建项目（直接上手实例）"><a href="#3-创建项目（直接上手实例）" class="headerlink" title="3.创建项目（直接上手实例）"></a>3.创建项目（直接上手实例）</h2><ul>
<li>在cmd中进入文件所在位置，再执行指令用于创建项目：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scrapy startproject 项目名	项目名一般由爬取网站的网站域名去除后缀再加上Spider单词组成</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是我的实际执行命令，爬取网站为 http://www.itcast.cn/</span></span><br><span class="line">scrapy startproject spiderStudy</span><br></pre></td></tr></table></figure>



<h2 id="4-创建爬虫"><a href="#4-创建爬虫" class="headerlink" title="4.创建爬虫"></a>4.创建爬虫</h2><ul>
<li>进入新建的项目目录，执行命令用于创建爬虫文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scrapy genspider 爬虫文件 网站域名</span></span><br><span class="line"><span class="comment"># 爬虫文件不要和项目名相同，规范是直接使用项目名去除Spider之后的单词，而网站域名则是爬虫采集的域名，即只有在此域名之下的网址才能被采集到，可以在文件中修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际执行命令</span></span><br><span class="line">scrapy genspider itcast itcast.cn</span><br></pre></td></tr></table></figure>



<h2 id="5-项目结构"><a href="#5-项目结构" class="headerlink" title="5.项目结构"></a>5.项目结构</h2><ul>
<li>如图所示：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/091.png" alt="image-20200909092153091"></p>
<ul>
<li>目录结构：<ul>
<li>spiders.data5u.py：爬虫文件，主要编写逻辑区域；</li>
<li>_ init_.py：初始化文件，一般不需要修改；</li>
<li>items.py：定义数据结构体；</li>
<li>middlewares：中间件文件；</li>
<li>pipelines.py：管道文件，从该文件中将数据传输保存为json、xls等文件；</li>
<li>settings.py：配置文件；</li>
</ul>
</li>
</ul>
<h2 id="6-爬虫开始"><a href="#6-爬虫开始" class="headerlink" title="6.爬虫开始"></a>6.爬虫开始</h2><h3 id="6-1-解析爬虫类"><a href="#6-1-解析爬虫类" class="headerlink" title="6.1 解析爬虫类"></a>6.1 解析爬虫类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建爬虫类 继承自scrapy.Spider 也就是原理中的Spider爬虫文件类，是一个基础类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItcastSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;itcast&#x27;</span>     <span class="comment">#爬虫名</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;itcast.cn&#x27;</span>]     <span class="comment">#允许爬取的域名范围</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;http://www.itcast.cn/channel/teacher.shtml&#x27;</span>]        <span class="comment">#最初请求url的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 用来处理start_urls地址对应的请求响应</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-Selectors选择器"><a href="#6-2-Selectors选择器" class="headerlink" title="6.2 Selectors选择器"></a>6.2 Selectors选择器</h3><ul>
<li>是scrapy提取数据的一套机制，通过特定的XPath或者CSS表达式来选去HTML中的某个部分；</li>
<li>Selector四个基本方法：<ul>
<li>正则表达式：暂不涉及；</li>
<li>xpath()：传入xpath()表达式，返回该表达式所对应的所有节点的selector list列表；</li>
<li>css()：传入css表达式，返回该表达式所对应的所有节点的selector list列表；</li>
<li>extract()：序列化该节点unicode字符串并返回list()，与get()使用效果相似；</li>
</ul>
</li>
<li>一般使用正则表达式和xpath即可，xpath请自行百度菜鸟或w3；</li>
</ul>
<h3 id="6-3-response-xpath"><a href="#6-3-response-xpath" class="headerlink" title="6.3 response.xpath"></a>6.3 response.xpath</h3><ul>
<li>response是返回的响应，使用xpath对返回的数据进行选择：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    <span class="comment"># 用来处理start_urls地址对应的请求响应</span></span><br><span class="line">    retName = response.xpath(<span class="string">&#x27;//*[@class=&quot;main_bot&quot;]/h2/text()&#x27;</span>)</span><br><span class="line">    print(retName)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>xpath是如何选择的呢：</p>
<ul>
<li>进入到start_urls网页（这本就是parse函数最初得到的相应数据），具体请自行学习xpath：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/095.png" alt="image-20200910201738870"></p>
</li>
</ul>
<ul>
<li>可以在cmd进入该项目目录中执行，也可直接在PyCharm Terminal执行：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scrapy crawl 爬虫名</span></span><br><span class="line">scrapy crawl itcast</span><br></pre></td></tr></table></figure>

<ul>
<li>得到结果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/092.png" alt="image-20200910195843555"></p>
<h3 id="6-4-LOG-LEVEL日志信息"><a href="#6-4-LOG-LEVEL日志信息" class="headerlink" title="6.4 LOG_LEVEL日志信息"></a>6.4 LOG_LEVEL日志信息</h3><ul>
<li>从上图中看见很多额外的信息，在<code>settings.py</code>文件中添加以下代码过滤日志信息：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOG_LEVEL = <span class="string">&#x27;WARNING&#x27;</span></span><br><span class="line"><span class="comment"># 该语句含义为只显示警告及以上级别（ERROR）的日志信息</span></span><br><span class="line"><span class="comment"># 日志信息有四个等级，从低到高分别为 DEBUG-&gt;INFO-&gt;WARNING-&gt;ERROR</span></span><br><span class="line"><span class="comment"># 对应含义为 					调试信息-&gt;普通信息-&gt;警告-&gt;错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重新执行上述代码可以看到已经只剩下输出信息：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/093.png" alt="image-20200910200554769"></p>
<h3 id="6-5-extract"><a href="#6-5-extract" class="headerlink" title="6.5 extract()"></a>6.5 extract()</h3><ul>
<li>根据6.3中使用的语句<code>/text()</code>应该返回的结果是具体的文本内容，也就是上图中的<code>data</code>数据部分，但是却发现不经处理直接返回的数据是整个<code>&lt;Selector&gt;</code>列表，此时应该使用 <code>extract()</code>函数处理得到具体数据的列表值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    <span class="comment"># 用来处理start_urls地址对应的请求响应</span></span><br><span class="line">    retNames = response.xpath(<span class="string">&#x27;//*[@class=&quot;main_bot&quot;]/h2/text()&#x27;</span>).extract()</span><br><span class="line">    print(retName)</span><br></pre></td></tr></table></figure>

<ul>
<li>再次执行就可以得到想要的信息啦：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/094.png" alt="image-20200910201223556"></p>
<h3 id="6-6-分组处理数据"><a href="#6-6-分组处理数据" class="headerlink" title="6.6 分组处理数据"></a>6.6 分组处理数据</h3><ul>
<li>刚刚我们获得的数据是在具体节点下所有的<code>h2</code>文本数据列表，但如果我们要将所有对应的数据进行分组呢？</li>
<li>只要使用一个变量用来存储所有的<code>&lt;Selector&gt;</code>列表（注意此处不能接extract()函数，否则得到的列表并不是响应数据<code>response</code>的类型则不能再下面调用），再使用for循环遍历列表中所有节点并依次获取数据即可：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    li_list = response.xpath(<span class="string">&#x27;//*[@class=&quot;clears&quot;]/li&#x27;</span>)</span><br><span class="line">    <span class="comment">#不能使用extract()，否则类型不同于response响应类型，则不能被循环调用</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        item = &#123;&#125;	<span class="comment">#定义字典变量用来存储数据</span></span><br><span class="line">        item[<span class="string">&quot;name&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/text()&#x27;</span>).extract()	<span class="comment">#. 表示从当前节点开始取</span></span><br><span class="line">        item[<span class="string">&quot;level&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/span/text()&#x27;</span>).extract()</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>

<ul>
<li>得到结果如图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/096.png" alt="image-20200910203824629"></p>
<ul>
<li><p>但是却发现输出数据的最前头和最后头都分别有四个空数据，这是为什么？</p>
</li>
<li><p>回顾刚刚代码中的<code>xpath(&#39;//*[@class=&quot;clears&quot;]/li&#39;)</code>，发现原网页中class属性不唯一！如图所示一共有四处节点使用了该class属性，而我们需要获取数据的节点只有一处，此处需要注意，class属性值并不唯一，可能被其它地方引用而导致我们获取无用数据：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/097.png" alt="image-20200910204220189"></p>
<ul>
<li>修改之后代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">	<span class="comment">#只需要修改父节点一处即可</span></span><br><span class="line">    li_list = response.xpath(<span class="string">&#x27;//*[@class=&quot;maincon&quot;]/ul/li&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        item = &#123;&#125;	<span class="comment">#定义字典变量用来存储数据</span></span><br><span class="line">        item[<span class="string">&quot;name&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/text()&#x27;</span>).extract()</span><br><span class="line">        item[<span class="string">&quot;level&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/span/text()&#x27;</span>).extract()</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>
<ul>
<li>如图所示，成功解决问题：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/098.png" alt="image-20200910204627728"></p>
<h2 id="7-pipelines管道文件简要介绍"><a href="#7-pipelines管道文件简要介绍" class="headerlink" title="7 pipelines管道文件简要介绍"></a>7 pipelines管道文件简要介绍</h2><h3 id="7-1-单爬虫使用"><a href="#7-1-单爬虫使用" class="headerlink" title="7.1 单爬虫使用"></a>7.1 单爬虫使用</h3><ul>
<li>刚刚我们获取的数据都是通过<code>print()</code>函数直接打印在终端上，那么接下来我们就要将这些文件通过pipelins管道文件传输出来，暂时也是使用<code>print()</code>，此处主要是简要讲述pipelines管道文件；</li>
<li>管道文件其实早就初始化在我们的spider文件中，也就是其中的pipelines.py文件，但在正式使用之前，需要到settings.py文件中进行配置：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在settings.py文件中找到被注释掉的这段代码并去掉注释即可使用</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="comment">#其中该字典元素的键名即为pipelines.py文件中的类名路径，后面的值300表示距离管道文件的距离，距离越近值越小表示越先经过该文件，可以设置多个值，通过不同的键值确定其顺序</span></span><br><span class="line">   <span class="string">&#x27;spiderStudy.pipelines.SpiderstudyPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">   <span class="string">&#x27;spiderStudy.pipelines.SpiderstudyPipeline1&#x27;</span>: <span class="number">301</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置完成后先在爬虫文件中将获取的数据返回给<code>pipelines.py</code>文件，只要通过一条语句即可完成：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    item = &#123;&#125;   <span class="comment">#定义字典变量用来存储数据</span></span><br><span class="line">    item[<span class="string">&quot;name&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/text()&#x27;</span>).extract()</span><br><span class="line">    item[<span class="string">&quot;level&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/span/text()&#x27;</span>).extract()</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<ul>
<li>最后在<code>pipelines.py</code>文件中编写逻辑代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderstudyPipeline</span>:</span></span><br><span class="line">    <span class="comment"># 该函数为默认接收并执行逻辑数据的函数，不可修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="comment"># 对所有返回的字典增加一个键值对</span></span><br><span class="line">        item[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br><span class="line">        <span class="comment"># 函数结束后必须返回其值，否则无法继续使用</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderstudyPipeline1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        print(item)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<ul>
<li>执行代码得到结果便可知其妙用：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/099.png" alt="image-20200910210416661"></p>
<ul>
<li>结束之后我们再重新回过头看一下爬虫文件中的<code>yield item</code>语句，这段语句放在for循环之内，表示每次得到一对数据就返回给管道文件一次，那么可不可以将含有所有元素的字典列表一次性返回给管道文件呢？我们来尝试一下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新建一个list变量用于存储所有的item值</span></span><br><span class="line">content_list = []</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">            item = &#123;&#125;   <span class="comment">#定义字典变量用来存储数据</span></span><br><span class="line">            item[<span class="string">&quot;name&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/text()&#x27;</span>).extract()</span><br><span class="line">            item[<span class="string">&quot;level&quot;</span>] = li.xpath(<span class="string">&#x27;./div[2]/h2/span/text()&#x27;</span>).extract()</span><br><span class="line">            content_list.append(item)</span><br><span class="line">        <span class="keyword">yield</span> content_list</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果为：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/100.png" alt="image-20200910211436369"></p>
<ul>
<li>直接报错，由此可知不能一次性返回一个列表；</li>
</ul>
<blockquote>
<p>其实最后可以总结一下yield传输值给pipelines.py文件时的过程，pipelines.py文件是对于每一次yield返回值都会进行一次逻辑运算的，而yield自身只能传输请求、字典或者None值，而不能传输list列表。</p>
</blockquote>
<blockquote>
<p>最后再讲一下extract()函数，这个函数调用时是直接返回list列表取得的所有值，而我们在分组单次数据获取时只需要获取一个值便可，一般会使用extract()[0]（获取数组中第一个值）来替代上述写法，但是extract()[0]有一个弊端就是如果列表中没有值不会返回任何值（连空字符串都没有），但yield却不能返回这种类型的值而会导致报错，于是我们更常用extract_first()来替代上一种写法，这种写法在列表中没有值时会返回一个None字符串，可以直接被yield传输    </p>
</blockquote>
<h3 id="7-2-多爬虫使用"><a href="#7-2-多爬虫使用" class="headerlink" title="7.2 多爬虫使用"></a>7.2 多爬虫使用</h3><ul>
<li><p>在同一个项目spiderStudy下，创建多个爬虫文件；</p>
</li>
<li><p>可以创建多个pipeline类用于接收来自不同爬虫文件的数据：</p>
<ul>
<li><p>通过以下两种方式处理不同的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过一个类来说明</span></span><br><span class="line">  <span class="comment">#1.在每个爬虫文件传入的item值中定义一个字典元素“come_from”,并且赋值，通过此值判断</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SpiderstudyPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">&quot;come_from&quot;</span>] == <span class="string">&quot;itcase&quot;</span>:</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">elif</span> ...:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> ...:</span><br><span class="line">              </span><br><span class="line">  </span><br><span class="line">  <span class="comment">#2.通过传入的spider参数判断，spider参数本身就是被传入的爬虫文件</span></span><br><span class="line">  	  <span class="comment">#其中spider.name变量就是spider爬虫文件最初定义的爬虫名</span></span><br><span class="line">        <span class="keyword">if</span> spider.name == <span class="string">&quot;itcase&quot;</span>:</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">elif</span> ...:</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">else</span> ...:</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="8-logging"><a href="#8-logging" class="headerlink" title="8.logging"></a>8.logging</h2><h3 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1 定义"></a>8.1 定义</h3><ul>
<li>手动调试并存储日志信息，有助于项目结束之后调试bug；</li>
</ul>
<h3 id="8-2-scrapy导入及使用"><a href="#8-2-scrapy导入及使用" class="headerlink" title="8.2 scrapy导入及使用"></a>8.2 scrapy导入及使用</h3><ul>
<li>第一种方式，直接使用原包：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入logging包</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将item信息以warning等级的信息存储为日志信息显示，设置存储为文件之后就不会在终端显示而只存储至文件中</span></span><br><span class="line"><span class="comment"># warning 还可为 debug、info、error，配合settings.py中的LOG_LEVEL使用</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    item = &#123;&#125;</span><br><span class="line">    item[<span class="string">&quot;come_from&quot;</span>] = <span class="string">&quot;itcast&quot;</span></span><br><span class="line">    logging.warning(item)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">#输出如下</span></span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">44</span>:<span class="number">37</span> [root] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">44</span>:<span class="number">37</span> [root] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">44</span>:<span class="number">37</span> [root] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">44</span>:<span class="number">37</span> [root] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">44</span>:<span class="number">37</span> [root] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方式，使用函数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"><span class="comment">#全局定义一次，其它文件可以直接引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    item = &#123;&#125;</span><br><span class="line">    item[<span class="string">&quot;come_from&quot;</span>] = <span class="string">&quot;itcast&quot;</span></span><br><span class="line">    logger.warning(item)</span><br><span class="line">    </span><br><span class="line">&gt;<span class="comment">#输出如下</span></span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">18</span> [spiderStudy.spiders.itcast] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">18</span> [spiderStudy.spiders.itcast] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">18</span> [spiderStudy.spiders.itcast] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">18</span> [spiderStudy.spiders.itcast] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">18</span> [spiderStudy.spiders.itcast] WARNING: &#123;<span class="string">&#x27;come_from&#x27;</span>: <span class="string">&#x27;itcast&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对比之后可以发现第二种函数调用方法可以显示出所传入参数来自于哪个爬虫文件或者管道文件，更加有利于信息整理，其实日志信息一般放至pipelines.py文件中用来统一处理数据信息</p>
</blockquote>
<h3 id="8-3-将logging文件存储至日志文件"><a href="#8-3-将logging文件存储至日志文件" class="headerlink" title="8.3 将logging文件存储至日志文件"></a>8.3 将logging文件存储至日志文件</h3><ul>
<li>在<code>settings.py</code>文件中添加<code>LOG_FILE = &quot;./log.log&quot;</code>即可存储至代码目录下为<code>log.log</code>文件；</li>
</ul>
<h3 id="8-4-普通python文件调用logging包"><a href="#8-4-普通python文件调用logging包" class="headerlink" title="8.4 普通python文件调用logging包"></a>8.4 普通python文件调用logging包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">					level=logging.INFO,</span><br><span class="line">    				format=<span class="string">&quot;&quot;</span>	<span class="comment">#百度查找具体格式即可</span></span><br><span class="line">    				filename=<span class="string">&quot;./log.log&quot;</span></span><br><span class="line">					)	<span class="comment">#设置日志输出的样式和格式，</span></span><br><span class="line">logger = logging.getLogger(__name__)	<span class="comment">#实例化logger，在任何py文件中直接调用logger即可</span></span><br><span class="line"><span class="comment"># 调用格式 from log.a(省略.py) import logger</span></span><br><span class="line"><span class="comment">#用以下语句来观看结果</span></span><br><span class="line">logger.info(<span class="string">&quot;info&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="9-实现翻页请求"><a href="#9-实现翻页请求" class="headerlink" title="9.实现翻页请求"></a>9.实现翻页请求</h2><ul>
<li>注：由于原学习视频是18年的，而现在20年很多网站都设置反扒，不好使用原案例，直接贴代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self,response</span>):</span></span><br><span class="line">	tr_list = response.xpath(<span class="string">&quot;//table[eclass=&#x27;tablelist&#x27;]/tr&quot;</span>)[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> tr <span class="keyword">in</span> tr_list:</span><br><span class="line">		item = []</span><br><span class="line">		item[<span class="string">&quot;title&quot;</span>] = tr.xpath(<span class="string">&quot;./td[1]/a/text()&quot;</span>).extract_first(</span><br><span class="line">		item[<span class="string">&quot;position&quot;</span>] = tr.xpath(<span class="string">&quot;./td[2]/text()&quot;</span>).extract_first(</span><br><span class="line">		item[ <span class="string">&quot;publish_date&quot;</span>] = tr.xpath(<span class="string">&quot;./td[5]/text()&quot;</span>).extract_first()</span><br><span class="line">		<span class="keyword">yield</span> item</span><br><span class="line">	<span class="comment">#找到下一页的url地址</span></span><br><span class="line">	next_url = response.xpath(<span class="string">&quot;//a[@id=&#x27;next&#x27;]/@href&quot;</span>).extract_first()</span><br><span class="line">	<span class="keyword">if</span> next_url != <span class="string">&quot;javascript:; &quot;</span>:</span><br><span class="line">		next_url = <span class="string">&quot;http://hr.tencent.com/&quot;</span> +next_url</span><br><span class="line">		<span class="keyword">yield</span> scrapy.Request(</span><br><span class="line">			next_url,</span><br><span class="line">			callback=self.parse</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>并且从原网站中拿到请求头中的UserAgent数据贴到settings.py文件中：</p>
</li>
<li><p>在网站Network中打开原网页的Response页面，注意与直接检查HTML代码中tbody标签是否有无，实质上我们请求得到的响应式前者网页源代码，而Response中可能没有tbody标签而导致无法使用；</p>
</li>
</ul>
<h2 id="10-scrapy-Request"><a href="#10-scrapy-Request" class="headerlink" title="10.scrapy.Request()"></a>10.scrapy.Request()</h2><p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/101.png" alt="image-20200911202745519"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot(一)</title>
    <url>/2020/10/23/SpringBoot/SpringBoot%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>SpringBoot</p>
</blockquote>
<ul>
<li>官方文档：<a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/htmlsingle/#boot-features-external-config">https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/htmlsingle/#boot-features-external-config</a></li>
</ul>
<h2 id="1-创建SpringBoot文件"><a href="#1-创建SpringBoot文件" class="headerlink" title="1.创建SpringBoot文件"></a>1.创建SpringBoot文件</h2><h3 id="1-1-官网创建文件并下载，使用IDEA打开"><a href="#1-1-官网创建文件并下载，使用IDEA打开" class="headerlink" title="1.1 官网创建文件并下载，使用IDEA打开"></a>1.1 官网创建文件并下载，使用IDEA打开</h3><h3 id="1-2-IDEA创建"><a href="#1-2-IDEA创建" class="headerlink" title="1.2 IDEA创建"></a>1.2 IDEA创建</h3><ul>
<li>New Project -&gt; Spring Initializr（本质也是从官网下载的模板格式）；</li>
<li>添加 java web 依赖；</li>
</ul>
<h2 id="2-文件简析"><a href="#2-文件简析" class="headerlink" title="2.文件简析"></a>2.文件简析</h2><h3 id="2-1-pom-xml"><a href="#2-1-pom-xml" class="headerlink" title="2.1 pom.xml"></a>2.1 pom.xml</h3><ul>
<li><p>配置文件，主要有四个部分：</p>
<ul>
<li>项目元数据信息：创建时输入的Project Metadata部分，也就是Meaven项目的基本元素，包括groupId、artifactId、version、name、description等；</li>
<li>parent：继承<code>spring-boot-starter-parent</code>的依赖管理、控制版本和打包等内容；</li>
<li>dependencies：项目具体依赖，下面包含了<code>spring-boot-starter-web</code>用于实现HTTP接口（该依赖包含了Spring MVC，且使用Tomcat作为默认嵌入式容器），<code>spring-boot-starter-test</code>是用于编写后续单元测试的依赖包：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  在这个标签中添加  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  添加依赖，格式为 spring-boot-starter- 这是springboot启动器的标准格式     --&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--  web依赖，tomcat      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>build：构件配置部分，默认使用了<code>spring-boot-maven-plugin</code>，即打jar包插件；</li>
</ul>
</li>
</ul>
<a id="more"></a>


<h3 id="2-2-application-properties"><a href="#2-2-application-properties" class="headerlink" title="2.2 application.properties"></a>2.2 application.properties</h3><ul>
<li><code>src/main/javaresource/application.properties</code>目录核心配置文件；</li>
<li>重写服务属性，稍后详述；</li>
<li>编辑对象、定义属性；</li>
<li>常用小服务：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接更改项目端口号即可，修改之后再次访问该端口才能成功</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure>





<h3 id="2-3-banner-txt（小彩蛋）"><a href="#2-3-banner-txt（小彩蛋）" class="headerlink" title="2.3 banner.txt（小彩蛋）"></a>2.3 banner.txt（小彩蛋）</h3><ul>
<li>自建文件，重写启动器banner服务，<code>src/main/javaresource/banner.txt</code>目录文件；</li>
<li>网站：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></li>
<li>例：</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////////////////////////////////</span><br><span class="line">//                          _ooOoo_                               //</span><br><span class="line">//                         o8888888o                              //</span><br><span class="line">//                         88&quot; . &quot;88                              //</span><br><span class="line">//                         (| ^_^ |)                              //</span><br><span class="line">//                         O\  =  /O                              //</span><br><span class="line">//                      ____/`---&#x27;\____                           //</span><br><span class="line">//                    .&#x27;  \\|     |//  `.                         //</span><br><span class="line">//                   /  \\|||  :  |||//  \                        //</span><br><span class="line">//                  /  _||||| -:- |||||-  \                       //</span><br><span class="line">//                  |   | \\\  -  /// |   |                       //</span><br><span class="line">//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //</span><br><span class="line">//                  \  .-\__  `-`  ___/-. /                       //</span><br><span class="line">//                ___`. .&#x27;  /--.--\  `. . ___                     //</span><br><span class="line">//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //</span><br><span class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><br><span class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><br><span class="line">//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //</span><br><span class="line">//                           `=---=&#x27;                              //</span><br><span class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><br><span class="line">//            佛祖保佑       永不宕机     永无BUG                    //</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br></pre></td></tr></table></figure>



<h3 id="2-4-XXXApplication-java"><a href="#2-4-XXXApplication-java" class="headerlink" title="2.4 XXXApplication.java"></a>2.4 XXXApplication.java</h3><ul>
<li><code>src/main/java/com/kun/XXXApplication.java</code>目录文件；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注这是一个SpringBoot应用，加载所有资源类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">//程序入口</span></span><br><span class="line">    <span class="comment">//run，开启了一个服务，参数一：应用入口的类，参数二：命令行输入的参数类</span></span><br><span class="line">    <span class="comment">/*SpringApplication实例化，做了以下四项工作：</span></span><br><span class="line"><span class="comment">    1.判断该应用类型是普通java项目还是Web项目</span></span><br><span class="line"><span class="comment">    2.查找并加载所有可用初始化器，设置到initializers属性中</span></span><br><span class="line"><span class="comment">    3.找出所有的应用程序监听器，设置到listeners属性中</span></span><br><span class="line"><span class="comment">    4.推断并设置main方法的定义类，找到运行的主类</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-XXXApplicationTests-java"><a href="#2-5-XXXApplicationTests-java" class="headerlink" title="2.5 XXXApplicationTests.java"></a>2.5 XXXApplicationTests.java</h3><ul>
<li><code>test/java/com/kun/XXXApplicationTests.java</code>目录文件；</li>
<li>实现单元测试功能；</li>
</ul>
<h3 id="2-6-自建框架层"><a href="#2-6-自建框架层" class="headerlink" title="2.6 自建框架层"></a>2.6 自建框架层</h3><ul>
<li>在<code>src/main/java/com/kun/</code>最底层包目录下新建<code>config</code>、<code>controller</code>、<code>dao</code>、<code>pojo</code>等包，这些具体用到再详细讲解，也可以参考博客简略了解一下：<a href="https://www.cnblogs.com/tooyi/p/13340374.html">https://www.cnblogs.com/tooyi/p/13340374.html</a>；</li>
<li>为说明几个常用注解以及习惯注解的用法，新建<code>controller</code>包，并在该目录下新建<code>HelloController.java</code>文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Controller注解标注说明并被加载</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//使用Mapping类注解来映射请求，即请求/hello时响应回该类</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在/hello地址请求之下再请求地址/hello即可获得下列响应</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="comment">//当请求/hello/hello时，响应主体部分为hello()方法</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解和反射机制请参考博客：<a href="https://kunpw.cn/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"><a href="https://kunpw.cn/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/">https://kunpw.cn/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</a></a></li>
</ul>
<h2 id="3-yaml（yml）语法"><a href="#3-yaml（yml）语法" class="headerlink" title="3.yaml（yml）语法"></a>3.yaml（yml）语法</h2><ul>
<li>yaml文件是对properties文件的替代，但比properties更实用，所以一般使用yaml；</li>
<li>删除application.properties文件，新建application.yaml（.yml）；</li>
</ul>
<h3 id="3-1-常用语法："><a href="#3-1-常用语法：" class="headerlink" title="3.1 常用语法："></a>3.1 常用语法：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.基础语法</span></span><br><span class="line"><span class="comment"># 修改自动配置的默认值，其中 : 后必须接空格</span></span><br><span class="line"><span class="comment"># yaml 对空格很敏感，很像python  而properties只能保存键值对</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yaml基本语法</span></span><br><span class="line"><span class="comment"># 定义参数使用key-value</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">zhaoxiaoan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义对象</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhaoxiaoan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象的行内写法</span></span><br><span class="line"><span class="attr">teacher:</span> &#123;<span class="attr">name:</span> <span class="string">zhao</span>,<span class="string">age</span> <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数组</span></span><br><span class="line"><span class="attr">pets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组的行内写法</span></span><br><span class="line"><span class="attr">pet:</span> [<span class="string">cat</span>,<span class="string">dog</span>,<span class="string">pig</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># EL表达式</span></span><br><span class="line"><span class="attr">age:</span> <span class="string">$&#123;random.int&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 占位符</span></span><br><span class="line"><span class="attr">person:</span> </span><br><span class="line">	<span class="attr">hello:</span> <span class="string">happy</span></span><br><span class="line">	<span class="attr">dog:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">$&#123;person.hello:hello&#125;_旺财</span></span><br><span class="line"><span class="comment"># 如果没有就直接为空，有则占位显示，即happy_旺财</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-重点：给实体类赋值："><a href="#3-2-重点：给实体类赋值：" class="headerlink" title="3.2 重点：给实体类赋值："></a>3.2 重点：给实体类赋值：</h3><ul>
<li>新建数据类：新建pojo/Dog.java、pojo/Person.java类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参无参构造器、get/set方法以及toString方法，后续这些方法不再细列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kun.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean happy;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//省略各方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>赋值：</p>
<ul>
<li>直接new对象；</li>
</ul>
</li>
<li><p>原生注解赋值：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;zhaoxiaoan&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;3&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>yaml文件赋值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.0</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhaoxiaoan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">happy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2020</span><span class="string">/10/22</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">study</span></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">旺财</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">/*@PropertySource(value = &quot;classpath:application.yaml&quot;)</span></span><br><span class="line"><span class="comment">通过该注解设置装配文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//通过ConfigurationProperties(prefix = &quot;person&quot;)注解绑定映射yaml文件中person对象</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean happy;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<ul>
<li><p>单元测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.0</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自动装配类</span></span><br><span class="line">  <span class="comment">//如果有多个对象Dog，可以通过@Qualifier选择具体的对象</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Dog dog;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出为：</span></span><br><span class="line">Dog&#123;name=<span class="string">&#x27;旺财&#x27;</span>, age=<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出为：</span></span><br><span class="line">Person&#123;name=<span class="string">&#x27;zhaoxiaoan&#x27;</span>, age=<span class="number">3</span>, happy=<span class="keyword">true</span>, birth=Thu Oct <span class="number">22</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">2020</span>, maps=&#123;k1=v1, k2=v2&#125;, lists=[code, music, study], dog=Dog&#123;name=<span class="string">&#x27;旺财&#x27;</span>, age=<span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="3-3-yaml-ConfigurationProperties与原properties-value比较图示："><a href="#3-3-yaml-ConfigurationProperties与原properties-value比较图示：" class="headerlink" title="3.3 yaml-ConfigurationProperties与原properties-value比较图示："></a>3.3 yaml-ConfigurationProperties与原properties-value比较图示：</h3><p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/SpringBoot/001.png" alt="image-20201022231250885"></p>
<ul>
<li>功能：即yaml可以直接映射到对象而properties需要使用@Value一个一个赋值；</li>
<li>松散绑定：即yaml中的last-name和类中的lastName是一样的，<code>-</code>后接的字母转为大写；</li>
<li>JSR303数据校验：可以在字段增加一层过滤验证，保证数据合法性；</li>
<li>复杂类型封装：yml中可以封装对象，使用@Value就不支持；</li>
</ul>
<ul>
<li><p>JSR303数据校验（类似于html中input标签中选中的url、email等功能，可以自动校验输入）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@PropertySource(value = &quot;classpath:application.yaml&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span><span class="comment">//开启数据校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Email</span><span class="comment">//对email赋值开启Email数据校验，假设对name属性开启Email验证</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean happy;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意，在SpringBoot2.3以后版本由于spring-boot-starter-web的依赖项已经去除了validate依赖，所以需要手动添加依赖才能生效：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.17.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次测试则会得到报错结果：</p>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &#x27;person&#x27; to com.kun.pojo.Person failed:</span><br><span class="line"></span><br><span class="line">    Property: person.name</span><br><span class="line">    Value: zhaoxiaoan</span><br><span class="line">    Origin: class path resource [application.yaml]:2:9</span><br><span class="line">    Reason: 不是一个合法的电子邮件地址</span><br></pre></td></tr></table></figure>

<ul>
<li>修改name属性赋值即可；</li>
<li>JSR303校验注解类：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/SpringBoot/002.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/SpringBoot/003.png" alt="img"></p>
<ul>
<li>小技巧：可以进入注解原文件查看各种注解值并自主修改；</li>
</ul>
</li>
</ul>
<h2 id="4-yaml配置文件位置和多环境配置"><a href="#4-yaml配置文件位置和多环境配置" class="headerlink" title="4.yaml配置文件位置和多环境配置"></a>4.yaml配置文件位置和多环境配置</h2><h3 id="4-1-配置文件"><a href="#4-1-配置文件" class="headerlink" title="4.1 配置文件"></a>4.1 配置文件</h3><ol>
<li><code>file:./config/</code></li>
<li><code>file:./</code></li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ol>
<ul>
<li><p>file即项目目录，classpath即<code>src/main/resources</code>目录；</p>
</li>
<li><p>这既是yaml配置文件可存放的位置，也是其配置文件加载的优先级权重顺序，即按照权重覆盖相同属性及服务配置；</p>
</li>
</ul>
<h3 id="4-2-多环境配置"><a href="#4-2-多环境配置" class="headerlink" title="4.2 多环境配置"></a>4.2 多环境配置</h3><ul>
<li><p>现实开发中可能会有三种环境版本：</p>
<ul>
<li>普通环境：application.properties配置文件；</li>
<li>测试环境：application-test.properties配置文件；</li>
<li>开发环境：application-dev.properties配置文件；</li>
</ul>
</li>
<li><p>yaml格式和properties格式配置环境对比：</p>
<ul>
<li><p>在properties文件格式下徐亚单独配置多个文件才能生效；</p>
</li>
<li><p>而在yaml格式中则实现多文档模块，步骤更为简便：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过`---`符号分割不同配置环境，并使用spring.profiles属性说明即可</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<h2 id="5-自动装配原理（重点）"><a href="#5-自动装配原理（重点）" class="headerlink" title="5.自动装配原理（重点）"></a>5.自动装配原理（重点）</h2><p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/SpringBoot/004.png" alt="@SpringBootApplication"></p>
<h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h3><ul>
<li><p>从<code>src/main/java/com/kun/XXXApplication.java</code>程序入口文件<code>@SpringBootApplication</code>注解出发，依次查看父级文件，了解其自动装配原理：</p>
<ul>
<li>@ComponentScan：其父级文件注解，用来实现扫描当前主启动类同级的包；</li>
<li>@SpringBootConfiguration——&gt;@Configuration——&gt;@Component：分别实现springboot配置、spring配置和基本组件；</li>
<li>@EnableAutoConfiguration：自动装配，核心包：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">—&gt;<span class="meta">@AutoConfigurationPackage</span>:自动配置包</span><br><span class="line">	-&gt;<span class="meta">@Import(&#123;Registrar.class&#125;)</span>:自动配置包注册</span><br><span class="line">-&gt;<span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>:自动配置导入选择器</span><br><span class="line">    -&gt;getAutoConfigurationEntry():获得自动配置的实体入口</span><br><span class="line">    -&gt;getCandidateConfigurations():获取候选配置</span><br><span class="line">    	-&gt;<span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    		<span class="keyword">return</span> EnableAutoConfiguration.class; //标注了EnableAutoConfiguration注解类的所有配置</span><br><span class="line">		&#125;</span><br><span class="line">    -&gt;loadFactoryNames():获取所有的加载配置名字</span><br><span class="line">        -&gt;loadSpringFactories():加载所有的Spring工厂</span><br><span class="line">			-&gt;classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>):加载项目资源</span><br><span class="line">            -&gt;ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>):加载系统资源</span><br><span class="line">        	-&gt;META-INF/spring.factories:从该文件获取资源，自动装配的核心文件</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>META-INF/spring.factories</code>文件：存在于External Libraries中</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/SpringBoot/005.png" alt="image-20201023160248610"></p>
<ul>
<li><p>文件内容：<br><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/SpringBoot/006.png" alt="image-20201023160458985"></p>
<ul>
<li><p>所有已经配置好的依赖都在这里，其它只能自己配置；</p>
</li>
<li><p>随便进入一个源文件（可能只是.class文件，根据提示下载源java文件查看）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnXXX</span> <span class="comment">//系列核心注解，其中每个文件都有，用来判断是否满足一系列条件才加载该文件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>结论一：SpringBoot所有自动装配都是在启动的时候扫描并加载的，其中所有的自动装配类都在<code>spring.factories</code>文件中，只有在pom.xml文件中添加了依赖才满足生效条件并且自动装配生效；</p>
</li>
</ul>
<h3 id="5-2-yaml文件与自动装配"><a href="#5-2-yaml文件与自动装配" class="headerlink" title="5.2 yaml文件与自动装配"></a>5.2 yaml文件与自动装配</h3><ul>
<li><p>yaml文件内能够重写的服务实质上和spring.factories文件相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span> <span class="comment">//某些自动装配文件中含有此注解，即标注可以在properties配置文件中重写属性值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在构造器类中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(ServerProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties.getServlet().getEncoding();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//其中ServerProperties文件中的属性即与yaml配置文件绑定，可以重写配置</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ServerProperties：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="comment">//该注解中prefix值表示yaml文件中重写配置该类属性的前缀</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样可以从yaml文件中根据配置属性返回到上级XXXProperties文件查看所有同类属性；</li>
</ul>
</li>
<li><p>结论二：springfactories中定义好的自动装配类XXXAutoConfiguration加载XXXProperties文件，而XXXProperties文件则与配置文件.properties/.yaml一一绑定，即可通过.yaml配置文件修改配置并被加载；</p>
</li>
<li><p>开启Debug，查看具体哪些配置类被加载：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在application.yaml文件中开启Spring调试类</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>测试结果：</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Positive matches: 已经启用生效的类</span><br><span class="line">Negative matches: 没有开启生效的类</span><br><span class="line">Unconditional classes: 没有条件的类</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="5-3-SpringApplication-run启动"><a href="#5-3-SpringApplication-run启动" class="headerlink" title="5.3 SpringApplication.run启动"></a>5.3 SpringApplication.run启动</h3><ul>
<li><p><code>src/main/java/com/kun/XXXApplication.java</code>文件中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication.run(DemoApplication.class, args);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法主要分两部分：</p>
<ul>
<li>SpringApplication实例化；</li>
<li>run方法执行；</li>
</ul>
</li>
<li><p>做了四项工作：</p>
<ul>
<li>判断该应用类型是普通java项目还是Web项目；</li>
<li>查找并加载所有可用初始化器，设置到initializers属性中；</li>
<li>找出所有的应用程序监听器，设置到listeners属性中；</li>
<li>推断并设置main方法的定义类，找到运行的主类；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue（3.开发实例演示(含webpack)）</title>
    <url>/2020/09/06/vue/3.vue%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="1-解剖初始化模板"><a href="#1-解剖初始化模板" class="headerlink" title="1.解剖初始化模板"></a>1.解剖初始化模板</h2><h3 id="1-1-vue文件"><a href="#1-1-vue文件" class="headerlink" title="1.1 vue文件"></a>1.1 vue文件</h3><ul>
<li>如图所示，对于一个新建的vue文件而言，其中标签分为三个部分：<ul>
<li>template标签：这一块模板区域用于编写html代码块，其实就是component组建中的template属性内容，用作模板显示，而这个模板component的名字就是该vue文件名，使用时导入即可；</li>
<li>script标签：默认导出；</li>
<li>style标签：scoped属性相当于private，确保其中的样式只在本style样式中有效；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/063.png" alt="image-20200904130511003"></p>
<a id="more"></a>


<h3 id="1-2-App-vue和main-js"><a href="#1-2-App-vue和main-js" class="headerlink" title="1.2 App.vue和main.js"></a>1.2 App.vue和main.js</h3><ul>
<li>创建新项目时src目录下模板文件只需要保留App.vue和main.js即可；</li>
<li>App.vue中template模板相当于主模板，其中可以直接通过组件标签调用其它组件模板，相当于没有slot便签的限定而可以自由嵌套插槽；</li>
<li>App.vue组件用来传递给main.js，main.js是webpack中设置的默认入口文件，它只需要绑定App.vue文件并且完成一些组件的初始化和申明使用即可；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/066.png" alt="image-20200904131915497"></p>
<h2 id="2-webpack"><a href="#2-webpack" class="headerlink" title="2.webpack"></a>2.webpack</h2><h3 id="2-1-基础概念"><a href="#2-1-基础概念" class="headerlink" title="2.1 基础概念"></a>2.1 基础概念</h3><ul>
<li>webpack的本质是将新版本的vue组件框架打包成ES5版本支持的js代码；</li>
</ul>
<h3 id="2-2-实例步骤"><a href="#2-2-实例步骤" class="headerlink" title="2.2 实例步骤"></a>2.2 实例步骤</h3><ul>
<li>新建项目<code>webpack-study</code>；</li>
<li>打开之后创建<code>modules</code>文件目录；</li>
<li>在<code>modules</code>文件目录下创建<code>hello.js</code>作为模板，代码为：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴露一个方法，在同一个文件中暴露的多个方法最终被接受到同一个对象中</span></span><br><span class="line"><span class="built_in">exports</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;Vue webpack&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.sayHi2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;JavaScript&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.sayHi3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;JavaSE&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.sayHi4 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;Linux&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>modules</code>文件目录下创建<code>main.js</code>作为入口，代码为：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受一个文件中暴露的所有方法，类似于java的类</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line">hello.sayHi();</span><br><span class="line">hello.sayHi2();</span><br><span class="line">hello.sayHi3();</span><br><span class="line">hello.sayHi4();</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>webpack-study</code>目录下创建<code>webpack.config.js</code>文件用来设置webpack参数，代码为：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//entry设置程序入口</span></span><br><span class="line">    entry:<span class="string">&#x27;./modules/main.js&#x27;</span>,</span><br><span class="line">    <span class="comment">//output设置程序打包输出目录</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">&quot;./js/bundle.js&quot;</span> <span class="comment">//这是标准格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>在管理员模式下进入文件目录，使用指令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/059.png" alt="image-20200903172445440"></p>
<ul>
<li>这个<code>bundle.js</code>文件就是打包后得到的js文件，也就是最终拿来使用的文件；</li>
<li>最后如上图创建<code>index.html</code>文件，作为整个程序的首页，添加<code>&lt;script&gt;</code>标签引入<code>bundle.js</code>文件：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;dist/js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/060.png" alt="image-20200903172940366"></p>
<blockquote>
<p>大功告成！整个过程一目了然。</p>
</blockquote>
<hr>
<h2 id="3-vue-router（重点）"><a href="#3-vue-router（重点）" class="headerlink" title="3.vue-router（重点）"></a>3.<code>vue-router（重点）</code></h2><h3 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title="3.1 基础概念"></a>3.1 基础概念</h3><ul>
<li><p>实现多个页面跳转的功能；</p>
</li>
<li><p>能够实现部分组件的页面改变而不影响其它组件部分；</p>
</li>
<li><p>实质并不会通过服务器后端实现链接跳转，而是前端直接修改并且即时刷新显示</p>
</li>
</ul>
<h3 id="3-2-实例步骤"><a href="#3-2-实例步骤" class="headerlink" title="3.2 实例步骤"></a>3.2 实例步骤</h3><ul>
<li><p>在<code>components</code>目录下新建两个文件<code>main.vue</code>和<code>content.vue</code>；</p>
</li>
<li><p>如图所示，只在<code>template</code>标签内加入一段标题即可：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/063.png" alt="image-20200904123949339"></p>
<ul>
<li>在<code>src</code>目录下新建目录<code>router</code>，下建<code>index.js</code>文件，代码如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入vue和vue-router组件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">//导入新建的content.vue和main.vue组件</span></span><br><span class="line"><span class="keyword">import</span> Content <span class="keyword">from</span> <span class="string">&quot;../components/content&quot;</span></span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">&quot;../components/main&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//安装路由，相当于类的实例化操作</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//路由路径，在App.vue中用于link to连接的部分</span></span><br><span class="line">      path:<span class="string">&#x27;/content&#x27;</span>,</span><br><span class="line">      <span class="comment">//路由名称，也可用于link to连接</span></span><br><span class="line">      name:<span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">      <span class="comment">//跳转的组件</span></span><br><span class="line">      component:Content</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//路由路径，在App.vue中用于link to连接的部分</span></span><br><span class="line">      path:<span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      <span class="comment">//路由名称，也可用于link to连接</span></span><br><span class="line">      name:<span class="string">&#x27;main&#x27;</span>,</span><br><span class="line">      <span class="comment">//跳转的组件</span></span><br><span class="line">      component:Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>main.js</code>入口文件中导入<code>vue-router</code>：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span> <span class="comment">//自动扫描路由配置</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router, <span class="comment">//直接使用即可</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>App.vue</code>文件中添加模板代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!--router只有两个标签，link为链接标签，view为显示视图标签，to属性即为转到路径，该路径是index.js中配置的路径--&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;main&quot;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容页&lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;!--没有view标签则无法显示内容--&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>部署服务器<code>npm run dev</code>后网页显示如图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/064.png"></p>
<ul>
<li>附：最终目录，其余部分已删除：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/065.png" alt="image-20200904125959596"></p>
<hr>
<h2 id="4-实例工程（运用element-UI）"><a href="#4-实例工程（运用element-UI）" class="headerlink" title="4.实例工程（运用element-UI）"></a>4.实例工程（运用element-UI）</h2><h3 id="4-1-新建项目并配置依赖"><a href="#4-1-新建项目并配置依赖" class="headerlink" title="4.1 新建项目并配置依赖"></a>4.1 新建项目并配置依赖</h3><ul>
<li><p>使用管理员模式运行命令行，并进入到目录下准备新建项目；</p>
</li>
<li><p>创建一个名为<code>hello-vue</code>的工程项目：<code>vue init webpack hello-vue</code>，接下来的步骤请参看博客：<a href="https://blog.csdn.net/weixin_44339531/article/details/108384498">Vue开发环境配置</a></p>
</li>
<li><p>新建之后，执行以下命令：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> he1lo-vue</span><br><span class="line"><span class="comment">#安装vue-router</span></span><br><span class="line">npm install vue-router --save- dev</span><br><span class="line"><span class="comment">#安装element- ui</span></span><br><span class="line">cnpm i element-ui -S</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">cnpm install</span><br><span class="line"><span class="comment">#安装SAsS加戟器</span></span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"><span class="comment">#启动测试</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<ul>
<li>启动测试后可以正常通过端口访问即可；</li>
</ul>
<h3 id="4-2-修改配置文件"><a href="#4-2-修改配置文件" class="headerlink" title="4.2 修改配置文件"></a>4.2 修改配置文件</h3><ul>
<li>在IDEA中打开工程项目，并在<code>package.json</code>文件中修改以下内容（sass版本过高需手动调低）：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/067.png"></p>
<ul>
<li>修改完毕重新安装依赖：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure>



<h3 id="4-3-修改初始src"><a href="#4-3-修改初始src" class="headerlink" title="4.3 修改初始src"></a>4.3 修改初始src</h3><ul>
<li>按照<code>vue-router</code>删改，最终效果图如下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/068.png" alt="image-20200904144820476"></p>
<h3 id="4-4-新建目录及文件"><a href="#4-4-新建目录及文件" class="headerlink" title="4.4 新建目录及文件"></a>4.4 新建目录及文件</h3><ul>
<li>新建项目目录router用来存放路由配置文件<code>index.js</code>；</li>
<li>新建项目目录view用来存放视图组件，而components组件专门存放功能组件，明确分工；</li>
<li>在view目录下新建<code>Login.vue</code>文件和<code>Main.vue</code>文件；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/069.png" alt="image-20200904145015407"></p>
<h3 id="4-5-使用element-ui组件"><a href="#4-5-使用element-ui组件" class="headerlink" title="4.5 使用element-ui组件"></a>4.5 使用element-ui组件</h3><ul>
<li><p>打开element组件：<a href="https://element.eleme.cn/#/zh-CN/component/installation">https://element.eleme.cn/#/zh-CN/component/installation</a>；</p>
</li>
<li><p>如图，复制表单代码完全覆盖Login.vue文件（在el-form标签外添加template标签，否则无法运行），并对<code>Main.vue</code>文件添加简单文字“首页”：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/070.png" alt="image-20200904145542362"></p>
<ul>
<li>所有视图组件都是独立的，接下来配置路由<code>index.js</code>文件，使其能够联系起来：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">&#x27;../view/Main&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;../view/Login&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:<span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      component:Main</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      path:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      component:Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="4-6-配置main-js文件"><a href="#4-6-配置main-js文件" class="headerlink" title="4.6 配置main.js文件"></a>4.6 配置main.js文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(router);</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>并在<code>App.vue</code>中添加路由显示；</li>
<li>最终成果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/071.png" alt="image-20200904153130970"></p>
<hr>
<h2 id="5-路由嵌套"><a href="#5-路由嵌套" class="headerlink" title="5.路由嵌套"></a>5.路由嵌套</h2><h3 id="5-1-基础概念"><a href="#5-1-基础概念" class="headerlink" title="5.1 基础概念"></a>5.1 基础概念</h3><ul>
<li>路由嵌套可以实现外框架组件不变而仅改变内组件；</li>
</ul>
<h3 id="5-2-实例步骤"><a href="#5-2-实例步骤" class="headerlink" title="5.2 实例步骤"></a>5.2 实例步骤</h3><ul>
<li>接4工程；</li>
<li>在view目录下创建子目录user，并在该目录下创建两个新文件，新文件中仅配置一行文字：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/073.png" alt="image-20200904162145636"></p>
<ul>
<li>在路由<code>index.js</code>文件中添加子路由：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:<span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      component:Main,</span><br><span class="line">      children:[	</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">&#x27;/user/listone&#x27;</span>,<span class="attr">component</span>:UserListOne&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">&#x27;/user/listtwo&#x27;</span>,<span class="attr">component</span>:UserListTwo&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      path:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      component:Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>对应更改<code>Main.vue</code>文件，导入侧边栏，并在侧边栏中添加路由连接和路由视图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;el-radio-group v-model&#x3D;&quot;isCollapse&quot; style&#x3D;&quot;margin-bottom: 20px;&quot;&gt;</span><br><span class="line">    &lt;el-radio-button :label&#x3D;&quot;false&quot;&gt;展开&lt;&#x2F;el-radio-button&gt;</span><br><span class="line">    &lt;el-radio-button :label&#x3D;&quot;true&quot;&gt;收起&lt;&#x2F;el-radio-button&gt;</span><br><span class="line">  &lt;&#x2F;el-radio-group&gt;</span><br><span class="line">  &lt;el-menu default-active&#x3D;&quot;1-4-1&quot; class&#x3D;&quot;el-menu-vertical-demo&quot; @open&#x3D;&quot;handleOpen&quot; @close&#x3D;&quot;handleClose&quot; :collapse&#x3D;&quot;isCollapse&quot;&gt;</span><br><span class="line">    &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">      &lt;template slot&#x3D;&quot;title&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span slot&#x3D;&quot;title&quot;&gt;个人中心&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;el-menu-item-group&gt;</span><br><span class="line">        &lt;span slot&#x3D;&quot;title&quot;&gt;分组一&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;!--添加路由链接--&gt;</span><br><span class="line">        &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;&lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;listone&quot;&gt;账号设置&lt;&#x2F;router-link&gt;&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">        &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;&lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;listtwo&quot;&gt;密码设置&lt;&#x2F;router-link&gt;&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">        &lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;选项3&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">      &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">      &lt;el-menu-item-group title&#x3D;&quot;分组2&quot;&gt;</span><br><span class="line">        &lt;el-menu-item index&#x3D;&quot;1-4&quot;&gt;选项4&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">      &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">      &lt;el-submenu index&#x3D;&quot;1-4&quot;&gt;</span><br><span class="line">        &lt;span slot&#x3D;&quot;title&quot;&gt;选项5&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;el-menu-item index&#x3D;&quot;1-4-1&quot;&gt;选项1&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">      &lt;&#x2F;el-submenu&gt;</span><br><span class="line">    &lt;&#x2F;el-submenu&gt;</span><br><span class="line">    &lt;el-menu-item index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;el-icon-menu&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;title&quot;&gt;导航二&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">    &lt;el-menu-item index&#x3D;&quot;3&quot; disabled&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;el-icon-document&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;title&quot;&gt;导航三&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">    &lt;el-menu-item index&#x3D;&quot;4&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;el-icon-setting&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;title&quot;&gt;导航四&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">  &lt;&#x2F;el-menu&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--添加路由视图--&gt;</span><br><span class="line">  &lt;router-view align&#x3D;&quot;center&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &quot;Main&quot;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          isCollapse: true</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleOpen(key, keyPath) &#123;</span><br><span class="line">          console.log(key, keyPath);</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClose(key, keyPath) &#123;</span><br><span class="line">          console.log(key, keyPath);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .el-menu-vertical-demo:not(.el-menu--collapse) &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    min-height: 400px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果如图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/072.png" alt="image-20200904161758727"></p>
<hr>
<h2 id="6-传参以及重定向"><a href="#6-传参以及重定向" class="headerlink" title="6.传参以及重定向"></a>6.传参以及重定向</h2><h3 id="6-1-传参"><a href="#6-1-传参" class="headerlink" title="6.1 传参"></a>6.1 传参</h3><ul>
<li>先更改<code>Main.vue</code>文件中的路由器链接：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--name属性对应路由配置时的名称，params表示传参，且需要使用v-bind:双向绑定才能使此处的值能被路由接收--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;UserListOne&#x27;,params:&#123;id:1&#125;&#125;&quot;</span>&gt;</span>账号设置<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>再修改路由配置文件<code>index.js</code>：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /:id 表示参数id，用来接收params传参，props:true，表示开启props传参</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user/listone/:id&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;UserListOne&#x27;</span>,<span class="attr">component</span>:UserListOne,<span class="attr">props</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后修改<code>ListOne.vue</code>文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;账号设置&lt;&#x2F;h1&gt;</span><br><span class="line">    &#123;&#123;id&#125;&#125;&lt;!--便可以直接调用参数，且内容必须直接放在标签内不，或者报错--&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props:[&#39;id&#39;],&#x2F;&#x2F;将index.js中的id传到此处</span><br><span class="line">        name: &quot;UserListOne&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后显示：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/074.png" alt="image-20200904173718333"></p>
<h3 id="6-2-重定向"><a href="#6-2-重定向" class="headerlink" title="6.2 重定向"></a>6.2 重定向</h3><ul>
<li>只要在路由配置时添加一个新的路由配置重定向即可：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&#x27;/goHome&#x27;</span>,</span><br><span class="line">  redirect:<span class="string">&#x27;/main&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再在<code>Main.vue</code>中添加配置：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;1-3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/goHome&quot;</span>&gt;</span>回到首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>得到结果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/075.png" alt="image-20200904174020000"></p>
<h3 id="6-3-账号传参"><a href="#6-3-账号传参" class="headerlink" title="6.3 账号传参"></a>6.3 账号传参</h3><ul>
<li>先修改<code>Login.vue</code>文件，在跳转函数时添加代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&quot;/main/&quot;</span>+<span class="built_in">this</span>.ruleForm.name);</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>index.js</code>文件中修改代码接收参数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path:<span class="string">&#x27;/main/:name&#x27;</span>,</span><br><span class="line">component:Main,</span><br><span class="line">props:<span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Main.vue</code>文件中添加代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:[<span class="string">&#x27;name&#x27;</span>],</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/076.png" alt="image-20200904184745405"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/077.png" alt="image-20200904184818425"></p>
<h3 id="6-4-路由模式"><a href="#6-4-路由模式" class="headerlink" title="6.4 路由模式"></a>6.4 路由模式</h3><ul>
<li><p>mode属性：</p>
<ul>
<li>hash：路径带 # 符号；</li>
<li>history：路径不带 # 符号；</li>
</ul>
</li>
<li><p>修改为history模式：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mode:<span class="string">&#x27;history&#x27;</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>图显：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/078.png" alt="image-20200904185239423"></p>
<hr>
<h2 id="7-404及钩子"><a href="#7-404及钩子" class="headerlink" title="7. 404及钩子"></a>7. 404及钩子</h2><h3 id="7-1-404"><a href="#7-1-404" class="headerlink" title="7.1 404"></a>7.1 404</h3><ul>
<li>在view目录下新建<code>NotFound.vue</code>文件，添加文字即可；</li>
<li>在<code>index.js</code>文件中routes最后添加代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:<span class="string">&#x27;*&#x27;</span>,	<span class="comment">//表示除以上页面外链接都指向该页面</span></span><br><span class="line">component:NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/079.png" alt="image-20200904194401030"></p>
<h3 id="7-2-路由钩子与异步请求"><a href="#7-2-路由钩子与异步请求" class="headerlink" title="7.2 路由钩子与异步请求"></a>7.2 路由钩子与异步请求</h3><ul>
<li>两个路由钩子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//beforeRouteEnter(to,from,next):在进入路由前执行</span></span><br><span class="line"><span class="comment">//beforeRouteLeave(to,from,next):在离开路由前执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数说明：</p>
<ul>
<li>to：路由将要跳转的路径信息；</li>
<li>from：路由跳转前的路径信息；</li>
<li>next：路由的参数控制：<ul>
<li>next()：跳入下一个页面；</li>
<li>next(‘/path’)：改变路由的跳转方向，使其跳转到另一个路由；</li>
<li>next(false)：返回原来的页面；</li>
<li>next((vm)=&gt;{})，仅在<code>beforeRouteEnter</code>中可用，vm是组件实例；</li>
</ul>
</li>
</ul>
</li>
<li><p>在钩子函数中使用异步请求：</p>
<ul>
<li>安装Axios： <code>cnpm install axios -s</code> （反复尝试npm和cnpm，直到成功安装）；</li>
<li><code>main.js</code>引用Axios：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueAxios <span class="keyword">from</span> <span class="string">&#x27;vue-axios&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueAxios,axios);</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>static</code>（静态数据，可以从网上读取并下载）目录下创建新目录<code>mock</code>（静态数据测试规范目录），新目录下创建新文件<code>data.json</code>（从Vue基础入门那里拿来使用），重新部署服务器之后能够通过文件目录读取到该文件（该步骤同样可测试axios是否完整安装，否则重装）；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/080.png" alt="image-20200904205141348"></p>
<ul>
<li>在<code>ListOne.vue</code>文件中添加以下代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter:<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;<span class="comment">//=&gt;是function的简写模式，在钩子函数中使用</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;进入路由之前&quot;</span>);</span><br><span class="line">        next(<span class="function"><span class="params">vm</span>=&gt;</span>&#123;<span class="comment">//使用此方法可以直接调用vm实例</span></span><br><span class="line">          vm.getData();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeRouteLeave:<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;<span class="comment">//=&gt;是function的简写模式，在钩子函数中使用</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;离开路由之前&quot;</span>);</span><br><span class="line">        next();</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        getData:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.axios(&#123;</span><br><span class="line">            method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">            url:<span class="string">&#x27;http://localhost:8080/static/mock/data.json&#x27;</span> <span class="comment">//数据链接</span></span><br><span class="line">          &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(response);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击页面上“账号设置”之后则获取了该数据：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/081.png" alt="image-20200904210337482"></p>
<ul>
<li>并且正常输出了“进入路由之前”和“离开路由之前”提示；</li>
</ul>
</li>
<li><p>根据上述这段操作则可以实现从静态数据中获取数据，再结合前面几点内容融会贯通之后基本实现了前端的数据交互操作；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue（1.基础入门）</title>
    <url>/2020/09/06/vue/1.Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><h3 id="1-1-概念介绍"><a href="#1-1-概念介绍" class="headerlink" title="1.1 概念介绍"></a>1.1 概念介绍</h3><ul>
<li>Vue 是一款渐进式JavaScript框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular（模块化）和React(虚拟DOM）的优点，与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库(如: vue-router，vue-resource，vuex）或既有项目整合。</li>
</ul>
<a id="more"></a>

<h3 id="1-2-MVVM"><a href="#1-2-MVVM" class="headerlink" title="1.2 MVVM"></a>1.2 MVVM</h3><ul>
<li>Model:模型层，在这里表示JavaScript对象；</li>
<li>View:视图层，在这里表示DOM(HTML 操作的元素)；</li>
<li>ViewModel:连接视图和数据的中间件，Vue.js 就是MVVM中的ViewModel层的实现者</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/030.png" alt="image-20200830141507977"></p>
<ul>
<li>View层展现的不是Model层的数据，而是ViewModel的数据，由ViewNodel负责与 Model层交互，这就完全解耦了View层和Model层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</li>
</ul>
<h3 id="1-3-搭配环境"><a href="#1-3-搭配环境" class="headerlink" title="1.3 搭配环境"></a>1.3 搭配环境</h3><ul>
<li><p>下载vue.js文件：</p>
<ul>
<li><a href="https://vuejs.org/js/vue.js">https://vuejs.org/js/vue.js</a></li>
<li><a href="https://vuejs.org/js/vue.min.js">https://vuejs.org/js/vue.min.js</a></li>
<li>上面一个是全包，下面一个是简化包，代码中引用一个就OK</li>
</ul>
</li>
<li><p>如果不下载到本地，可以使用<code>cdn</code>外部引入：</p>
<ul>
<li><pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> 再在IDEA中 <span class="code">`settings-&gt;plugins`</span>中搜索安装vue.js：</span><br><span class="line">  ![<span class="string">image-20200830144613941</span>](<span class="link">https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/031.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 安装之后重启再设置下一步：</span><br><span class="line"></span><br><span class="line">![<span class="string">å¨è¿éæå¥å¾çæè¿°</span>](<span class="link">https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/032.png</span>)</span><br><span class="line"></span><br><span class="line">附模板：</span><br><span class="line"></span><br><span class="line"><span class="code">```vue</span></span><br><span class="line"><span class="code">&lt;template&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">&lt;/template&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">&lt;script&gt;</span></span><br><span class="line"><span class="code">    export default &#123;</span></span><br><span class="line"><span class="code">        name:&quot;$&#123;NAME&#125;&quot;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&lt;/script&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">&lt;style scoped&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：上图与模板代码取自博客：<a href="https://blog.csdn.net/jdq8576/article/details/104055707/">https://blog.csdn.net/jdq8576/article/details/104055707/</a></p>
</blockquote>
<ul>
<li>然后就可以在IDEA文件中new一个Vue Component文件啦！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/033.png" alt="image-20200830145017226"></p>
<hr>
<h2 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h2><h3 id="2-1-初步使用"><a href="#2-1-初步使用" class="headerlink" title="2.1 初步使用"></a>2.1 初步使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--展示格式--&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,		<span class="comment">//el属性用于绑定id号，且双向绑定，vm绑定id的同时，id也绑定了vm，使id视图层能随时取到vm的值</span></span></span><br><span class="line"><span class="javascript">        data: &#123;			<span class="comment">//data属性为数据存储区</span></span></span><br><span class="line"><span class="javascript">            message:<span class="string">&quot;hello,vue!&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//页面内容能够随message数值改变而随时改变，不需要刷新页面</span></span></span><br><span class="line"><span class="javascript">vm.message = <span class="string">&#x27;hello zhaoxiaoan&#x27;</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="string">&quot;hello zhaoxiaoan&quot;</span>  </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Vue常用的七个属性：<ul>
<li><code>el</code> ：占位符，用来绑定标签、id和class，指示编译器解析；</li>
<li><code>data</code> ：存放数据区域；</li>
<li><code>methods</code> ：存放方法逻辑区域；</li>
<li><code>render</code> ：创建Virtual Dom</li>
<li><code>computed</code> ：用于计算</li>
<li><code>watch</code> ：<ul>
<li>watch:function(new,old){}；</li>
<li>监听data中数据的变化；</li>
</ul>
</li>
<li><code>template</code> ：用来设置模板，替换页面元素，包括占位符；</li>
</ul>
</li>
</ul>
<h3 id="2-2-v-bind指令"><a href="#2-2-v-bind指令" class="headerlink" title="2.2 v-bind指令"></a>2.2 v-bind指令</h3><ul>
<li>该指令的含义是绑定信息，如 <code>v-bind:title=&quot;massage&quot;</code> 就是绑定了标题信息，将鼠标移动到<code>&lt;span&gt;</code>标签语句悬停可显示其绑定信息；</li>
<li><code>v-bind:</code>可以简写为 <code>:</code> ;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用v-bind指令可以自动引入v-bind使用链接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v- 都是vue指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;massage&quot;</span>&gt;</span></span><br><span class="line">        鼠标悬停几秒查看此处绑定的信息</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            massage:<span class="string">&quot;hello,vue&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-if判断语句"><a href="#2-3-if判断语句" class="headerlink" title="2.3 if判断语句"></a>2.3 if判断语句</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;type===&#x27;A&#x27;&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type===&#x27;B&#x27;&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>C<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            type:<span class="string">&quot;A&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-4-循环列表（重要）"><a href="#2-4-循环列表（重要）" class="headerlink" title="2. 4 循环列表（重要）"></a>2. 4 <code>循环列表（重要）</code></h3><ul>
<li>列表配合for循环就可以简单实现从数据库中导出数据并且循环输出成列表展示；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--v-for=&quot;(item,index) in items&quot; 格式类似于forEach,定义item取items数组中每个元素,index取索引下标，不用可不取--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--item.message用于展示--&gt;</span></span><br><span class="line">        &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//数组元素用来给列表li循环遍历</span></span></span><br><span class="line">            items: [</span><br><span class="line"><span class="javascript">                &#123;<span class="attr">message</span>:<span class="string">&quot;hello,vue&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="attr">message</span>:<span class="string">&quot;hello zhaoxiaoan&quot;</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/034.png" alt="image-20200830153345031"></p>
<h3 id="2-5-v-on-绑定事件"><a href="#2-5-v-on-绑定事件" class="headerlink" title="2.5 v-on 绑定事件"></a>2.5 v-on 绑定事件</h3><ul>
<li><code>v-on:</code> 用来绑定事件，如事件<code>click</code> ，其余事件可以查找jQuery事件文档（可以自己创建新事件）；</li>
<li><code>v-on:</code>可以简写为 <code>@</code> ；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-on</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span> = <span class="string">&quot;sayHi&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;hello,vue!&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">//方法只能存放在methods中</span></span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            sayHi:<span class="function"><span class="keyword">function</span> (<span class="params">envent</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="built_in">this</span>.message);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/035.png" alt="image-20200830155311872"></p>
<hr>
<h2 id="3-双向绑定（重点）"><a href="#3-双向绑定（重点）" class="headerlink" title="3.双向绑定（重点）"></a>3.<code>双向绑定（重点）</code></h2><ul>
<li>使用<code>v-model</code>指令；</li>
<li><code>v-model</code>指令会忽略所有表单元素的checked、selected等值，因此在下拉框中初始默认选择为空，必须设置一个disabled不可选中项并且设置其值为空来作为默认选择域；</li>
</ul>
<h3 id="3-1-文本"><a href="#3-1-文本" class="headerlink" title="3.1 文本"></a>3.1 文本</h3><ul>
<li>本质是<code>&#123;&#123;message&#125;&#125;</code>用来绑定<code>data&#123;message&#125;</code>显示内容，而<code>message</code>又通过<code>v-model=&quot;message&quot;</code>绑定了<code>&lt;input&gt;</code>文本域，所以当<code>&lt;input&gt;</code>输入框值域变化时修改了<code>data&#123;message&#125;</code>数据，接着<code>message</code>就跟着变化；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    输入的文本：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;hello,vue!&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/036.png" alt="image-20200830164055648"></p>
<h3 id="3-2-textarea文本域"><a href="#3-2-textarea文本域" class="headerlink" title="3.2 textarea文本域"></a>3.2 textarea文本域</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    输入的文本：</span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;hello,vue!&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/037.png" alt="image-20200830164801393"></p>
<h3 id="3-3-radio单选框"><a href="#3-3-radio单选框" class="headerlink" title="3.3 radio单选框"></a>3.3 radio单选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    性别：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/038.png" alt="image-20200830165053896"></p>
<h3 id="3-4-select下拉框"><a href="#3-4-select下拉框" class="headerlink" title="3.4 select下拉框"></a>3.4 select下拉框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    下拉框：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">disabled</span> &gt;</span>--请选择--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>选择了：&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/039.png" alt="image-20200830165542144"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/040.png" alt="image-20200830165627407"></p>
<hr>
<h2 id="4-组件"><a href="#4-组件" class="headerlink" title="4.组件"></a>4.组件</h2><ul>
<li>组件最大的作用就是其良好的复用性，但是复用性的本质只能复用框架外围，内在的本质数据必须从另一方获取，接下来讲述的就是获取数据的过程；</li>
</ul>
<h3 id="4-1-新建component组件"><a href="#4-1-新建component组件" class="headerlink" title="4.1 新建component组件"></a>4.1 新建component组件</h3><ul>
<li>给新组件命名为<code>zhaoxiaoan</code>；</li>
<li><code>template</code>为替换的模板内容；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;zhaoxiaoan&quot;</span>,&#123;</span><br><span class="line">    template: <span class="string">&#x27;&lt;li&gt;Hello&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//做好准备工作，绑定好id，存好数据</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        items: [<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Linux&quot;</span>,<span class="string">&quot;前端&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="4-2-使用新组件"><a href="#4-2-使用新组件" class="headerlink" title="4.2 使用新组件"></a>4.2 使用新组件</h3><ul>
<li>从绑好的Data中遍历取出数据；</li>
<li>并且使用<code>v-bind:itemX</code>绑定新变量<code>itemX</code>，并且将v-for遍历得到的数据赋值给新变量</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zhaoxiaoan</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:itemX</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">zhaoxiaoan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-3-将数据传入新组件"><a href="#4-3-将数据传入新组件" class="headerlink" title="4.3 将数据传入新组件"></a>4.3 将数据传入新组件</h3><ul>
<li>使用属性<code>props</code>接收新参数<code>itemX</code>此参数就是<code>v-bind</code>新定义并且绑定的那个变量，最终这个新变量传递给<code>template</code>模板中的<code>itemX</code>；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;zhaoxiaoan&quot;</span>,&#123;</span><br><span class="line">    props:[<span class="string">&#x27;itemX&#x27;</span>],</span><br><span class="line">    template: <span class="string">&#x27;&lt;li&gt;&#123;&#123;itemX&#125;&#125;&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>最终代码与运行结果如下：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zhaoxiaoan</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">zhaoxiaoan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue.js包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;zhaoxiaoan&quot;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props:[<span class="string">&#x27;item&#x27;</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">item</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            items: [<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Linux&quot;</span>,<span class="string">&quot;前端&quot;</span>]</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/041.png" alt="image-20200830171934341"></p>
<hr>
<h2 id="5-Axios异步网络通信（重点）"><a href="#5-Axios异步网络通信（重点）" class="headerlink" title="5.Axios异步网络通信（重点）"></a>5.<code>Axios异步网络通信（重点）</code></h2><h3 id="5-1-Axios简介"><a href="#5-1-Axios简介" class="headerlink" title="5.1 Axios简介"></a>5.1 Axios简介</h3><ul>
<li><p>Axios是一个开源的可以用在浏览器端和 Node3S 的异步通信框架，它的主要作用就是实现 AJAX异步通信，其功能特点如下:</p>
<ul>
<li>从浏览器中创建 <code>XMLHttpRequests</code></li>
<li>从 node.js 创建http请求</li>
<li>支持 Promise API [JS中链式编程]</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF（跨站请求伪造)</li>
</ul>
</li>
<li><p>由于Vue.js是一个视图层框架并且作者（尤雨溪）严格准守SoC(关注度分离原则），所以Vue.js并不包含AJAX的通信功能，为了解决通信问题，作者单独开发了一个名为vue-resource的插件，不过在进入2.0版本以后停止了对该插件的维护并推荐了Axios框架。少用jQuery，因为它操作Dom太频繁</p>
</li>
</ul>
<h3 id="5-2-Vue实例生命周期图示介绍"><a href="#5-2-Vue实例生命周期图示介绍" class="headerlink" title="5.2 Vue实例生命周期图示介绍"></a>5.2 Vue实例生命周期图示介绍</h3><ul>
<li>这是一个Vue实例生命周期，在生命周期过程中会执行相应的“钩子函数”，这些“钩子函数”是可以被外部调用进而影响到整个实例的；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/042_lifecycle.png" alt="lifecycle"></p>
<h3 id="5-3-引入Axios"><a href="#5-3-引入Axios" class="headerlink" title="5.3 引入Axios"></a>5.3 引入Axios</h3><ul>
<li>外部cdn引入：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>官方文档安装Axios：</li>
</ul>
<p><a href="http://www.axios-js.com/zh-cn/docs/vue-axios.html">http://www.axios-js.com/zh-cn/docs/vue-axios.html</a></p>
<h3 id="5-4-模拟网络通信"><a href="#5-4-模拟网络通信" class="headerlink" title="5.4 模拟网络通信"></a>5.4 模拟网络通信</h3><ul>
<li>开发的接口大部分使用JSON格式，先在项目里模拟一段<code>JSON</code>数据：<ul>
<li>创建一个新文件命名为<code>data.json</code> ，数据如下：</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;狂神说Java&quot;</span> ,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;https://blog.kuangstudy.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;isNonProfit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;street&quot;</span>:<span class="string">&quot;含光门&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span>:<span class="string">&quot;陕西西安&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;country&quot;</span> :<span class="string">&quot;中国&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">&quot;links&quot;</span> :[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;bilibili&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://space.bilibili.com/95256449&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;狂伸说java&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://blog.kuangstudy.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;百度&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://www.baidu.com/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>html文件代码如下：</p>
<ol>
<li><p>先写mounted()函数，在这个钩子函数中调用<code>axios.get()</code>获取json文件数据；</p>
</li>
<li><pre><code class="javascript">response=&gt;(this.info=response.data)
//这条语句是ES6新特性，=&gt;后面相当于函数内容，即请求响应后执行函数语句将请求响应的数据赋值给info
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3.</span> ```javascript</span><br><span class="line">   //<span class="class"><span class="keyword">data</span>()函数return是将其中定义的键值对属性值在mounted调用之后返回给<span class="keyword">data</span>，实现<span class="keyword">data</span>属性的动态传递</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>再通过双向绑定在html中引用data属性的数值；</p>
</li>
<li><p>对于链接标签中链接的动态生成，则使用<code>v-bind</code>指令将href属性的值绑定为info.url，不能直接将<code>info.url</code>传递给<code>href</code>，否则只能识别为一串字符串；</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;info.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;info.address.street&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;info.url&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#vue&quot;</span> ,</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">            info: &#123;		<span class="comment">//json文件中的属性只有在此处同名定义之后，接收数据后才能被调用</span></span></span><br><span class="line"><span class="javascript">                name: <span class="literal">null</span>,</span></span><br><span class="line">                address: &#123;</span><br><span class="line"><span class="javascript">                    street: <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">                    city: <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">                    country: <span class="literal">null</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                url:<span class="literal">null</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    mounted()&#123;        <span class="comment">//钩子函数，链式编程</span></span></span><br><span class="line"><span class="javascript">        axios.get(<span class="string">&quot;../data.json&quot;</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>(<span class="built_in">this</span>.info=response.data));</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/043.png" alt="image-20200902223854253"></p>
<ul>
<li>json文件在编码时没有使用UTF-8编译，所以上述请求执行后会得到乱码内容，解决方法是将json文件用notepad++打开之后在视窗栏 编码-&gt;使用UTF-8编码和转为UTF-8编码；</li>
</ul>
<hr>
<h2 id="6-计算属性"><a href="#6-计算属性" class="headerlink" title="6.计算属性"></a>6.计算属性</h2><ul>
<li><p>存在于computed属性中；</p>
</li>
<li><p>methods与computed属性中的函数名不能重名，否则优先调用methods中的函数而不会调用computed中的属性（定义为函数，调用为属性）；</p>
</li>
<li><p>调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销；</p>
</li>
<li><p>computed属性中的缓存只在数据发生增删改之后才会重新刷新变化，而methods内的函数随时变化；</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>currentTime1 &#123;&#123;currentTime1()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="comment">&lt;!--注意，调用methods内的函数使用函数调用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>currentTime2 &#123;&#123;currentTime2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="comment">&lt;!--注意，调用computed内的函数使用属性调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span> ,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;hello,world&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            currentTime1:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">Date</span>.now();<span class="comment">//返回一个时间戳</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed:&#123;</span><br><span class="line"><span class="javascript">            currentTime2:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.message;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">Date</span>.now();<span class="comment">//返回一个时间戳</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/044.png" alt="image-20200903102347608"></p>
<hr>
<h2 id="7-插槽slot"><a href="#7-插槽slot" class="headerlink" title="7.插槽slot"></a>7.插槽slot</h2><ul>
<li>插槽的本质就是嵌套组合复用；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--v-bind: 简略形式为 :        --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--v-on: 简略形式为 @        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-title</span> <span class="attr">slot</span>=<span class="string">&quot;todo-title&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-items</span> <span class="attr">slot</span>=<span class="string">&quot;todo-item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in todoItems&quot;</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;todo&quot;</span>,&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        /*template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#x27; +</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    &#x27;<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>&#x27; +</span></span></span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;&lt;ul&gt;&#x27;</span> +</span></span><br><span class="line"><span class="handlebars"><span class="xml">                        &#x27;<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>&#x27; +</span></span></span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;&lt;/ul&gt;&#x27;</span> +</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;&lt;/div&gt;&#x27;</span>*/</span></span><br><span class="line"><span class="javascript">        <span class="comment">//使用一个 \ 就可以直接换行</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo-title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//slot插槽通过name属性确定每一个slot插槽独一无二，在&lt;div&gt;中可通过此属性连接其它组件</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;todo-title&quot;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props:[<span class="string">&quot;title&quot;</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;todo-items&quot;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props:[<span class="string">&quot;item&quot;</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">item</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span> ,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&quot;学习篇&quot;</span>,</span></span><br><span class="line"><span class="javascript">            todoItems:[<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Linux&quot;</span>,<span class="string">&quot;前端&quot;</span>]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/045.png" alt="image-20200903110407351"></p>
<hr>
<h2 id="8-自定义事件分发"><a href="#8-自定义事件分发" class="headerlink" title="8.自定义事件分发"></a>8.自定义事件分发</h2><ul>
<li>实现在slot基础上的自定义删除事件；</li>
<li>具体问题及解决方式：<ul>
<li>component组件中定义事件函数，但是并不能直接修改vue实例内容<ul>
<li>间接，在vue实例中定义函数事件用于删除data数据内容；</li>
<li>将该事件<code>removeItem</code> 通过 <code>v-on</code> 绑定到自定义事件 <code>remove</code> 上；</li>
<li>再在component组件中通过<code>this.$emit(&#39;remove&#39;,index)</code>自定义事件分发传参并调用自定义事件<code>remove</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--v-bind: 简略形式为 :        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--v-on: 简略形式为 @        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-title</span> <span class="attr">slot</span>=<span class="string">&quot;todo-title&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-items</span> <span class="attr">slot</span>=<span class="string">&quot;todo-item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in todoItems&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:index</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">remove</span>=<span class="string">&quot;removeItem(index)&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">todo-items</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;todo&quot;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//使用一个 \ 就可以直接换行</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo-title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>\</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//slot插槽通过name属性确定每一个slot插槽独一无二，在&lt;div&gt;中可通过此属性连接其它组件</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;todo-title&quot;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props:[<span class="string">&quot;title&quot;</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;todo-items&quot;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props:[<span class="string">&quot;item&quot;</span>,<span class="string">&quot;index&quot;</span>],<span class="comment">//传入两个参数</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">li</span>&gt;</span>--</span><span class="template-variable">&#123;&#123;<span class="name">index</span>&#125;&#125;</span><span class="xml">--</span><span class="template-variable">&#123;&#123;<span class="name">item</span>&#125;&#125;</span><span class="xml"> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;remove(index)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;,</span></span></span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            remove: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;remove&#x27;</span>,index);<span class="comment">//自定义事件固定调用格式</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span> ,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            title: <span class="string">&quot;学习篇&quot;</span>,</span></span><br><span class="line"><span class="javascript">            todoItems:[<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Linux&quot;</span>,<span class="string">&quot;前端&quot;</span>]</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            removeItem:<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.todoItems.splice(index,<span class="number">1</span>);<span class="comment">//从index索引删除一个数组元素</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>点击删除按钮能够动态删除data数据并且刷新页面显示：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/046.png" alt="image-20200903121218463"></p>
<blockquote>
<p>关系示意图：最终都是通过前端的view视图来连接</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/047.png" alt="QQ图片20200903120909"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下方法学习笔记（一）因特网</title>
    <url>/2020/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%80%E7%AB%A0.%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<h2 id="1-什么是因特网"><a href="#1-什么是因特网" class="headerlink" title="1.什么是因特网"></a>1.什么是因特网</h2><blockquote>
<p>因特网是一种特定的计算机网络（只是其中一种类型）；</p>
</blockquote>
<h3 id="1-1-具体构成描述"><a href="#1-1-具体构成描述" class="headerlink" title="1.1 具体构成描述"></a>1.1 具体构成描述</h3><ul>
<li><p>主机（端系统）：</p>
<ul>
<li>接入到因特网的设备被称作主机；</li>
<li>由通信链路和分组交换机连接；</li>
<li>端系统通过ISP接入因特网；</li>
<li>因特网端系统包括：<ul>
<li>桌面计算机（桌面PC、Mac和Linux设备）；</li>
<li>服务器（Web和电子邮件服务器）；</li>
<li>移动计算机（智能手机和平板电脑）；</li>
</ul>
</li>
</ul>
</li>
<li><p>分组：</p>
<ul>
<li>由发送端系统将数据进行分段，并为每段加上首部字节组成的信息包；</li>
<li>一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(path/route)；</li>
</ul>
</li>
<li><p>通信链路：</p>
<ul>
<li>由不同类型的物理媒体组成，物理媒体包括同轴电缆、光纤等；</li>
<li>不同的链路以不同的速率传输数据；</li>
<li>传输速度以比特/秒（bit/s或bps）为单位；</li>
</ul>
</li>
<li><p>分组交换机：</p>
<ul>
<li><p>自身连接两段小型通信链路，用于连接外部真正的通信链路：</p>
<ul>
<li>入通信链路用来接收到达的分组；</li>
<li>出通信链路用来转发接收到的分组；</li>
<li>一般所说的路由器链路传输速率就是指出链路传输到通信链路的速率；</li>
</ul>
</li>
<li><p>两种类型：</p>
<ul>
<li>路由器(router)；</li>
<li>链路层交换机；</li>
</ul>
</li>
<li><p>作用是将特定的分组转发到特定的链路；</p>
</li>
<li><p>通过时延图观察其构成：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/001.png" alt="image-20200929232833820"></p>
</li>
<li><p>因特网服务提供商(ISP)：</p>
<ul>
<li>每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络；</li>
</ul>
</li>
<li><p>网络协议：</p>
<ul>
<li>用来控制因特网中信息的接收和发送的规则和标准；</li>
<li>因特网的主要协议统称为TCP/IP；</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h3 id="1-2-服务描述"><a href="#1-2-服务描述" class="headerlink" title="1.2 服务描述"></a>1.2 服务描述</h3><ul>
<li>因特网是一种为应用程序提供服务的基础设施；</li>
<li>因特网应用程序运行在端系统上，由于其涉及到多个交换数据的端系统，这些应用程序又被称为分布式应用程序；</li>
<li>套接字接口：<ul>
<li>是一套发送程序必须遵守的规则集合；</li>
<li>规定了运行在一个端系统上的程序请求因特网向运行在另一个端系统上的特定目的程序交付数据的方式；</li>
</ul>
</li>
</ul>
<h2 id="2-网络边缘"><a href="#2-网络边缘" class="headerlink" title="2.网络边缘"></a>2.网络边缘</h2><blockquote>
<p>即处于因特网边缘的端系统；</p>
</blockquote>
<h3 id="2-1-接入网"><a href="#2-1-接入网" class="headerlink" title="2.1 接入网"></a>2.1 接入网</h3><blockquote>
<p>将端系统物理连接到其边缘路由器的网络；</p>
</blockquote>
<ul>
<li>类型：<ul>
<li>家庭接入：<ul>
<li>数字用户线（DSL）；</li>
<li>电缆；</li>
<li>光纤到户（FTTH）；</li>
<li>拨号和卫星；</li>
</ul>
</li>
<li>企业接入：<ul>
<li>以太网；</li>
<li>WiFi；</li>
</ul>
</li>
<li>广域无线接入：<ul>
<li>3G；</li>
<li>长期演进（LTE）；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-物理媒体"><a href="#2-2-物理媒体" class="headerlink" title="2.2 物理媒体"></a>2.2 物理媒体</h3><blockquote>
<p>对于每个“发射器–接收器”对通过跨越一种物体媒体传播电磁波或光脉冲来发送该比特；</p>
</blockquote>
<ul>
<li>两种类型：<ul>
<li>导引性媒体：<ul>
<li>电波沿着固体媒体前行；</li>
<li>光缆；</li>
<li>双绞铜线；</li>
<li>同轴电缆；</li>
<li>安装实际成本低，但劳动力成本很高，常一次性直接安装多种媒体；</li>
</ul>
</li>
<li>非导引性媒体：<ul>
<li>电波在空气或外层空间中传播；</li>
<li>在无线局域网中传播；</li>
<li>在数字卫星频道中传播；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-网络核心"><a href="#3-网络核心" class="headerlink" title="3.网络核心"></a>3.网络核心</h2><blockquote>
<p>由互联因特网端系统的分组交换机和链路构成的网状结构；</p>
</blockquote>
<ul>
<li>通过网络链路和分组交换机传输数据有两种方式：分组交换和电路交换，前者正在慢慢取缔后者；</li>
</ul>
<h3 id="3-1-分组交换"><a href="#3-1-分组交换" class="headerlink" title="3.1 分组交换"></a>3.1 分组交换</h3><ul>
<li>分组：从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组；</li>
<li>分组交换：在源和目的端系统之间，每个分组都通过通信链路和分组交换机，由分组交换机实现分组交换功能，转发分组至指定的通信链路；</li>
<li>例：如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R比特/秒，则传输该分组的时间为L/R秒；</li>
</ul>
<h4 id="3-11-存储转发传输"><a href="#3-11-存储转发传输" class="headerlink" title="3.11 存储转发传输"></a>3.11 存储转发传输</h4><blockquote>
<p>存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组；</p>
</blockquote>
<ul>
<li>例：两个端系统经一条路由器构成的简单网络：<ul>
<li>源在时刻0开始传输，在时刻L/R秒，该路由器刚好接收到整个分组，并且朝着目的地向出链路开始传输分组（这里暂时先只考虑传输时延）；</li>
<li>在时刻2L/R，路由器已经传输了整个分组，并且整个分组已经被目的地接收；</li>
<li>考虑一种情形：如果一旦比特到达，交换机就转发比特，而不等到其全部到达再转发，那么传输时延将会是多少呢？<ul>
<li>虽然有两条通信链路，但由于此处我们只考虑传输时延而不考虑传播时延和处理时延，也就意味着这段时间和距离以及通信链路的段数没有关系，那么依然可以直接得到答案：L/R秒；</li>
</ul>
</li>
<li>考虑一般情形：通过由N条速率均为R的链路组成的路径，此时在源于目的地之间有N-1台路由器，此时从源发送一个分组，端到端的时延为：d=N*L/R;</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/002.png" alt="image-20200930000516666"></p>
<h4 id="3-12-排队时延和分组丢失"><a href="#3-12-排队时延和分组丢失" class="headerlink" title="3.12 排队时延和分组丢失"></a>3.12 排队时延和分组丢失</h4><ul>
<li><p>输出缓存（输出队列）：每台分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个输出缓存，用于存储路由器准备发往那条链路的分组；</p>
<ul>
<li><p>如果到达输出缓存的分组需要传输到某条链路，但却发现那条链路正忙于传输其它链路（传输容量已满），该到达分组必须在输出缓存中排队等待，这段等待时间被称为<strong>排队时延</strong>；</p>
</li>
<li><p>又由于输出缓存的大小也是有限的，当一个分组到达其输出缓存时，如果该输出缓存已经被其它需要传输的分组完全充满了，那么此时就会出现<strong>丢包</strong>现象，到达的分组或者排队的分组之一会被丢弃；</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-13-转发表和路由选择协议"><a href="#3-13-转发表和路由选择协议" class="headerlink" title="3.13 转发表和路由选择协议"></a>3.13 转发表和路由选择协议</h4><ul>
<li>IP地址：在因特网中，每台端系统具有一个IP地址，用于唯一标识自己的身份，目的IP地址存在于源发送的分组首部，且该地址具有等级结构，想象一下按照邮政地址发送的方式，二者极其相似；</li>
<li>转发表：每台路由器都拥有一个转发表，用于将目的地址（或其一部分）映射成为输出链路；</li>
<li>这样一来，整个过程就一目了然了，当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索器转发表，并且将其转发给适当的通信链路；</li>
<li>路由选择协议：因特网中用于自动设置这些转发表的协议标准；</li>
</ul>
<h3 id="3-2-电路交换"><a href="#3-2-电路交换" class="headerlink" title="3.2 电路交换"></a>3.2 电路交换</h3><blockquote>
<p>在电路交换网络中，在端系统通信期间，预留了端系统间沿路径通信所需要的资源（缓存或链路传输速率），而在分组交换网络中，传输速率是先来先使用的，如果已经被全部占用就只能排队。二者的区别类似于餐馆预定座位和直接去餐馆就餐。</p>
</blockquote>
<ul>
<li>例：传统的电话网络就是其中一种，当一个人通过电话网向另一个人发送信息时，在发送信息之前，必须先在二者之间建立一条电路连接，当网络创建出该电路连接时，它也在连接期间在该网络链路上预留了恒定的传输速率；</li>
<li>如图显示了一个四条链路互联四台电路交换机，且每条链路具有四条电路的电路交换网络：<ul>
<li>在这个网络中，每条链路都包括四条电路，这意味着每条链路最多可以同时并行四条连接；</li>
<li>例：如果邻近的两台分组交换机之间每条链路具有1Mbps的传输速率，那么其中每条电路都具有250kbps的传输速率，即每个端到端电路交换连接获得250kbps的专用传输速率；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/003.png" alt="image-20200930101439297"></p>
<h4 id="3-21-电路交换网络中的复用"><a href="#3-21-电路交换网络中的复用" class="headerlink" title="3.21 电路交换网络中的复用"></a>3.21 电路交换网络中的复用</h4><ul>
<li>频分复用（FDM）：对于FDM，链路的频谱由跨越链路创建的所有连接共享，在连接期间，为每条连接专用一个频段，该频段的宽度即称为<strong>带宽</strong>，在电话网络中，带宽通常为4kHz（即每秒4000周期）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/004.png" alt="image-20200930103014139"></p>
<ul>
<li>时分复用（TDM）：在TDM中，时间被划分为固定期间的帧，并且每个帧由被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙专门由该连接单独使用，该时隙用于传输该连接的数据；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/005.png" alt="image-20200930103113485"></p>
<h3 id="3-3-分组交换和电路交换的对比"><a href="#3-3-分组交换和电路交换的对比" class="headerlink" title="3.3 分组交换和电路交换的对比"></a>3.3 分组交换和电路交换的对比</h3><ul>
<li><p>对比：</p>
<ul>
<li>分组交换提供了比电路交换更好的带宽共享（即先来先使用原则更优于预留原则，预留原则存在巨大的占用期）；</li>
<li>分组交换比电路交换更简单更有效，实现成本更低；</li>
<li>由于排队时延，分组交换的端到端时延是可变的和不可预测的，不太适合实时服务（电话和视频会议等）；</li>
</ul>
</li>
<li><p>例1：假定多个用户共享一条1Mbps链路，每个用户活跃周期是变化的，且用户只有10%的时间以100kbps恒定速率产生数据，其余时间均静默：</p>
<ul>
<li>对于电路交换，在所有时间内必须为每个用户预留100kbps，该电路交换仅能支持10个并发用户。<ul>
<li>即在时分复用中将1s的帧划分为10个时隙，每个时隙100ms，则每帧将为每个用户分配一个时隙。</li>
</ul>
</li>
<li>对于分组交换，由于一个特定用户活跃的概率为0.1，如果有35个用户同时进行通信连接，有11个以上用户活跃的概率只有0.0004，当有10个以下并发用户时（概率为0.9996），到达的数据速率小于或等于该链路的输出速率1Mbps。因此，当同时活跃的用户小于或等于10个时，基本没有时延，等同于电路交换，而超过10个用户的概率只有0.0004，在用户过多的情形下，分组交换就会有排队时延。<ul>
<li>但是！注意分组交换可以同时支持3倍于电路交换支持的用户数量而保证性能基本相同！</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>横向占用，电路交换的并行通信数量是固定的，无法并行更多用户</p>
</blockquote>
<ul>
<li>例2：假定有10个用户，某个用户突然产生1000个1000比特的分组，而其它用户保持静默：<ul>
<li>在电路交换中，如每帧具有10个时隙并且每个时隙能包含1000比特，活跃用户仅能使用每帧中一个时隙来传输速率，而其余9个时隙保持空闲，该活跃用户传完所有10^6比特数据需要10s时间；</li>
<li>而在分组交换中，活跃用户能够持续以1Mbps的全部链路速率发送其分组，此时只需要1s就能发送完所有数据；</li>
</ul>
</li>
</ul>
<blockquote>
<p>纵向占用，电路交换分配的时隙连接也是固定的，无法更快传输数据</p>
</blockquote>
<h3 id="3-4-网络结构的发展过程"><a href="#3-4-网络结构的发展过程" class="headerlink" title="3.4 网络结构的发展过程"></a>3.4 网络结构的发展过程</h3><ul>
<li>接入ISP：端系统经过一个接入ISP与因特网相连，接入ISP不必是电信局或电缆公司，也能够是大学或公司这样的单位。端系统和内容提供商连接到接入ISP，接入ISP就是与端系统直接相连的第一个ISP。</li>
</ul>
<h4 id="3-41-网络结构1"><a href="#3-41-网络结构1" class="headerlink" title="3.41 网络结构1"></a>3.41 网络结构1</h4><ul>
<li>使用单一的全球传输ISP互联所有接入ISP；</li>
<li>且对于全球传输ISP而言，其建造将耗资巨大，因此向所有每个连接的接入ISP收费，故接入ISP被认为是<strong>客户</strong>，而全球传输ISP被认为是<strong>提供商</strong>；</li>
</ul>
<h4 id="3-42-网络结构2"><a href="#3-42-网络结构2" class="headerlink" title="3.42 网络结构2"></a>3.42 网络结构2</h4><ul>
<li>在网络结构1的基础上考虑竞争盈利的问题，于是导致多个全球传输ISP的产生；</li>
<li>由多个全球传输ISP和数十万个接入ISP组成，且这些全球传输ISP互联；</li>
</ul>
<h4 id="3-43-网络结构3"><a href="#3-43-网络结构3" class="headerlink" title="3.43 网络结构3"></a>3.43 网络结构3</h4><ul>
<li>多层等级结构，将全球传输ISP非正式命名为第一层ISP，建立区域ISP，且区域ISP之间又相互竞争，但最终都要连接到第一层ISP，且第一层ISP又互联；</li>
<li>例：中国每个城市都有接入ISP，这些接入ISP又与省级ISP相连，省级ISP又和国家ISP相连，最终国家ISP连入第一层ISP（或许可以将联通、移动、电信看成是相互竞争的各层次ISP）；</li>
</ul>
<h4 id="3-44-网络结构4"><a href="#3-44-网络结构4" class="headerlink" title="3.44 网络结构4"></a>3.44 网络结构4</h4><ul>
<li>在网络结构3的基础上增加存在点（PoP）、多宿、对等和因特网交换点；</li>
<li>PoP：<ul>
<li>存在于等级结构的所有层次，最底层接入ISP除外；</li>
<li>一个PoP提供商只是提供商网络中的一台或多台在相同位置的路由器群组；</li>
<li>对于与之相连的下一层客户ISP，它能从第三方提供商租用高速链路（注意，第三方提供商仅提供高速链路支持）快速互联其群组中任何两台路由器设备；</li>
<li>总结来说，就是一个提供商自身内部具有多个路由器，整个群组成为一个PoP，而下一层客户ISP只能接入其中一个路由器，但PoP概念能实现提供商内部路由器快速互联；</li>
</ul>
</li>
<li>多宿：任何ISP（第一层ISP除外）可以选择与两个或更多ISP提供商连接，这样当其中一个提供商出现故障时，客户ISP依然能够继续发送和接收分组数据；</li>
<li>对等：位于相同等级结构层次的邻近一对ISP直接将其网络连接到一起，使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输，这样一来可以节省与上层ISP之间的通信流量费用，其对等ISP之间无需提供费用；第一层ISP互相之间就是对等的关系，无需向对方结算费用</li>
<li>因特网交换点（IXP）：由第三方公司创建的汇合点，多个ISP能够在这里一起对等；</li>
</ul>
<h4 id="3-45-网络结构5——现在的网络结构"><a href="#3-45-网络结构5——现在的网络结构" class="headerlink" title="3.45 网络结构5——现在的网络结构"></a>3.45 网络结构5——现在的网络结构</h4><ul>
<li>在网络结构4的基础上增加内容提供商网络；</li>
<li>例：谷歌具有上百个数据中心，每个数据中心由无数服务器组成，其所有数据中心通过专用的TCP/IP网络互联，该网络跨越全球且独立于因特网，该谷歌专用网络仅承载出入谷歌浏览器的流量，由于有些接入ISP仅能通过第一层网络传输到达，所以谷歌也与第一层ISP相连，并就与这些ISP交换的流量向它们付费，这样一来可以减少大量流量传输费用开支，而且对其服务如何交付给端用户有了更多控制；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/006.png" alt="image-20200930124505953"></p>
<h2 id="4-分组交换网中的时延、丢包和吞吐量"><a href="#4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="4.分组交换网中的时延、丢包和吞吐量"></a>4.分组交换网中的时延、丢包和吞吐量</h2><h3 id="4-1-时延概述"><a href="#4-1-时延概述" class="headerlink" title="4.1 时延概述"></a>4.1 时延概述</h3><ul>
<li>分组从源主机出发，经过一系列路由器传输，最终到达目的地主机，该分组在沿途的每个节点经受了几种不同类型的时延；</li>
</ul>
<h4 id="4-11-时延类型"><a href="#4-11-时延类型" class="headerlink" title="4.11 时延类型"></a>4.11 时延类型</h4><ul>
<li>处理时延（d<sub>proc</sub>）：包括检查分组首部和决定将该分组导向何处所需要的时间、检查比特级别的差错所需要的时间等；</li>
<li>排队时延（d<sub>queue</sub>）：在输出缓存中时，当分组在等待传输时所花的时间；这个时间是不可预估而可变的，通常使用统计量来度量，而不使用具体的值；</li>
<li>传输时延（d<sub>trans</sub>）：是指当该分组前面的排队分组已经传输完毕之后，将该分组从路由器推上通信链路的时间，用比特L表示分组长度，R bps表示从路由器A到路由器B的链路传输速率，传输时延是L/R；</li>
<li>传播时延（d<sub>prop</sub>）：一旦一个比特被推上链路，该比特就需要向B路由器传播，从该链路的起点到路由器B传播所需要的时间是传播时延。传播时等于两台路由器之间的距离除以传播速率，传播速率取决于该链路的物理媒体。其大小为d/s；</li>
<li>节点总时延（d<sub>nodal</sub>）：d<sub>nodal</sub> = d<sub>proc</sub> + d<sub>queue</sub> + d<sub>trans</sub> + d<sub>prop</sub> </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/001.png" alt="image-20200929232833820"></p>
<h3 id="4-2-排队时延和丢包"><a href="#4-2-排队时延和丢包" class="headerlink" title="4.2 排队时延和丢包"></a>4.2 排队时延和丢包</h3><ul>
<li>节点时延中最为复杂和有趣的是排队时延；</li>
<li><strong>流量强度</strong>：<ul>
<li>假设输出队列的长度是无限的；</li>
<li>令 <code>a</code> 表示分组到达输出队列的平均速率，即 <code>a</code> 的单位为分组/秒；</li>
<li>分组长度为L；</li>
<li>则比特到达队列的平均速率为 <code>L*a</code>；</li>
<li>传输速率为R；</li>
<li>比率 <code>L*a/R</code> 被称作流量强度；</li>
<li>如果 <code>L*a/R&gt;1</code> 则比特到达队列的平均速率超过该队列传输出去的速率，排队速率将无限增加！所以设计系统时流量强度不能大于1；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/007.png" alt="image-20200930145540463"></p>
<ul>
<li>丢包：由于现实中输出队列容量有限，随着流量强度接近1，排队时延并不可能趋向无穷大（排队时延理论上有最大值，因为输出队列有容量上限），当到达的分组发现队列已满，此时就会发生丢包现象；<ul>
<li>分组丢失的比例随着流量强度的增强而增加；</li>
<li>一个节点的性能不仅根据时延来度量，而且根据丢包率来度量；</li>
<li>丢失的分组可能基于端到端的原则重传；</li>
</ul>
</li>
</ul>
<h3 id="4-3-端到端时延"><a href="#4-3-端到端时延" class="headerlink" title="4.3 端到端时延"></a>4.3 端到端时延</h3><blockquote>
<p>即从源到目的地的总时延；</p>
</blockquote>
<ul>
<li><p>假定在源于目的地端系统之间有N-1太路由器，网络无拥塞，且每台路由器的时延相同：</p>
<ul>
<li>d<sub>end-end</sub> = N*(d<sub>proc</sub> + d<sub>trans</sub> + d<sub>prop</sub>)</li>
</ul>
</li>
<li><p>在windows cmd中使用<code>tracert</code>指令能够进行跃点跟踪：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/008.png" alt="image-20200930151355107"></p>
<h3 id="4-4-吞吐量"><a href="#4-4-吞吐量" class="headerlink" title="4.4 吞吐量"></a>4.4 吞吐量</h3><ul>
<li><p>端到端吞吐量也是检测计算机网络性能的重要度量之一；</p>
</li>
<li><p>考虑从主机A到主机B跨越计算机网络传送一个大文件：</p>
<ul>
<li>瞬时吞吐量：主机B接收到该文件的速率（bps单位）；</li>
<li>平均吞吐量：如果该文件由F比特组成，主机B接收到所有F比特费时T，则文件传送的平均吞吐量为F/T bps；</li>
<li>在不考虑其它时延的情形下，吞吐量的大小就是所有通信链路中最小的传输速率；</li>
</ul>
</li>
</ul>
<h2 id="5-协议层次及其服务模型"><a href="#5-协议层次及其服务模型" class="headerlink" title="5.协议层次及其服务模型"></a>5.协议层次及其服务模型</h2><h3 id="5-1-协议分层"><a href="#5-1-协议分层" class="headerlink" title="5.1 协议分层"></a>5.1 协议分层</h3><blockquote>
<p>网络设计者以<strong>分层</strong>的方式组织协议以及实现这些协议的网络硬件和软件，每层通过在该层中执行某些动作或使用直接下层的服务来提供服务，各层的所有协议统称为协议栈</p>
</blockquote>
<ul>
<li>服务模型：某层向它的上一层提供的服务即称为该层的服务模型；</li>
</ul>
<h4 id="5-11-因特网协议栈组成层次（整本书后续重点都在于此）"><a href="#5-11-因特网协议栈组成层次（整本书后续重点都在于此）" class="headerlink" title="5.11 因特网协议栈组成层次（整本书后续重点都在于此）"></a>5.11 因特网协议栈组成层次（整本书后续重点都在于此）</h4><blockquote>
<p>协议组成层次相当于确定每两层之间交接时的标准和规则</p>
</blockquote>
<ul>
<li>应用层：<ul>
<li>应用层包含网络应用程序和应用层协议；</li>
<li>应用层协议：<ul>
<li>HTTP协议：提供Web文档的请求和传送服务；</li>
<li>SMTP协议：提供电子邮件报文的传输服务；</li>
<li>FTP协议：提供两个端系统之间的传送服务；</li>
<li>DNS协议：提供域名地址转换服务；</li>
</ul>
</li>
<li>报文：<ul>
<li>应用层协议分布在多个端系统上，一个端系统上的应用程序使用协议与另一个端系统中的应用程序交换信息分组；</li>
<li>应用层分组被称作<strong>报文</strong>；</li>
</ul>
</li>
</ul>
</li>
<li>运输层：<ul>
<li>在应用程序端点之间传送应用层报文；</li>
<li>运输层协议：<ul>
<li>TCP协议：<ul>
<li>向应用程序提供面向连接的服务；</li>
<li>包括应用层报文向目的地的确保传递和流量控制；</li>
<li>将长报文划分为短报文，并提供拥塞控制机制，当网络拥塞时，源抑制其传输速率；</li>
</ul>
</li>
<li>UDP协议：向应用程序提供无连接服务；</li>
</ul>
</li>
<li>报文段：运输层分组被称为<strong>报文段</strong>；</li>
</ul>
</li>
<li>网络层：<ul>
<li>数据报：网络层分组被称为<strong>数据报</strong>；</li>
<li>负责将数据报从一台主机移动到另一台主机；</li>
<li>网络层协议：<ul>
<li>IP协议：<ul>
<li>定义了数据报中各个字段以及端系统和路由器如何使用这些字段；</li>
<li>IP只有一个，所有具有网络层的因特网组件必须运行IP；</li>
</ul>
</li>
<li>路由选择协议：根据每个路由将数据报从源传输到目的地；</li>
</ul>
</li>
</ul>
</li>
<li>链路层：<ul>
<li>在每个节点（主机或路由器），网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点中，链路层再将数据报上传给网络层；</li>
<li>帧：链路层分组被称为<strong>帧</strong>；</li>
<li>链路层的任务是将整个帧从一个网络元素移动到相邻的网络元素；</li>
</ul>
</li>
<li>物理层：<ul>
<li>物理层的任务是将整个帧中的所有比特从一个节点移动到下一个节点；</li>
</ul>
</li>
</ul>
<h4 id="5-12-OSI模型"><a href="#5-12-OSI模型" class="headerlink" title="5.12 OSI模型"></a>5.12 OSI模型</h4><ul>
<li>国际化标准组织（ISO）提出计算机网络围绕七层来组织，成为开放系统互联模型（OSI），是一种不同于因特网协议栈的另一种协议栈；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/009.png" alt="image-20200930201300290"></p>
<h3 id="5-2-封装"><a href="#5-2-封装" class="headerlink" title="5.2 封装"></a>5.2 封装</h3><ul>
<li>每次向下即在分组端头部添加该层独有首部信息，即进行封装，向上时解封；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/010.png" alt="image-20200930201809900"></p>
<blockquote>
<p>附本书题目答案链接：<a href="https://feater.top/ebooks/11/">计算机网络：自顶向下方法（原书第7版）课后习题参考答案中文版</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下方法</tag>
        <tag>理论学习</tag>
        <tag>教材</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下方法学习笔记（四）网络层：数据平面</title>
    <url>/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0.%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="1-网络层概述"><a href="#1-网络层概述" class="headerlink" title="1.网络层概述"></a>1.网络层概述</h2><blockquote>
<p>网络层存在于网络中所有主机和路由器中（路由器具有截断的协议栈，没有网络层以上的部分），由<strong>数据平面</strong>和<strong>控制平面</strong>两部分组成。</p>
</blockquote>
<p><strong>数据平面</strong>：是网络层中属于每台路由器自身的功能，决定到达路由器输入链路的数据报（网络层分组）如何转发到该路由器某一个具体的输出链路。</p>
<p><strong>控制平面</strong>：是网络范围内的逻辑，控制数据报沿着从源主机到目的主机的端到端路径中路由器的路由方式。</p>
<p>如图所示：</p>
<ul>
<li>过程实例：<ul>
<li>H1中的网络层取得来自于H1运输层的报文段，并将其封装成数据报，向相邻路由器发送该数据报；</li>
<li>在接收方路由器H2，网络层接收来自相邻路由器R2的数据报，提取出相应报文段并上传给H2运输层；</li>
</ul>
</li>
<li>每台路由器数据平面作用是从其输入链路向其输出链路转发数据报，控制平面作用是协调本地的每台路由器转发动作，使数据报沿着源到目的主机之间的路由器路径进行端到端传输；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/079.png" alt="image-20201110165452010"></p>
<a id="more"></a>

<h3 id="1-1-转发和路由选择：数据平面和控制平面"><a href="#1-1-转发和路由选择：数据平面和控制平面" class="headerlink" title="1.1 转发和路由选择：数据平面和控制平面"></a>1.1 转发和路由选择：数据平面和控制平面</h3><p><strong>转发</strong>：当一个分组到达路由器的一条输入链路时，该路由器必须将该分组移动到合适的输出链路，这是一个路由器本地动作，发生时间很短，通常用硬件实现。转发是数据平面实现的唯一功能。分组有可能被现有的路由器阻拦（例如该分组来源于一个已知的恶意主机或者该分组发向一个被禁止的目的主机），或者可能是冗余的并经过多条出链路发送出去。</p>
<p><strong>路由选择</strong>：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径，计算这些路径的算法被称作<strong>路由选择算法</strong>，这是一个端到端路径的网络范围处理过程，但路由选择发生时间相对很长，通常用软件实现。</p>
<p>每台网络路由器本地存有有一个关键元素<strong>转发表</strong>，路由器检查到达的分组首部中一个或多个字段，进而使用这些首部值在其转发表中索引，转发分组至相应的输出链路。转发表配置方式有两种：</p>
<ul>
<li>传统方式：在一台路由器中的路由选择算法与在其它路由器中的路由选择算法通信，以计算它的转发表的值；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/080.png" alt="image-20201110170746223" style="zoom:80%;">

<ul>
<li>SDN方式：远程控制器计算和分发转发表供每台路由器使用，其中控制平面路由选择功能与物理路由器相分离，路由选择仅执行转发，远程控制器结算并分发转发表。路由器和远程控制器通过交换包含转发表和其它路由选择信息的报文而通信；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/081.png" alt="image-20201110171252006" style="zoom:80%;">



<h3 id="1-2-网络服务模型"><a href="#1-2-网络服务模型" class="headerlink" title="1.2 网络服务模型"></a>1.2 网络服务模型</h3><ul>
<li>确保交付；</li>
<li>具有时延上界的确保交付；</li>
<li>有序分组交付；</li>
<li>确保最小带宽；</li>
<li>安全性；</li>
<li>……</li>
</ul>
<p>但因特网的网络层只提供了<strong>尽力而为服务</strong>，即不保证任何服务，ATM网络体系结构提供了确保按序时延、有界时延和确保最小带宽。</p>
<p>分组交换机：指一台通用分组交换设备，根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组</p>
<ul>
<li>链路层交换机：基于链路层帧中的字段值做出转发决定，也被称为链路层设备；</li>
<li>路由器（router）：基于网络层数据报中的首部字段值做出转发决定，是网络层设备；</li>
</ul>
<h2 id="2-路由器工作原理"><a href="#2-路由器工作原理" class="headerlink" title="2.路由器工作原理"></a>2.路由器工作原理</h2><p>路由器体系结构：</p>
<ul>
<li>输入端口：<ul>
<li>输入端口最左侧方框（及输出最右侧），执行终结入物理链路的物理层功能；</li>
<li>输入端口中间方框（及输出中间框），与位于入链路远端的数据链路层交互来执行数据链路层功能；</li>
<li>输入端口最右侧，执行查找功能，通过查询转发表决定路由器的输出端口，到达的分组通过路由器的交换结构转发到输出端口；</li>
</ul>
</li>
<li>交换结构：将路由器的输入端口连接到输出端口；</li>
<li>输出端口：存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。当一条链路是双向时，输出端口通常与该链路的输入端口成对出现在同一条线路卡上；</li>
<li>路由选择处理器：执行控制平面功能<ul>
<li>在传统路由器中，执行路由选择协议，维护路由选择表与关联链路状态信息，并计算转发表；</li>
<li>在SDN路由器中，负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项；</li>
<li>还执行网络管理功能；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/082.png" alt="image-20201111122551951" style="zoom:80%;">

<p>路由器的输入端口、输出端口、交换结构几乎总使用硬件实现。</p>
<p>两种转发：</p>
<ul>
<li>基于目的地转发；</li>
<li>通用转发；</li>
</ul>
<h3 id="2-1-输入端口处理和基于目的地转发"><a href="#2-1-输入端口处理和基于目的地转发" class="headerlink" title="2.1 输入端口处理和基于目的地转发"></a>2.1 输入端口处理和基于目的地转发</h3><p>详细输入处理视图：</p>
<ul>
<li>转发表从路由选择处理器经过独立总线复制到线路卡，总线在图4-4中以虚线表示，因而转发决策能够在每个输入端口本地做出，无需基于每个分组调用集中式路由选择处理器，避免了集中式处理的瓶颈；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/083.png" alt="image-20201111134112128" style="zoom:80%;">

<p>假设一个入分组基于目的地址交换到输出端口，又假设路由器具有四条链路0-3如图：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/084.png" alt="image-20201111134527504" style="zoom:80%;">

<p>对于该链路，转发表如图：</p>
<ul>
<li>路由器使用分组目的地址的<strong>前缀</strong>与该表中表项进行匹配；</li>
<li>当有多个匹配时，该路由器使用<strong>最长前缀匹配规则</strong>；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/085.png" alt="image-20201111134611536" style="zoom:80%;">



<p>查找方法：</p>
<ul>
<li>快速查找算法；</li>
<li>三态内容可寻址存储器（TCAM）；</li>
</ul>
<p>通过查找确定某分组的输出端口后，该分组就进入交换结构，如果来自其它输入端口的分组当前正在使用该交换结构，则该分组可能会在输入端口处阻塞排队，并等待稍后被及时调度以通过交换结构。</p>
<p>输入端口除执行查找动作外，还必须执行以下三项动作：</p>
<ul>
<li>必须出现物理层和链路层处理；</li>
<li>必须检查分组的版本号、检验和以及寿命字段，并重写后两个字段；</li>
<li>必须更新用于网络管理的计数器；</li>
</ul>
<h3 id="2-2-交换"><a href="#2-2-交换" class="headerlink" title="2.2 交换"></a>2.2 交换</h3><p>交换结构位于一台路由器的核心位置，常用三种方式如图：</p>
<ul>
<li>经内存交换：一个分组到达一个输入端口时，该端口会通过中断方式向路由器处理器发出信号。该分组从输入端口处被复制到处理器内存中，处理器转发操作也是将该分组复制到输出端口的缓存中。而且每次只能转发一个分组；</li>
<li>经总线交换：直接通过一根共享主线将分组从输入端口传输到输出端口，不经过处理器的干预；</li>
<li>经互联网络交换：又称纵横式交换，由2N条总线组成，连接N个输入端口和N个输出端口。纵横式交换机是非阻塞的，只要没有其它分组被转发到该输出端口，转发到该输出端口的分组就不会阻塞。但相对应的，如果同时有来自两个不同输入端口的两个分组目的地相同，则有一个分组会在输入端排队等待；</li>
<li>除此之外，更复杂的互联网络使用多级交换元素，使得来自不同输入端口的分组通过交换结构同时朝着相同的输出端口前行如三级非阻塞交换策略：<ul>
<li>输入端口和输出端口被连接到并行的N个交换结构；</li>
<li>一个输入端口将一个分组分成K个较小的块，并通过N个交换结构中的K个发送这些块到所选择的输出端口；</li>
<li>输出端口再将K个块装配还原成初始的分组；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/086.png" alt="image-20201111135534529" style="zoom:80%;">



<h3 id="2-3-输出端口处理"><a href="#2-3-输出端口处理" class="headerlink" title="2.3 输出端口处理"></a>2.3 输出端口处理</h3><p>输出端口处理取出已存放在输出端口内存中的分组并将其发送到输出链路上：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/087.png" alt="image-20201111140111303" style="zoom:80%;">



<h3 id="2-4-何处出现排队"><a href="#2-4-何处出现排队" class="headerlink" title="2.4 何处出现排队"></a>2.4 何处出现排队</h3><p>假定输入线路速度和输出线路速度（传输速率）是相同的，均为<strong>R<sub>line</sub>**每秒分组数，并且有N个输入端口和N个输出端口。还假设所有分组具有相同的固定长度，分组以同步的方式到达输入端口。定义交换结构传输速率</strong>R<sub>switch</sub>**为从输入端口移动到输出端口移动分组的速率。</p>
<p>如果**R<sub>switch</sub>=N×R<sub>line</sub>**，这时输入端口的排队时延微不足道。</p>
<h4 id="2-41-输入排队"><a href="#2-41-输入排队" class="headerlink" title="2.41 输入排队"></a>2.41 输入排队</h4><p>考虑纵横式交换结构：</p>
<ul>
<li><p>假定①所有链路速率相同；②<strong>R<sub>switch</sub>=R<sub>line</sub>**；③ 分组以</strong>FCFS**先到先服务的方式从输入队列移动到输出队列；</p>
</li>
<li><p><strong>线路前部阻塞（HOL）</strong>：如果一个输入队列中前一个分组被阻塞，则后面的分组要去往的输出端口即使空闲也会被阻塞。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/088.png" alt="image-20201115110812624" style="zoom:80%;">



<h4 id="2-42-输出排队"><a href="#2-42-输出排队" class="headerlink" title="2.42 输出排队"></a>2.42 输出排队</h4><p>依然考虑纵横式结构，且**R<sub>switch</sub>=N×R<sub>line</sub>**，到达N个输入端口的每个分组的目的地是相同的输出端口，但由于输出端口每次只能传输一个分组，所以这N个分组必须排队等待，而每次传输一个分组的时间中每个输入队列又会新增一个分组到达，这时排队的数量足够大，就会耗尽输入队列的可用内存。</p>
<p>当没有足够的内存来存储一个分组时（有时候在缓存填满之前就会丢弃一个分组或者在其首部加上标记，这会向发送方提供拥塞信号），有两种方式解决：</p>
<ul>
<li>弃尾：丢弃到达的分组；</li>
<li>删除一个或多个正在排队的分组；</li>
</ul>
<p>所有处理分组丢弃和标记的策略被称作<strong>主动队列管理（AQM）算法</strong>，其中<strong>随机早期检测（RED）算法</strong>是最广泛研究和实现的AQM算法之一。</p>
<p>对于整个路由器而言，用来缓存所有的排队分组的大小该是多少呢？</p>
<ul>
<li>相对少量的TCP流经过链路排队，缓存数量（B）应当等于平均往返时延（RTT）乘以链路的容量（C）；</li>
<li>当有大量的TCP流（N条）流过一条链路时，缓存所需要的数量B=RTT×C/$\sqrt{N}$；</li>
</ul>
<h3 id="2-5-分组调度"><a href="#2-5-分组调度" class="headerlink" title="2.5 分组调度"></a>2.5 分组调度</h3><blockquote>
<p>仅考虑分组到达输出链路的排队问题，不考虑分组丢弃问题。</p>
</blockquote>
<h4 id="2-51-先进先出（FIFO、FCFS）"><a href="#2-51-先进先出（FIFO、FCFS）" class="headerlink" title="2.51 先进先出（FIFO、FCFS）"></a>2.51 先进先出（FIFO、FCFS）</h4><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/090.png" alt="image-20201116165410909" style="zoom:80%;">



<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/089.png" alt="image-20201116165223119" style="zoom:80%;">



<h4 id="2-52-优先权排队"><a href="#2-52-优先权排队" class="headerlink" title="2.52 优先权排队"></a>2.52 优先权排队</h4><p>在<strong>非抢占式优先权排队</strong>规则下进行，一旦分组进行传输，不能被打断。</p>
<p>每个优先权类通常拥有自己的队列，当选择一个分组传输时，优先权排队规则将从队列非空的最高优先权类中按照FIFO规则传输分组。实践中，携带网络管理信息的分组能获得超过用户流量的优先权，基于IP的实时语音分组也可能获得超过非实时流量的优先权。</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/091.png" alt="image-20201116165759364" style="zoom:80%;">



<p>例如，分组1,3,4属于高优先权类，2,5属于低优先权类：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/092.png" alt="image-20201116170223606" style="zoom:80%;">



<h4 id="2-53-循环和加权公平排队"><a href="#2-53-循环和加权公平排队" class="headerlink" title="2.53 循环和加权公平排队"></a>2.53 循环和加权公平排队</h4><p>在<strong>循环排队规则</strong>下，分组像使用优先权排队那样被分类，但是类与类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。一个<strong>保持工作排队</strong>规则不允许链路保持空闲。</p>
<p>例如，分组1,2,4属于第一类，3,5属于第二类：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/093.png" alt="image-20201116170529171" style="zoom:80%;">



<p><strong>加权公平排队规则（WFQ）</strong>：</p>
<ul>
<li>到达的分组被加权分类在每个类的等待区域排队，WFQ会循环调度每一个类，而不必等待高优先权类为空再去调度下一级优先权类；</li>
<li>对于每个类<code>i</code>被分配权 $w_i$ ，在类<code>i</code>有分组要发送的任何时间间隔内，第 i 类将确保接收到的服务部分等于 $w_i/(\sum w_j)$ ，其中分母中的和是计算所有有分组排队等待传输的类别得到的；</li>
<li>在最坏的情况下，即使所有的类都有分组排队，第 i 类仍然保证分配到带宽的 $w_i/(\sum w_j)$ 部分；</li>
<li>对于一条传输速率为<code>R</code>的链路，第 i 类总能获得至少为  $R*w_i/(\sum w_j)$ 的吞吐量；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/094.png" alt="image-20201116170459971" style="zoom:80%;">



<h2 id="3-IPV4、寻址、IPV6及其它"><a href="#3-IPV4、寻址、IPV6及其它" class="headerlink" title="3.IPV4、寻址、IPV6及其它"></a>3.IPV4、寻址、IPV6及其它</h2><h3 id="3-1-IPV4数据报格式"><a href="#3-1-IPV4数据报格式" class="headerlink" title="3.1 IPV4数据报格式"></a>3.1 IPV4数据报格式</h3><p>关键字段：</p>
<ul>
<li>版本：4比特，说明IPV4/IPV6版本；</li>
<li>首部长度：4比特，选项字段为0时首部长度为20字节；</li>
<li>服务类型（TOS）：区分不同类型的数据报，如将实时流量数据报和非实时流量数据报区分；</li>
<li>数据报长度：16比特，所以IP数据报的理论最大长度为65535字节，一般以太网帧载荷字段为1500字节；</li>
<li>标识、标志、片偏移：与IP分片相关；</li>
<li>寿命（TTL）：每一台路由器处理数据报时，该字段值减1，若TTL值为0，则该数据报被丢弃；</li>
<li>协议：仅当IP数据报到达目的地时使用，指示IP数据报的数据部分交付给哪个特定的运输层协议，值为6交给TCP，值为17交给UDP；</li>
<li>首部检验和：将首部中每2个字节当做一个数，用反码算术求和；</li>
<li>源和目的IP地址；</li>
<li>选项：可扩展项，很少使用；</li>
<li>数据（有效载荷）；</li>
</ul>
<p>一个IP数据报首部总长为20字节（无选项时），如果承载一个TCP报文段，则每个数据报总共承载40字节首部以及应用层报文；</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/095.png" alt="image-20201117165648343" style="zoom:80%;">



<h3 id="3-2-IPV4数据报分片"><a href="#3-2-IPV4数据报分片" class="headerlink" title="3.2 IPV4数据报分片"></a>3.2 IPV4数据报分片</h3><blockquote>
<p>不是所有链路层协议都能承载相同长度的网络层分组，因此有时需要对数据报进行分片处理</p>
</blockquote>
<p><strong>最大传送单元（MTU）</strong>：一个链路层帧能承载的最大数据量。</p>
<p>当某条链路接收到一个IP数据报，通过检查转发表确定出链路，并且该出链路的MTU比该IP数据报的长度要小，这时如何将这个过大的IP数据报挤进链路层帧的有效载荷字段呢？</p>
<p>解决方法是将IP数据报中的数据分片成两个或更多个较小的IP数据报，再通过出链路发送这些数据报，每个这种较小的数据报都被称作<strong>片（fragment）</strong>。片在其到达目的地运输层以前需要进行重组。</p>
<p>分片格式：</p>
<ul>
<li>每个片都具有其源数据报的源地址、目的地址与标识号；</li>
<li>最后一个片的标志比特被设置为0，其余片标志设置为1；</li>
<li>偏移字段指定该片应放在初始IP数据报的哪个位置，注意，由于分片，多个数据报会多出多个首部20字节，且偏移量只计算数据内容，一般使用数据长度（字节）/8表示；</li>
</ul>
<h3 id="3-3-IPV4编址"><a href="#3-3-IPV4编址" class="headerlink" title="3.3 IPV4编址"></a>3.3 IPV4编址</h3><blockquote>
<p>主机和路由器通过链路连接到网络中，而这个主机与物理链路之间的边界又叫做<strong>接口</strong>，一台主机通常只有一个接口，但是一台路由器往往有多个接口。从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器关联！</p>
</blockquote>
<p>IPV4中每个IP地址长度为32字节，采用<strong>点分十进制记法</strong>每8个比特的十进制等价数使用句点<code>.</code>符号分割，如<code>193.32.216.9</code>的二进制记法就是<code>11000001 00100000 11011000 00001001</code>。</p>
<p><strong>子网</strong>：如图所示一台路由器具有三个接口，互联七台主机</p>
<ul>
<li><strong>子网掩码</strong>：以该中心路由器为核心的三条链路接口共同组成一个大<strong>子网</strong>网络（包含三个小<strong>子网</strong>网络），对于最左侧链路IP地址<code>223.1.1.0/24</code>而言，其中的<code>/24</code>记法就被称作子网掩码，指示了比特中最左侧24定义了子网地址；对于路由器而言，它只需要匹配IP地址前24位即可分发分组至相应链路，而后<code>32-24</code>位地址则由链路分发给它所连接的其它主机；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/097.png" alt="image-20201118135734964" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/096.png" alt="image-20201118135551134" style="zoom:80%;">



<p>除此之外，再来看一个路由器互联的案例：</p>
<ul>
<li>该图中就包含六个子网；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/098.png" alt="image-20201118140308954" style="zoom:80%;">



<p><strong>无类别域间路由选择（CIDR）</strong>：32比特的IP地址按照<code>a.b.c.d/x</code>格式被划分成两部分，其中x位最高比特构成了IP地址的网络部分，该部分又被称为<strong>（网络）前缀（prefix）</strong>，当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组织的内部时，仅需要考虑该地址前x位比特，这能够大大减少这些路由器中转发表的长度。</p>
<p>对于使用CIDR协议的ISP组织而言，外界的其它部分不需要关注该ISP内部是否再次进行划分地址或者划分了多少主机，这种使用单个网络前缀通告多个网络的能力又被称为<strong>地址聚合</strong>、<strong>路由聚合</strong>或<strong>路由摘要</strong>。</p>
<h4 id="3-31-获取一块地址"><a href="#3-31-获取一块地址" class="headerlink" title="3.31 获取一块地址"></a>3.31 获取一块地址</h4><p><strong>因特网名字和编号分配机构（ICANN）</strong>：非盈利，功能主要包括：</p>
<ul>
<li>分配IP地址；</li>
<li>管理DNS根服务器；</li>
<li>分配域名；</li>
<li>解决域名纷争；</li>
<li>……</li>
</ul>
<p>ISP通过与ICANN联系并获得一块IP地址（通过x确定），ISP再将自己的大块地址分配给向它发起请求的组织，如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/099.png" alt="image-20201118141630351" style="zoom:80%;">



<h4 id="3-32-获取主机地址：动态主机配置协议"><a href="#3-32-获取主机地址：动态主机配置协议" class="headerlink" title="3.32 获取主机地址：动态主机配置协议"></a>3.32 获取主机地址：动态主机配置协议</h4><blockquote>
<p>当某组织获得一块地址之后，它如何为本组织内的主机与路由器分配IP地址呢？系统管理员一般手动配置路由器中的IP地址，并使用DHCP自动为主机配置地址</p>
</blockquote>
<p><strong>动态主机配置协议（DHCP）</strong>：DHCP允许主机自动获取一个IP地址，而DHCP又可以被网络管理员手动配置，使得每次分配给一台主机相同IP或者分配临时IP。DHCP也可以获得主机信息，如：</p>
<ul>
<li>子网掩码；</li>
<li>第一条路由器地址（默认网关）；</li>
<li>本地DNS服务器地址；</li>
</ul>
<p>DHCP又被称为<strong>即插即用协议</strong>或<strong>零配置协议</strong>。</p>
<p>DHCP又是一个客户-服务器协议，客户通常是新到达的主机，它要获得包括自身使用的IP地址在内的网络配置信息。在最简单场景中，而每个子网都要拥有一台DHCP服务器，如果某子网中没有服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理知道用于该网络的DHCP服务器的地址。</p>
<p>DHCP分配新地址步骤：</p>
<ul>
<li>DHCP服务器发现：新主机通过使用<strong>DHCP发现报文</strong><ul>
<li>在UDP分组中向端口67发送该报文，DHCP发现报文中使用广播地址<code>255.255.255.255</code>和本机源地址<code>0.0.0.0</code></li>
<li>DHCP客户将该IP数据报发送给链路层；</li>
<li>链路层将该帧广播到所有与该子网连接的节点；</li>
</ul>
</li>
<li>DHCP服务器提供：DHCP服务器收到一个DHCP发现报文，用<strong>DHCP提供报文</strong>向客户做出响应<ul>
<li>该报文向该子网的所有节点广播，仍然使用广播地址<code>255.255.255.255</code>（使用广播的原因是可能有多个服务器共客户选择最优）；</li>
<li>报文包含：<ul>
<li>收到的发现报文的事务ID；</li>
<li>向客户推荐的IP地址；</li>
<li>网络掩码；</li>
<li><strong>IP地址租用期</strong>，即IP地址有效的时间量；</li>
</ul>
</li>
</ul>
</li>
<li>DHCP请求：客户主机选择一个服务器，并使用<strong>DHCP请求报文</strong>进行响应，回显配置参数；</li>
<li>DHCP ACK：服务器使用<strong>DHCP ACK报文</strong>对请求报文进行响应，证实参数；</li>
</ul>
<p>一旦客户接收到 DHCP ACK 后，交互分配即成功，该客户能在租用期内使用该DHCP分配的IP地址。由于可能过期，DHCP还提供了一种机制允许客户更新它对一个IP地址的租用。</p>
<p>DHCP缺陷：每当节点连接到一个新子网，要从DHCP重新获取IP，当移动节点在子网与子网之间移动时，就不能维持IP与远程应用之间的TCP连接。</p>
<h3 id="3-4-网络地址转换"><a href="#3-4-网络地址转换" class="headerlink" title="3.4 网络地址转换"></a>3.4 网络地址转换</h3><blockquote>
<p>考虑家庭路由器以及小型办公室路由器的情形，在这些情形中，ISP显然是不会为每个路由器分配一块区域，太过浪费。这时就有一种广泛使用的<strong>网络地址转换（NAT）</strong>路由器出现了</p>
</blockquote>
<p>地址空间<code>10.0.0.0/8</code>是保留的<strong>专用网络/具有专用地址的地域</strong>，专门配置给家庭网络：</p>
<ul>
<li>对内而言，网络内部的各主机进行分组通信时自然是可以通过诸如<code>10.0.0.1</code>这种IP地址进行的；</li>
<li>但对外而言，如果一台路由器中的主机要访问外部网络，那么不可能所有的家庭主机还使用<code>10.0.0.1</code>这个公共内部地址，这时就需要NAT使能路由器发挥作用了；</li>
</ul>
<p>NAT使能路由器（如图所示）：</p>
<ul>
<li><p>具有一个接口，被DHCP分配IP地址为<code>138.76.29.7</code>，这个IP地址仅在对外访问连接时使用，并且连接在这一台路由器上的所有主机设备都使用这一台链路传输数据；</p>
</li>
<li><p>NAT转换表：将接收到的来自内部主机的源IP统一替换为路由器IP地址，并为该数据报生成一个新的尚未使用的端口号，旧端口号为具体主机使用的源端口号，这样一来，当接收到外部传入的数据包时，再次进行匹配转换最后再传给具体主机；</p>
</li>
<li><p>NAT缺点：</p>
<ul>
<li>端口号是用来进程寻址的，而不是用来主机寻址的；<ul>
<li>解决方法：<strong>NAT穿越</strong>和<strong>通用即插即用（UPnP）</strong>；</li>
</ul>
</li>
<li>路由器时网络层设备，不应该处理IP地址和源端口号这种上层分组；</li>
</ul>
</li>
<li><p>又被称作<strong>中间盒</strong>，功能如下：</p>
<ul>
<li>NAT；</li>
<li>流量流的负载均衡；</li>
<li>流量防火墙；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/100.png" alt="image-20201118145401770" style="zoom:80%;">



<blockquote>
<p>拓展：检查数据报：防火墙和入侵检测系统（IDS）</p>
</blockquote>
<p>对抗恶意分组攻击的两种方式：</p>
<ul>
<li>防火墙：即一般路由器都具有防火墙功能，能够检查数据报和数据报首部字段，拒绝可疑的数据报进入网络内部；</li>
<li>入侵检测系统（IDS）：通常位于网络的边界，执行深度分组检查，不仅检查数据报（包括应用层数据）中的首部字段，而且检查其有效载荷；</li>
</ul>
<h3 id="3-5-IPV6"><a href="#3-5-IPV6" class="headerlink" title="3.5 IPV6"></a>3.5 IPV6</h3><h4 id="3-51-IPV6数据报格式"><a href="#3-51-IPV6数据报格式" class="headerlink" title="3.51 IPV6数据报格式"></a>3.51 IPV6数据报格式</h4><p>与IPV4相较的变化：</p>
<ul>
<li>地址容量扩大：地址长度从32比特扩大到128比特；</li>
<li>简化高效的40字节首部；</li>
<li>流标签：<ul>
<li><strong>流（flow）</strong>：用于给属于特殊流的分组加上标签，这种特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流；</li>
<li>高优先权用户承载的流量也可能被当做一个流；</li>
</ul>
</li>
</ul>
<p>IPV6字段：</p>
<ul>
<li>版本：4比特，IPV6将该字段值设置为6（但并不能简单的设置为4以创建IPV4数据报）；</li>
<li>流量类型：8比特，与IPV4 TOS字段含义类似，用来区分不同类型的数据报；</li>
<li>流标签：20比特，用于标识一条数据报的流，给出更高优先权；</li>
<li>有效载荷长度：16比特，无符号整数，给出了数据部分字节数量；</li>
<li>下一个首部：等同于IPV4协议字段，标识需要交付给哪一个运输层协议；</li>
<li>跳限制：转发数据报的每台路由器对该值减1，计数达到0则该数据报被舍弃；</li>
<li>源地址和目的地址；</li>
<li>数据；</li>
</ul>
<p>不再存在于IPV6上的几个字段：</p>
<ul>
<li>分片/重新组装：由于该操作耗时，因此只能在源和目的地执行，不允许中间路由器执行该操作，如果路由器收到的IPV6数据报太大，则向发送方发回一个“分组太大”的ICMP差错报文，发送方重新发送较小长度的IP数据报；</li>
<li>首部检验和：因为因特网运输层和数据链路层协议执行了检验操作，且耗时，故舍弃；</li>
<li>选项：不再是标准首部的一部分，而是可能出现在IPV6首部中“下一个首部”字段位置；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/101.png" alt="image-20201118155410687" style="zoom:80%;">



<h4 id="3-52-从IPV4到IPV6的迁移"><a href="#3-52-从IPV4到IPV6的迁移" class="headerlink" title="3.52 从IPV4到IPV6的迁移"></a>3.52 从IPV4到IPV6的迁移</h4><blockquote>
<p>IPV6使能系统能向后兼容，即能发送、路由和接收IPV4数据报，但已经部署的具有IPV4数据报能力的系统却不能处理IPV6数据报</p>
</blockquote>
<p>实践可行的解决方案是<strong>建隧道</strong>，其基本思想是：假定两个IPV6节点要使用中间IPV4节点进行互联，则将该中间IPV4路由器称为一个<strong>隧道</strong>。在隧道发送端，IPV6节点将整个IPV6数据报放到一个IPV4数据报的数据字段中，在隧道接收端，IPV6节点最终接收到该IPV4数据报，并通过确认其首部协议号字段值为41，从中取出IPV6数据报并为该数据报提供路由。</p>
<h2 id="4-通用转发和SDN"><a href="#4-通用转发和SDN" class="headerlink" title="4.通用转发和SDN"></a>4.通用转发和SDN</h2><blockquote>
<p>通用转发用来提供多种网络层功能以及某些链路层功能，进而解决多种第三层中间盒独立发展配置的问题</p>
</blockquote>
<p>先将第三层基于目的地转发的特征总结为两个步骤：</p>
<ul>
<li>查找IP地址（匹配）；</li>
<li>将分组发送到有特定输出端口的交换结构（动作）；</li>
</ul>
<p>通用转发就整合这两个步骤，形成新的“匹配加动作”范式，该设备又被称为<strong>分组交换机</strong>：</p>
<ul>
<li>能够对多个首部字段进行“匹配”；</li>
<li>“动作”包括：<ul>
<li>将分组转发到一个或多个输出端口（就像基于目的地转发一样）；</li>
<li>跨越多个通向服务的离开接口进行负载均衡分组（就像负载均衡一样）；</li>
<li>重写首部值（就像NAT一样）；</li>
<li>有意识地阻挡/丢弃某个分组（就像防火墙一样）；</li>
<li>为进一步处理和动作而像某个特定的服务器发送一个分组（就像DPI一样）；</li>
</ul>
</li>
</ul>
<p>如图显示了位于每台分组交换机中的一张匹配加动作表，该表由远程控制器计算、安装和更新：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/102.png" alt="image-20201118204009875" style="zoom:80%;">



<p><strong>OpenFlow</strong>是一个得到高度认可和成功的通用转发的标准，已经成为匹配加动作转发抽象、控制器以及更为一般的SDN革命等概念的先驱，后续对通用转发的讨论也将基于OpenFlow。</p>
<p>匹配加动作转发表在OpenFlow中被称作<strong>流表</strong>，它的每个<strong>表项</strong>包括：</p>
<ul>
<li>首部字段值的集合：入分组与之匹配；</li>
<li>计数器集合：当分组与流表匹配时更新计数器，这些计数器可以包括已经与该流表项匹配的分组数量，以及自从该表项上次更新以来的时间等；</li>
<li>当分组匹配流表项时所采取的的动作集合；</li>
</ul>
<h3 id="4-1-匹配"><a href="#4-1-匹配" class="headerlink" title="4.1 匹配"></a>4.1 匹配</h3><p>OpenFlow的匹配抽象允许对来自三个层次的协议首部所选择的字段进行匹配，但基于功能复杂性，并非一个IP首部所有的字段都能被匹配，如OpenFlow并不允许基于TTL字段或数据长度字段的匹配。</p>
<p>入端口是指分组交换机上接收分组的输入端口，运输层源和目的端口号字段也能匹配。</p>
<p>流表项也可有通配符，如<code>128.119.*.*</code>格式，每个流表项也具有相应的优先权。如果一个分组匹配多个流表项，选定的匹配和对应的动作将是其中优先权最高的那个。</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/103.png" alt="image-20201118205852856" style="zoom:80%;">



<h3 id="4-2-动作"><a href="#4-2-动作" class="headerlink" title="4.2 动作"></a>4.2 动作</h3><p>每个流表项都拥有零个或多个动作，如果有多个动作，它们以在表中规定的次序执行，其中最重要的动作是：</p>
<ul>
<li>转发：<ul>
<li>一个入分组可以转发到一个特定的物理输出端口，或者广播到除入端口外的所有端口，或者通过所选的端口集合进行多播；</li>
<li>该分组可能被封装并发送到用于该设备的远程控制器，该控制器可能对该分组采取某些动作并安装或更新新的流表项重新转发；</li>
</ul>
</li>
<li>丢弃：没有动作的流表项表明某个匹配的分组应该被丢弃；</li>
<li>修改字段：在分组被转发到相应的输出端口前，分组首部的10个字段（图4-29中显示的除IP协议字段外的所有第二、三、四层的字段）中的值可以重写；</li>
</ul>
<h3 id="4-3-匹配加动作操作中的OpenFlow例子"><a href="#4-3-匹配加动作操作中的OpenFlow例子" class="headerlink" title="4.3 匹配加动作操作中的OpenFlow例子"></a>4.3 匹配加动作操作中的OpenFlow例子</h3><p>例：该网络具有六台主机（h系列）以及三台分组交换机（s系列），每台交换机具有四个本地接口（1-4）</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/104.png" alt="image-20201118211728849" style="zoom:80%;">

<blockquote>
<p>第一个例子：简单转发</p>
</blockquote>
<p>假定希望的转发行为是：来自h5/h6的发往h3/h4的分组从s3转发到s1，再从s1转发到s2</p>
<ul>
<li>s1中的流表项：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/105.png" alt="image-20201118212140005" style="zoom:80%;">

<ul>
<li>s3中的流表项：从h5/h6经过接口s3转发到s1</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/106.png" alt="image-20201118212215390" style="zoom:80%;">

<ul>
<li>s2中的流表项：s1转发到目的主机h3/h4</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/107.png" alt="image-20201118212245271" style="zoom:80%;">



<blockquote>
<p>第二个例子：负载均衡</p>
</blockquote>
<p>来自h3发往<code>10.1.*.*</code>的数据报经过s1和s2之间的直接链路转发，同时来自于h4发往<code>10.1.*.*</code>的数据报经过s2和s3之间的链路转发</p>
<ul>
<li>s2中的流表项：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/108.png" alt="image-20201118212619944" style="zoom:80%;">



<blockquote>
<p>第三个例子：充当防火墙</p>
</blockquote>
<p>s2仅希望接收到来自与s3相连的主机所发送的流量</p>
<ul>
<li>s2中的流表项：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/109.png" alt="image-20201118212747781" style="zoom:80%;">


]]></content>
      <categories>
        <category>计算机网络自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下方法</tag>
        <tag>理论学习</tag>
        <tag>教材</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/09/06/javascript%EF%BC%88%E5%90%ABjQuery%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-引入script"><a href="#1-引入script" class="headerlink" title="1.引入script"></a>1.引入script</h2><ul>
<li>内部写入；</li>
<li>外部引入；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.在html页面内部写入js代码    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--script标签内，写js代码    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;script&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        alert(&#x27;hello,world&#x27;);--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;/script&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.外部导入    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认type=&quot;text/javascript&quot; 可以不用写出     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/helloworld.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>



<a id="more"></a>



<hr>
<h2 id="2-基本语法入门"><a href="#2-基本语法入门" class="headerlink" title="2.基本语法入门"></a>2.基本语法入门</h2><ul>
<li>定义变量 var 变量名 = 变量值;    只有var一种变量类型；</li>
<li>条件控制同java；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.定义变量 var 变量名 = 变量值;    只有var一种变量类型</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> score = <span class="number">75</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.条件控制同java</span></span></span><br><span class="line">        if(score&gt;=60&amp;&amp;score&lt;70)&#123;</span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;60-70&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">70</span>&amp;&amp;score&lt;<span class="number">80</span>)&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;70-80&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span>&amp;&amp;score&lt;<span class="number">90</span>)&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;80-80&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;other&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(score);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//console.log(score); 在浏览器控制台打印变量，相当于sout;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用浏览器：<ul>
<li>Elements：html+css代码区域；</li>
<li>Console：控制台，可以在此处写入js执行代码；</li>
<li>Source：js源代码区域，可以断点debug，在此处debug代码；</li>
<li>Network：网络元素；</li>
<li>Application：应用；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/018.png"></p>
<hr>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><ul>
<li>数值、文本、图形、音频、视频……</li>
</ul>
<h3 id="3-1变量"><a href="#3-1变量" class="headerlink" title="3.1变量"></a>3.1变量</h3><ul>
<li>以字母、$、_ 等符号开头，可以使用中文定义，大小写敏感；</li>
<li>定义变量类型只有var一种类型；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 王者荣耀 = <span class="string">&quot;倔强青铜&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-2number"><a href="#3-2number" class="headerlink" title="3.2number"></a>3.2number</h3><ul>
<li>js不区分小数和整数；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>			<span class="comment">//整数123</span></span><br><span class="line"><span class="number">123.1</span>		<span class="comment">//浮点数123.1</span></span><br><span class="line"><span class="number">1.123e3</span>		<span class="comment">//科学计数法1123</span></span><br><span class="line"><span class="number">-99</span>			<span class="comment">//负数-99</span></span><br><span class="line"><span class="literal">NaN</span>			<span class="comment">//Not a Number</span></span><br><span class="line"><span class="literal">Infinity</span>	<span class="comment">//无穷大</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3字符串"><a href="#3-3字符串" class="headerlink" title="3.3字符串"></a>3.3字符串</h3><ul>
<li><p>正常字符串表示形式：</p>
<ul>
<li>‘abc’；</li>
<li>“abc”；</li>
</ul>
</li>
<li><p>转义字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\<span class="string">&#x27;</span></span><br><span class="line"><span class="string">\n</span></span><br><span class="line"><span class="string">\t</span></span><br><span class="line"><span class="string">\u		//\u#### Unicode字符</span></span><br><span class="line"><span class="string">\x		//Ascll字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行字符串：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Esc下键``</span></span><br><span class="line"><span class="keyword">var</span> msg =</span><br><span class="line">    <span class="string">`hello</span></span><br><span class="line"><span class="string">	world`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;zhaoxiaoan&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板：$&#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`hello,<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg);</span><br><span class="line"><span class="comment">//&gt;hello,zhaoxiaoan</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串长度：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.length;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大小写转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，此处是方法而不是属性</span></span><br><span class="line">str.toUpperCase();</span><br><span class="line">str.toLpwerCase();</span><br></pre></td></tr></table></figure>
</li>
<li><p>该字符在字符串中第一次出现的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.indexOf(<span class="string">&#x27;t&#x27;</span>);<span class="comment">//获得下标索引</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>substring：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[)</span><br><span class="line">str.substring(<span class="number">1</span>);		<span class="comment">//从第一个字符直到最后一个字符</span></span><br><span class="line">str.substring(<span class="number">1</span>,<span class="number">3</span>);		<span class="comment">//[1,3)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串数组操作（不可变性）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/019.png" alt="image-20200826134313146"></p>
</li>
</ul>
<h3 id="3-4布尔值"><a href="#3-4布尔值" class="headerlink" title="3.4布尔值"></a>3.4布尔值</h3><ul>
<li>true；</li>
<li>false；</li>
<li>判断输出时显示；</li>
</ul>
<h3 id="3-5逻辑运算符"><a href="#3-5逻辑运算符" class="headerlink" title="3.5逻辑运算符"></a>3.5逻辑运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;&amp;	<span class="comment">//与</span></span><br><span class="line">    </span><br><span class="line">||	<span class="comment">//或</span></span><br><span class="line">    </span><br><span class="line">!	<span class="comment">//非</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6比较运算符"><a href="#3-6比较运算符" class="headerlink" title="3.6比较运算符"></a>3.6比较运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">=		<span class="comment">//赋值符号</span></span><br><span class="line">==		<span class="comment">//等于（类型不一样，值一样，也会判断为true，如1==“1”得到true）</span></span><br><span class="line">===		<span class="comment">//绝对等于（类型一样，纸一样，才为true），所以一般使用===比较而不使用==</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>NaN===NaN，false，NaN与所有的数值都不相等，包括自己；</p>
</li>
<li><p>使用isNaN()判断变量是否为NaN；</p>
</li>
<li><p>浮点数问题：</p>
<ul>
<li><pre><code class="javascript">console.log((1/3)===(1-2/3);    //false
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 浮点数存在精度问题；</span><br><span class="line"></span><br><span class="line">- 常使用以下方式解决：</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  Math.abs((<span class="number">1</span>/<span class="number">3</span>)-(<span class="number">1</span><span class="number">-2</span>/<span class="number">3</span>)&lt;<span class="number">0.000000001</span>);</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-7null和undefined"><a href="#3-7null和undefined" class="headerlink" title="3.7null和undefined"></a>3.7null和undefined</h3><ul>
<li>null：空；</li>
<li>undefined：未定义；</li>
</ul>
<h3 id="3-8数组"><a href="#3-8数组" class="headerlink" title="3.8数组"></a>3.8数组</h3><ul>
<li>java的数组中必须为相同类型，js不是；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;abs&quot;</span>,<span class="literal">null</span>,<span class="literal">true</span>];<span class="comment">//常用此方式定义数组类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;abs&quot;</span>,<span class="literal">null</span>,<span class="literal">true</span>);<span class="comment">//不常用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>取数组下标，如果越界，会显示undefined而不会执行更多的安全性检查；</p>
</li>
<li><p>多维数组：</p>
<ul>
<li><pre><code class="javascript">arr = [[1,2,3],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]]
&gt;(2) [Array(3), Array(3)]
arr[1][1]
&gt;&quot;b&quot;
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 常用的方法和属性：</span><br><span class="line"></span><br><span class="line">  - ```javascript</span><br><span class="line">    var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.length</span></span><br><span class="line">    arr.length</span><br><span class="line">    &gt;<span class="number">6</span></span><br><span class="line">    <span class="comment">//给arr.length赋值时，长度增大则显示undefined，长度减小则从后往前删减元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.indexOf</span></span><br><span class="line">    arr.indexOf(<span class="number">2</span>)</span><br><span class="line">    &gt;<span class="number">1</span></span><br><span class="line">    <span class="comment">//字符索引，对所给元素判断最先出现位置下标，注意：1和&#x27;1&#x27;不同，索引也不同</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.slice()</span></span><br><span class="line">    arr.slice(<span class="number">3</span>)</span><br><span class="line">    &gt;(<span class="number">3</span>) [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="comment">//截取array的一部分，返回一个新数组，类似于String中的substring()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.push()、pop()</span></span><br><span class="line">    arr.push(&#x27;a&#x27;,&#x27;b&#x27;)</span><br><span class="line">    &gt;<span class="number">8</span></span><br><span class="line">    arr</span><br><span class="line">    &gt;(<span class="number">8</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line">    arr.pop()</span><br><span class="line">    &gt;<span class="string">&quot;b&quot;</span></span><br><span class="line">    arr</span><br><span class="line">    &gt;(<span class="number">7</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">    <span class="comment">//在原数组的尾部插入或取出元素，push可以同时处理多个元素，而pop每次只能取出一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.unshift()、shift()</span></span><br><span class="line">    arr.unshift(&#x27;a&#x27;)</span><br><span class="line">    &gt;<span class="number">8</span></span><br><span class="line">    arr</span><br><span class="line">    &gt;(<span class="number">8</span>) [<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">    arr.shift()</span><br><span class="line">    &gt;<span class="string">&quot;a&quot;</span></span><br><span class="line">    arr</span><br><span class="line">    &gt;(<span class="number">7</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">    <span class="comment">//从数组头部插入或取出元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.sort()</span></span><br><span class="line">    arr = [&#x27;B&#x27;,&#x27;b&#x27;,&#x27;C&#x27;]</span><br><span class="line">    &gt;(<span class="number">3</span>) [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line">    arr.sort()</span><br><span class="line">    &gt;(<span class="number">3</span>) [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line">    <span class="comment">//将数组按照Ascll码值进行顺序排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.reverse()</span></span><br><span class="line">    arr.reverse()</span><br><span class="line">    &gt;(<span class="number">3</span>) [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">    <span class="comment">//将数组元素反转</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.concat()</span></span><br><span class="line">    arr.concat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,])</span><br><span class="line">    &gt;(<span class="number">6</span>) [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    arr</span><br><span class="line">    &gt;(<span class="number">3</span>) [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">    <span class="comment">//拼接数组，并且返回一个新数组而不是在原数组上修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.join()</span></span><br><span class="line">    arr.join(&#x27;-&#x27;)</span><br><span class="line">    &gt;<span class="string">&quot;b-C-B&quot;</span></span><br><span class="line">    arr</span><br><span class="line">    &gt;(<span class="number">3</span>) [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">    <span class="comment">//添加连接符号并且输出新的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10.splice(index,x,&quot;&quot;,&quot;&quot;,...),index表示下标索引，x表示删除数组个数，&quot;&quot;可以自行添加元素</span></span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-9对象"><a href="#3-9对象" class="headerlink" title="3.9对象"></a>3.9对象</h3><ul>
<li>所有键都是字符串，尤其是在判断中要加上引号；</li>
<li>对象使用大括号，相当于匿名内部类；</li>
<li>使用键值对定义赋值，属性之间使用 <strong>”,“</strong> 隔开最后一个属性不需要添加；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">&quot;zhaoxiaoan&quot;</span>,</span><br><span class="line">    age:<span class="number">3</span>,</span><br><span class="line">    tags:[<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;web&#x27;</span>,<span class="string">&#x27;...&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取变量值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person.name</span><br><span class="line">&gt;zhaoxiaoan</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个不存在的属性，不会报错，而是undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.haha</span><br><span class="line">&gt;<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用的方法和属性：</p>
<ul>
<li><pre><code class="javascript">//1.delete
delete person.name
&gt;true
person
&gt;&#123;age: 3, tags: Array(4)&#125;
//动态地删减对象的属性

//2.增加
person.haha = &#39;haha&#39;
&gt;&quot;haha&quot;
person
&gt;&#123;age: 3, tags: Array(4), haha: &quot;haha&quot;&#125;
//动态地增加属性直接赋值即可

//3.判断属性值是否在对象中
&#39;age&#39; in person
&gt;true
&#39;toString&#39; in person
&gt;true
//有继承性质，&#39;toString&#39;是继承属性

//4.hasOwnProperty()
person.hasOwnProperty(&#39;age&#39;)
&gt;true
person.hasOwnProperty(&#39;toString&#39;)
&gt;false
//判断是否为自身定义属性

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.10.流程控制</span><br><span class="line"></span><br><span class="line">- if、while、for普通使用同Java；</span><br><span class="line"></span><br><span class="line">- 常用用法：</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  //shift+tab对齐</span><br><span class="line">  //1.forEach循环</span><br><span class="line">  var age = [1,2,3,6,4,5,8,21,3,5];</span><br><span class="line">  age.forEach(function (value) &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  &gt;1</span><br><span class="line">  &gt;2</span><br><span class="line">  &gt;3</span><br><span class="line">  &gt;6</span><br><span class="line">  &gt;4</span><br><span class="line">  &gt;5</span><br><span class="line">  &gt;8</span><br><span class="line">  &gt;21</span><br><span class="line">  &gt;3</span><br><span class="line">  &gt;5</span><br><span class="line">  </span><br><span class="line">  //2.for in 循环</span><br><span class="line">  for (var num in age)&#123;</span><br><span class="line">      console.log(age[num]);</span><br><span class="line">  &#125;</span><br><span class="line">  &gt;1</span><br><span class="line">  &gt;2</span><br><span class="line">  &gt;3</span><br><span class="line">  &gt;6</span><br><span class="line">  &gt;4</span><br><span class="line">  &gt;5</span><br><span class="line">  &gt;8</span><br><span class="line">  &gt;21</span><br><span class="line">  &gt;3</span><br><span class="line">  &gt;5</span><br><span class="line">  //适用于未知数组长度，用于得到数组索引</span><br><span class="line">  </span><br><span class="line">  //3.for of 循环</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-11-Map、Set"><a href="#3-11-Map、Set" class="headerlink" title="3.11.Map、Set"></a>3.11.Map、Set</h3><ul>
<li>Map</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">100</span>],[<span class="string">&#x27;jack&#x27;</span>,<span class="number">90</span>],[<span class="string">&#x27;hash&#x27;</span>,<span class="number">80</span>]]);	<span class="comment">//键值对数组</span></span><br><span class="line"><span class="keyword">var</span> name = map.get(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">map.set(<span class="string">&#x27;admin&#x27;</span>,<span class="number">60</span>);	<span class="comment">//添加和修改</span></span><br><span class="line">map.delete(<span class="string">&#x27;Tom&#x27;</span>);		<span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="number">100</span></span><br><span class="line">map</span><br><span class="line">&gt;<span class="built_in">Map</span>(<span class="number">3</span>) &#123;<span class="string">&quot;jack&quot;</span> =&gt; <span class="number">90</span>, <span class="string">&quot;hash&quot;</span> =&gt; <span class="number">80</span>, <span class="string">&quot;admin&quot;</span> =&gt; <span class="number">60</span>&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Set</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]);     <span class="comment">//去重数组</span></span><br><span class="line">set.add(<span class="number">100</span>);   <span class="comment">//添加</span></span><br><span class="line">set.delete(<span class="number">2</span>);  <span class="comment">//删除</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">3</span>));    <span class="comment">//判断是否存在该元素</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="literal">true</span></span><br><span class="line">set</span><br><span class="line">&gt;<span class="built_in">Set</span>(<span class="number">4</span>) &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>遍历</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.数组遍历元素</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">3</span></span><br><span class="line">&gt;<span class="number">4</span></span><br><span class="line">&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Map遍历元素</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">100</span>],[<span class="string">&#x27;jack&#x27;</span>,<span class="number">90</span>],[<span class="string">&#x27;hash&#x27;</span>,<span class="number">80</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">&gt;(<span class="number">2</span>) [<span class="string">&quot;Tom&quot;</span>, <span class="number">100</span>]</span><br><span class="line">&gt;(<span class="number">2</span>) [<span class="string">&quot;jack&quot;</span>, <span class="number">90</span>]</span><br><span class="line">&gt;(<span class="number">2</span>) [<span class="string">&quot;hash&quot;</span>, <span class="number">80</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Set遍历元素</span></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]);     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">3</span></span><br><span class="line">&gt;<span class="number">6</span></span><br><span class="line">&gt;<span class="number">2</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：for in只有数组可用，Map，Set皆不可用，且只能遍历索引</span></span><br><span class="line"><span class="comment">//bug:</span></span><br><span class="line">arr.name = <span class="string">&#x27;zhaoxiaoan&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">0</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line">&gt;<span class="number">2</span></span><br><span class="line">&gt;name</span><br><span class="line"><span class="comment">//此时索引号会变成键名，且不能输出name相对应的值zhaoxiaoan</span></span><br></pre></td></tr></table></figure>



<h3 id="3-12-严格检查模式"><a href="#3-12-严格检查模式" class="headerlink" title="3.12.严格检查模式"></a>3.12.严格检查模式</h3><ul>
<li>是为了防止多个js文件中全局变量互相矛盾的问题，在每个js文件或<code>&lt;script&gt;</code>标签中都使用；</li>
<li>在js代码第一行写入代码 <strong><em>‘use strict’;</em></strong> ，表明使用严格检查模式；</li>
<li>定义变量时都定义为局部变量，建议使用<strong>let</strong>标识符而不使用<strong>var</strong>；</li>
</ul>
<hr>
<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><h3 id="4-1定义函数"><a href="#4-1定义函数" class="headerlink" title="4.1定义函数"></a>4.1定义函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绝对值函数</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种定义方式效果相同，常用一</span></span><br><span class="line">abs(<span class="number">10</span>)</span><br><span class="line">&gt;<span class="number">10</span></span><br><span class="line">abs(<span class="number">-10</span>)</span><br><span class="line">&gt;<span class="number">10</span></span><br><span class="line">abs()</span><br><span class="line">&gt;<span class="literal">NaN</span></span><br><span class="line"><span class="comment">//注意，未传入参数则undefined</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2参数"><a href="#4-2参数" class="headerlink" title="4.2参数"></a>4.2参数</h3><ul>
<li>函数可以传入任意个参数，即使未定义</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//手动抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x!== <span class="string">&#x27;number&#x27;</span>)&#123;<span class="comment">//x的数据类型不为&#x27;number&#x27;，不传入参数时x未定义，会抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Not a Number&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abs()</span><br><span class="line">&gt;Uncaught Not a <span class="built_in">Number</span></span><br></pre></td></tr></table></figure>

<ul>
<li>arguments：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> a <span class="keyword">of</span> <span class="built_in">arguments</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abs(<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">555</span>,<span class="number">5</span>)</span><br><span class="line">&gt;x=<span class="number">1</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line">&gt;<span class="number">3</span></span><br><span class="line">&gt;<span class="number">6</span></span><br><span class="line">&gt;<span class="number">2</span></span><br><span class="line">&gt;<span class="number">555</span></span><br><span class="line">&gt;<span class="number">5</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line"><span class="comment">//arguments用于接收所有传入参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>rest：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b,...rest</span>) </span>&#123;<span class="comment">//...rest只能放在参数列最后一个，用于接收多余的参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a=&#x27;</span>+a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b=&#x27;</span>+b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">63</span>,<span class="number">9</span>,<span class="number">52</span>,<span class="number">85</span>,<span class="number">666</span>,<span class="number">555</span>,<span class="number">985</span>)</span><br><span class="line">&gt;a=<span class="number">1</span></span><br><span class="line">&gt;b=<span class="number">5</span></span><br><span class="line">&gt;(<span class="number">8</span>) [<span class="number">2</span>, <span class="number">63</span>, <span class="number">9</span>, <span class="number">52</span>, <span class="number">85</span>, <span class="number">666</span>, <span class="number">555</span>, <span class="number">985</span>]</span><br></pre></td></tr></table></figure>



<h3 id="4-3变量的作用域"><a href="#4-3变量的作用域" class="headerlink" title="4.3变量的作用域"></a>4.3变量的作用域</h3><ul>
<li><p>var 关键字具有作用范围：</p>
<ul>
<li>在一个函数内部定义的变量名，只能往下延伸，不能在该函数外使用；</li>
<li>在函数内部的函数中，定义一个与父函数相同的变量，调用时优先调用自身变量；</li>
<li>ES6之前，var变量存在一定Bug：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"><span class="comment">//结果如下，i值在函数f1()外依然可以调用</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/021.png" alt="image-20200827150554681"></p>
<ul>
<li>由此引入 let 关键字解决局部作用域冲突问题：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"><span class="comment">//let定义变量只在作用域内部有效，外部调用报错：ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/022.png" alt="image-20200827150804774"></p>
</li>
<li><p>作用域内部所有变量定义，无论位置，在 js 编译时都自动将定义提前，但并不会赋值初始化：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&#x27;x&#x27;</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//未定义 let y = &#x27;y&#x27;; 时:ReferenceError: y is not defined</span></span><br><span class="line"><span class="comment">//定义 let y = &#x27;y&#x27;; 后:ReferenceError: Cannot access &#x27;y&#x27; before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规范写法：将所有变量定义提前到作用域开头</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>&lt;script&gt;</code>中直接定义的全局变量（包括对象和函数），以及直接从库中调用的类似于alert()函数，实质上全部属于window全局对象：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">alert(x);</span><br><span class="line">alert(<span class="built_in">window</span>.x);</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="built_in">window</span>.x);</span><br><span class="line"><span class="comment">//三条语句实质上等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> old_alert = <span class="built_in">window</span>.alert();</span><br><span class="line"><span class="built_in">window</span>.alert() = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//给window.alert()赋予了新的函数，导致原函数失效</span></span><br><span class="line"><span class="built_in">window</span>.alert(<span class="number">123</span>);<span class="comment">//失效了无法显示弹窗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复window.alert()</span></span><br><span class="line"><span class="built_in">window</span>.alert = old_alert;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="number">456</span>);<span class="comment">//可以显示该弹窗</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为window全局对象的危险性，为确保在多个js文件中代码保持安全性，规范法则，自己单独创建一个对象用于存放自己的变量，相当于每个人都拥有一个属于自己的window对象，而不会被其它人无意篡改：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建唯一全局对象</span></span><br><span class="line"><span class="keyword">var</span> ZhaoApp = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义属于自己的全局变量</span></span><br><span class="line">ZhaoApp.name = <span class="string">&#x27;zhaoxiaoan&#x27;</span>;</span><br><span class="line">ZhaoApp.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6引入常量 const 关键字，只读：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="string">&#x27;3.14&#x27;</span>;</span><br><span class="line">PI = <span class="string">&#x27;314&#x27;</span>;<span class="comment">//该语句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在引入const之前都使用大写字母表示常量，但依然由var定义，值可改变</span></span><br></pre></td></tr></table></figure>



<h3 id="4-4方法"><a href="#4-4方法" class="headerlink" title="4.4方法"></a>4.4方法</h3><ul>
<li>定义方法：对象内部定义的函数叫做方法；<ul>
<li>其中this的用法和java相似，但更丰富，它默认指向调用该函数或者该方法的对象，如方式二中外部调用函数也是可行的，然而直接调用getAge()函数时却得到NaN，本质是此时调用函数对象是window本身，而window对象并不存在.name属性；</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> zhaoxiaoan = &#123;</span><br><span class="line">    name:<span class="string">&#x27;朝小闇&#x27;</span>,</span><br><span class="line">    birth:<span class="number">2000</span>,</span><br><span class="line">    age:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> (nowYear-<span class="built_in">this</span>.birth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象内部只存在属性和方法两种内容</span></span><br><span class="line"><span class="comment">//调用方法需要()</span></span><br><span class="line">zhaoxiaoan.age()</span><br><span class="line">&gt;<span class="number">20</span></span><br><span class="line"><span class="comment">//调用属性则不用()</span></span><br><span class="line">zhaoxiaoan.name</span><br><span class="line">&gt;<span class="string">&quot;朝小闇&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> (nowYear-<span class="built_in">this</span>.birth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhaoxiaoan = &#123;</span><br><span class="line">    name : <span class="string">&#x27;朝小闇&#x27;</span>,</span><br><span class="line">    birth : <span class="number">2000</span>,</span><br><span class="line">    age : getAge</span><br><span class="line">&#125;</span><br><span class="line">zhaoxiaoan.age()</span><br><span class="line">&gt;<span class="number">20</span></span><br><span class="line">zhaoxiaoan.name</span><br><span class="line">&gt;<span class="string">&quot;朝小闇&quot;</span></span><br><span class="line">getAge()</span><br><span class="line">&gt;<span class="literal">NaN</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply()方法：所有函数共有，它的作用是将this默认指向改为指定指向对象：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> (nowYear-<span class="built_in">this</span>.birth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhaoxiaoan = &#123;</span><br><span class="line">    name : <span class="string">&#x27;朝小闇&#x27;</span>,</span><br><span class="line">    birth : <span class="number">2000</span>,</span><br><span class="line">    age : getAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中第一个参数为指向对象名，第二个为传入该函数的参数列表，用数组表示</span></span><br><span class="line">getAge.apply(zhaoxiaoan,[])</span><br><span class="line">&gt;<span class="number">20</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="5-内部对象"><a href="#5-内部对象" class="headerlink" title="5.内部对象"></a>5.内部对象</h2><h3 id="5-1-标准对象类型"><a href="#5-1-标准对象类型" class="headerlink" title="5.1 标准对象类型"></a>5.1 标准对象类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span></span><br><span class="line">&gt;<span class="string">&quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&gt;<span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span></span><br><span class="line">&gt;<span class="string">&quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>		<span class="comment">//NaN 虽然含义为Not a Number,但却是number类型</span></span><br><span class="line">&gt;<span class="string">&quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []		</span><br><span class="line">&gt;<span class="string">&quot;object&quot;</span>		<span class="comment">//对象类型</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;</span><br><span class="line">&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs</span><br><span class="line">&gt;<span class="string">&quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line">&gt;<span class="string">&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-Date"><a href="#5-2-Date" class="headerlink" title="5.2 Date"></a>5.2 Date</h3><ul>
<li>常用时间方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nowDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">nowDate.getFullYear();	<span class="comment">//年</span></span><br><span class="line">&gt;<span class="number">2020</span></span><br><span class="line">nowDate.getMonth();		<span class="comment">//月，注意，设计月份为0-11，得到7实质是8月</span></span><br><span class="line">&gt;<span class="number">7</span></span><br><span class="line">nowDate.getDate();		<span class="comment">//日</span></span><br><span class="line">&gt;<span class="number">27</span>	</span><br><span class="line">nowDate.getDay();		<span class="comment">//星期</span></span><br><span class="line">&gt;<span class="number">4</span></span><br><span class="line">nowDate.getHours();		<span class="comment">//时</span></span><br><span class="line">&gt;<span class="number">18</span></span><br><span class="line">nowDate.getMinutes();	<span class="comment">//分</span></span><br><span class="line">&gt;<span class="number">52</span></span><br><span class="line">nowDate.getSeconds();	<span class="comment">//秒</span></span><br><span class="line">&gt;<span class="number">43</span></span><br><span class="line">nowDate.getTime();		<span class="comment">//时间戳，以1970-1-1 00:00:00为始计算毫秒数</span></span><br><span class="line">&gt;<span class="number">1598525563925</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间转化：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1598525563925</span>))	<span class="comment">//时间戳转化成具体标准时间</span></span><br><span class="line">&gt;Thu Aug <span class="number">27</span> <span class="number">2020</span> <span class="number">18</span>:<span class="number">52</span>:<span class="number">43</span> GMT+<span class="number">0800</span> (中国标准时间)<span class="comment">//GMT中国标准时间</span></span><br><span class="line"></span><br><span class="line">nowDate.toLocaleString();		<span class="comment">//转化为当地时间</span></span><br><span class="line">&gt;<span class="string">&quot;2020/8/27 下午6:52:43&quot;</span></span><br><span class="line"></span><br><span class="line">nowDate.toGMTString();</span><br><span class="line">&gt;<span class="string">&quot;Thu, 27 Aug 2020 10:52:43 GMT&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-JSON"><a href="#5-3-JSON" class="headerlink" title="5.3 JSON"></a>5.3 JSON</h3><ul>
<li><p>定义：</p>
<ul>
<li>JSON是一种轻量级的交换格式；</li>
<li>具有简洁和清晰的<strong>层次结构</strong>；</li>
<li>能够有效提升网络传输效率；</li>
</ul>
</li>
<li><p>在 javascript 中一切都皆对象，任何 js 支持的类型都能用 JSON 来表示；</p>
</li>
<li><p>格式：</p>
<ul>
<li>对象 {}</li>
<li>数组 []</li>
<li>键值对 key : value </li>
</ul>
</li>
<li><p>对象与JSON格式相互转换：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    name : <span class="string">&#x27;zhaoxiaoan&#x27;</span>,</span><br><span class="line">    age : <span class="number">3</span>,</span><br><span class="line">    sex : <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON.stringify()将对象转换为JSON格式</span></span><br><span class="line"><span class="keyword">let</span> jsonUser = <span class="built_in">JSON</span>.stringify(user);</span><br><span class="line">jsonUser</span><br><span class="line">&gt;<span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhaoxiaoan&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">// 得到字符串 注意，外部用&#x27;&#x27;,内部用&quot;&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON.parse()将JSON格式转换为对象</span></span><br><span class="line"><span class="keyword">let</span> parseUser = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhaoxiaoan&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span>);</span><br><span class="line">parseUser</span><br><span class="line">&gt;&#123;<span class="attr">name</span>: <span class="string">&quot;zhaoxiaoan&quot;</span>, <span class="attr">age</span>: <span class="number">3</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 得到对象，可展开</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象与JSON区别</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象格式</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;zhaoxiaoan&quot;</span>, <span class="attr">age</span>: <span class="number">3</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//json本质是字符串</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;zhaoxiaoan&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="6-面向对象编程"><a href="#6-面向对象编程" class="headerlink" title="6.面向对象编程"></a>6.面向对象编程</h2><ul>
<li>基础概念：javascript、java、C#等编程语言都是面向对象的；</li>
<li>面向对象编程：<ul>
<li>类：模板</li>
<li>对象：具体实例</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_44339531/article/details/104204377">java一切都是对象博客链接</a></p>
<h3 id="6-1-原型继承"><a href="#6-1-原型继承" class="headerlink" title="6.1 原型继承"></a>6.1 原型继承</h3><ul>
<li>原型的特性就在于可以随时修改；</li>
<li>一个对象定义之后指向自己本身的原型，对象和对象原型并不是一个同一样事物；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name : <span class="string">&#x27;zhaoxiaoan&#x27;</span>,</span><br><span class="line">    age : <span class="number">3</span>,</span><br><span class="line">    run : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name : <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明的原型指向Student，相当于父类</span></span><br><span class="line">xiaoming.__proto__ = Student;</span><br><span class="line"></span><br><span class="line">xiaoming</span><br><span class="line">&gt;&#123;<span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line">&gt;name: <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">&gt;__proto__:</span><br><span class="line">&gt;age: <span class="number">3</span></span><br><span class="line">&gt;name: <span class="string">&quot;zhaoxiaoan&quot;</span></span><br><span class="line">&gt;run: ƒ ()</span><br><span class="line">&gt;__proto__: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">xiaoming.run()</span><br><span class="line">&gt;xiaomingis running</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中 __proto__ 原型指向Student，属性和方法直接继承原型，但是相同属性name依然默认调用自身name属性，而Student的原型则为Object对象(window全局对象最终原型同样指向Object对象)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird;</span><br><span class="line"><span class="comment">//可以随时修改指向原型，修改后:</span></span><br><span class="line">xiaoming.run()</span><br><span class="line">&gt;<span class="built_in">TypeError</span>: xiaoming.run is not a <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"><span class="title">xiaoming</span>.<span class="title">fly</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&gt;<span class="title">xiaomingis</span> <span class="title">flying</span></span></span><br><span class="line"><span class="function"><span class="title">xiaoming</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;name: <span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line">&gt;name: <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">&gt;__proto__:</span><br><span class="line">&gt;fly: ƒ ()</span><br><span class="line">&gt;__proto__: <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Student新增一个方法</span></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//prototype 是指对Student原型添加一个方法，而Student对象指向自身的原型</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-class继承"><a href="#6-2-class继承" class="headerlink" title="6.2 class继承"></a>6.2 class继承</h3><ul>
<li>ES6之后出现的新的继承方式；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//constructor就是构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中定义的方法不需要使用function，类中只存在属性和方法</span></span><br><span class="line">    hello()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,grade) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//重写构造方法必须涉及父类原型构造方法中的属性</span></span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    myGrade()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我今年的年级是：&quot;</span>+<span class="built_in">this</span>.grade+<span class="string">&quot;年级&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> xiaohong = <span class="keyword">new</span> XiaoStudent(<span class="string">&quot;xiaohong&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//class继承的本质还是原型继承</span></span><br><span class="line">xiaoming</span><br><span class="line">&gt;Student &#123;<span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line">&gt;name: <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">&gt;__proto__: <span class="built_in">Object</span>		<span class="comment">//原型依然指向于Object</span></span><br><span class="line">xiaoming.hello()</span><br><span class="line">&gt;hello</span><br><span class="line"></span><br><span class="line">xiaohong</span><br><span class="line">&gt;XiaoStudent &#123;<span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span>, <span class="attr">grade</span>: <span class="number">2</span>&#125;</span><br><span class="line">&gt;grade: <span class="number">2</span></span><br><span class="line">&gt;name: <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">&gt;__proto__: Student		<span class="comment">//继承自Student</span></span><br><span class="line">&gt;<span class="keyword">constructor</span>: class XiaoStudent</span><br><span class="line">&gt;myGrade: ƒ myGrade()</span><br><span class="line">&gt;__proto__: Object</span><br><span class="line">xiaohong.myGrade()</span><br><span class="line">&gt;我今年的年级是：2年级</span><br></pre></td></tr></table></figure>



<h3 id="6-3-原型链"><a href="#6-3-原型链" class="headerlink" title="6.3 原型链"></a>6.3 原型链</h3><ul>
<li>原型指向最终直到Object截止，再往后就是Object和Object原型互指；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/023.png" alt="image-20200827214732956"></p>
<hr>
<h2 id="7-操作BOM对象（重点）"><a href="#7-操作BOM对象（重点）" class="headerlink" title="7.操作BOM对象（重点）"></a>7.<code>操作BOM对象（重点）</code></h2><h3 id="7-1-BOM"><a href="#7-1-BOM" class="headerlink" title="7.1 BOM"></a>7.1 BOM</h3><ul>
<li>是浏览器对象模型；</li>
<li>常用浏览器内核：<ul>
<li>IE</li>
<li>Chrome</li>
<li>Safari</li>
<li>FireFox</li>
</ul>
</li>
<li>第三方浏览器：<ul>
<li>QQ浏览器</li>
<li>360浏览器</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="7-2-浏览器常用对象属性方法"><a href="#7-2-浏览器常用对象属性方法" class="headerlink" title="7.2 浏览器常用对象属性方法"></a>7.2 浏览器常用对象属性方法</h3><ul>
<li><p>window：</p>
<ul>
<li>代表浏览器窗口；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="number">1</span>)		<span class="comment">//弹窗</span></span><br><span class="line">&gt;<span class="literal">undefined</span></span><br><span class="line"><span class="built_in">window</span>.innerHeight	<span class="comment">//浏览器内部显示部分大小</span></span><br><span class="line">&gt;<span class="number">582</span></span><br><span class="line"><span class="built_in">window</span>.innerWidth</span><br><span class="line">&gt;<span class="number">150</span></span><br><span class="line"><span class="built_in">window</span>.outerHeight	<span class="comment">//浏览器全部大小</span></span><br><span class="line">&gt;<span class="number">701</span></span><br><span class="line"><span class="built_in">window</span>.outerWidth</span><br><span class="line">&gt;<span class="number">712</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>navigator：</p>
<ul>
<li>封装了浏览器的信息，也可以通过<strong>window.navigator</strong>调用；</li>
<li>大多数时候不使用navigator属性（不建议使用），因为会被认为修改；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.appName</span><br><span class="line">&gt;<span class="string">&quot;Netscape&quot;</span></span><br><span class="line">navigator.appVersion</span><br><span class="line">&gt;<span class="string">&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot;</span></span><br><span class="line">navigator.userAgent</span><br><span class="line">&gt;<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot;</span></span><br><span class="line">navigator.platform</span><br><span class="line">&gt;<span class="string">&quot;Win32&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>screen：</p>
<ul>
<li>代表电脑屏幕尺寸；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">screen.width</span><br><span class="line"><span class="number">1536</span></span><br><span class="line">screen.height</span><br><span class="line"><span class="number">864</span></span><br><span class="line"><span class="comment">//上述屏宽有125%的显示屏放大，设置回100%后即为以下</span></span><br><span class="line">screen.width</span><br><span class="line"><span class="number">1920</span></span><br><span class="line">screen.height</span><br><span class="line"><span class="number">1080</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>location（重点）：</strong></p>
<ul>
<li>代表当前网页的URL信息；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以 https://www.baidu.com 为例</span></span><br><span class="line">location</span><br><span class="line"></span><br><span class="line">&gt;host: <span class="string">&quot;www.baidu.com&quot;</span>			<span class="comment">//网页主机</span></span><br><span class="line">&gt;href: <span class="string">&quot;https://www.baidu.com/&quot;</span>	<span class="comment">//网页链接</span></span><br><span class="line">&gt;protocol: <span class="string">&quot;https:&quot;</span>				<span class="comment">//网络协议</span></span><br><span class="line"></span><br><span class="line">location.reload()				<span class="comment">//重载页面，即刷新页面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//很牛逼的方法</span></span><br><span class="line"><span class="comment">//设置新的地址，访问此网页则自动打开新地址</span></span><br><span class="line">location.assign(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>document：</strong></p>
<ul>
<li>代表当前的页面，HTML、DOM文档树；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.title</span><br><span class="line">&gt;<span class="string">&quot;百度一下，你就知道&quot;</span></span><br><span class="line"><span class="comment">//网页标题，可娱乐修改</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;zhaoxiaoan&#x27;</span></span><br><span class="line">&gt;<span class="string">&quot;zhaoxiaoan&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取具体的文档树节点</strong>：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>JavaSE<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>JavaEE<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> dl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">dl:</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/024.png" alt="image-20200827225540957"></p>
<ul>
<li><strong>获取网页cookie：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以 https://www.baidu.com 为例</span></span><br><span class="line"><span class="built_in">document</span>.cookie</span><br><span class="line">&gt;<span class="string">&quot;BIDUPSID=D82CB30D89EEDA3F955B622F870B5FE0; PSTM=1582882414; BAIDUID=B04A05793CE4AE9F77A02ECD55450F04:FG=1; BD_UPN=12314753; sugstore=0; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; delPer=0; BD_CK_SAM=1; PSINO=6; BD_HOME=1; H_PS_645EC=5d9esAXtgUE7WN%2F8FMHnWe2t10nBl8dCBY4JYI0tWWyKYGKF5r5VvZyY6d4; H_PS_PSSID=32653_32606_1452_32045_32675_32116_32090_32618_32506_22159&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>劫持cookie原理：</strong><ul>
<li>不要访问浏览器报警网页；</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--未知js文件，恶意人员获取你的cookie上传到他自己的服务器--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>history：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.back()		<span class="comment">//网页后退</span></span><br><span class="line">history.forward()	<span class="comment">//网页前进</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h2 id="8-操作DOM节点（重点）"><a href="#8-操作DOM节点（重点）" class="headerlink" title="8.操作DOM节点（重点）"></a>8.<code>操作DOM节点（重点）</code></h2><h3 id="8-1-基本说明"><a href="#8-1-基本说明" class="headerlink" title="8.1 基本说明"></a>8.1 基本说明</h3><ul>
<li>浏览器网页就是一个DOM树形结构；<ul>
<li>更新：更新DOM节点；</li>
<li>遍历：遍历DOM节点，得到DOM节点；</li>
<li>删除：删除一个DOM节点；</li>
<li>添加：添加一个DOM节点；</li>
</ul>
</li>
<li>DOM树形结构：<ul>
<li>每一个标签都是一个DOM节点；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/025.png" alt="image-20200828115725992"></p>
<h3 id="8-2-获得DOM节点"><a href="#8-2-获得DOM节点" class="headerlink" title="8.2 获得DOM节点"></a>8.2 获得DOM节点</h3><ul>
<li>这是原生代码，之后一般都使用JQuery；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题一<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>这是p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>这是p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//对应css选择器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> h1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> p2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;p2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> father = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> childrens = father.children;    <span class="comment">//获取father节点的所有子节点</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// father.children[0] 以数组下标的方式取得子节点</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// father.firstChild;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// father.lastChild;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="8-3-更新DOM节点"><a href="#8-3-更新DOM节点" class="headerlink" title="8.3 更新DOM节点"></a>8.3 更新DOM节点</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> id1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;id1&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作文本：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">id1.innerText = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&gt;<span class="string">&quot;123&quot;</span></span><br><span class="line">id1.innerHTML = <span class="string">&#x27;&lt;p&gt;111111111111111&lt;/p&gt;&#x27;</span></span><br><span class="line">&gt;<span class="string">&quot;&lt;p&gt;111111111111111&lt;/p&gt;&quot;</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>操作CSS：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">id1.style.color = <span class="string">&#x27;yellow&#x27;</span>		<span class="comment">//属性使用，要使用字符串</span></span><br><span class="line">&gt;<span class="string">&quot;yellow&quot;</span></span><br><span class="line">id1.style.fontSize = <span class="string">&#x27;40px&#x27;</span>		<span class="comment">// _ 转 驼峰命名规则</span></span><br><span class="line">&gt;<span class="string">&quot;40px&quot;</span></span><br><span class="line">id1.style.padding = <span class="string">&#x27;40px&#x27;</span></span><br><span class="line">&gt;<span class="string">&quot;40px&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="8-4-删除DOM节点"><a href="#8-4-删除DOM节点" class="headerlink" title="8.4 删除DOM节点"></a>8.4 删除DOM节点</h3><ul>
<li>删除子节点前必须获得父节点，自己不能删除自己；</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题一<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>这是p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>这是p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//删除节点步骤：1.先通过该节点获得父节点；2.再由父节点删除该节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> self = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> parent = self.parentElement;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//删除方式一：</span></span></span><br><span class="line">    parent.removeChild(self);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//删除节点过程中children时刻在变化，是一个动态的过程</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//删除方式二：</span></span></span><br><span class="line"><span class="javascript">    parent.removeChild(parent.children[<span class="number">0</span>]);     <span class="comment">//删除一次之后，后续子节点会自动往前补充</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="8-5-插入DOM节点（重点）"><a href="#8-5-插入DOM节点（重点）" class="headerlink" title="8.5 插入DOM节点（重点）"></a>8.5 <code>插入DOM节点（重点）</code></h3><ul>
<li>前面学过的 innerHTML 属性会覆盖目标DOM下所有的标签；</li>
<li>append：<ul>
<li>通过append甚至可以插入<code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;style&gt;</code>等标签，实现所有HTML、CSS功能；</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;se&quot;</span>&gt;</span>JavaSE<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;ee&quot;</span>&gt;</span>JavaEE<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;me&quot;</span>&gt;</span>JavaME<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//1.将已有的节点追加到目标节点尾端</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">	<span class="comment">//1.1 获得节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//1.2 直接追加到节点末尾</span></span></span><br><span class="line">    list.appendChild(js);</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//2.创建新的节点，并追加到节点末尾</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//2.1创建一个新的节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newP = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);<span class="comment">//创建一个p标签</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//2.2给新创建的节点赋值</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//方式一：</span></span></span><br><span class="line"><span class="javascript">    newP.id = <span class="string">&#x27;newP&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    newP.innerText = <span class="string">&#x27;123&#x27;</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//方式二：（更常用）</span></span></span><br><span class="line"><span class="javascript">    newP.setAttribute(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;newP&#x27;</span>);		<span class="comment">//参数就是键值对格式</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//2.3将新创建的标签追加到目标节点</span></span></span><br><span class="line">    list.appendChild(newP);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//3.添加style标签尝试修改css属性</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> myStyle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    myStyle.setAttribute(<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;text/css&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    myStyle.innerHTML = <span class="string">&#x27;body&#123;background-color: chartreuse&#125;&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(myStyle);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//注意，标签名字后面可以跟数组以确保是该标签</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>insertBefore：<ul>
<li>将新节点插入到目标节点的前面；</li>
<li>要被目标节点包含的节点调用（自身调用无效）；</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ee = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ee&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//要包含的节点.insertBefore(newNode,targetNode)</span></span></span><br><span class="line">    list.insertBefore(js,ee);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="9-操作表单（验证）"><a href="#9-操作表单（验证）" class="headerlink" title="9.操作表单（验证）"></a>9.操作表单（验证）</h2><h3 id="9-1-表单简介"><a href="#9-1-表单简介" class="headerlink" title="9.1 表单简介"></a>9.1 表单简介</h3><ul>
<li>是一个DOM树；</li>
<li>具有如下属性：<ul>
<li>文本框：text</li>
<li>下拉框：<code>&lt;select&gt;</code></li>
<li>单选框：radio</li>
<li>多选框：checkbox</li>
<li>隐藏域：hidden</li>
<li>密码框：password</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="9-2-获得要提交的信息"><a href="#9-2-获得要提交的信息" class="headerlink" title="9.2 获得要提交的信息"></a>9.2 获得要提交的信息</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    单选框的value属性就是其设置好的value值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;man&quot;</span> <span class="attr">id</span>=<span class="string">&quot;boy&quot;</span>&gt;</span> 男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;women&quot;</span> <span class="attr">id</span>=<span class="string">&quot;girl&quot;</span>&gt;</span> 女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> input_text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;username&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> boy_radio = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;boy&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> girl_radio = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;girl&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//得到输入框的值</span></span></span><br><span class="line">    input_text.value;</span><br><span class="line"><span class="javascript">    &gt;<span class="string">&quot;123322553&quot;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//修改输入框的值</span></span></span><br><span class="line"><span class="javascript">    input_text.value = <span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="javascript">	&gt;<span class="string">&quot;123&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//得到单选框是否被选中</span></span></span><br><span class="line">    girl_radio.checked;</span><br><span class="line"><span class="javascript">    &gt;<span class="literal">false</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//修改其是否被选中</span></span></span><br><span class="line"><span class="javascript">    girl_radio.checked = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    &gt;<span class="literal">true</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//单选框和复选框的value值只是设定好的value属性</span></span></span><br><span class="line">    girl_radio.value</span><br><span class="line"><span class="javascript">	&gt;<span class="string">&quot;women&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="9-3-提交表单"><a href="#9-3-提交表单" class="headerlink" title="9.3 提交表单"></a>9.3 提交表单</h3><ul>
<li><p>使用md5算法加密，同时使用隐藏域防止密码框修改：</p>
<ul>
<li><pre><code class="html">&lt;!--md5加密算法引入，可以自己下载到本地，下载地址在引入地址的上级--&gt;
&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt;&lt;/script&gt;
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```html</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        添加name属性才可在提交时被看见--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>密  码：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--隐藏域用来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;md5-password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;f()&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> uname = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;username&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;password&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> md5pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;md5-password&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(md5pwd.value);<span class="comment">//隐藏域的值自己设置，可以为空，此处为空下面没有输出</span></span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="javascript">		md5pwd.value = md5(pwd.value); <span class="comment">//md5算法，直接以密码域值作参，修改原密码</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(md5pwd.value);<span class="comment">//经过md5算法之后可以改密</span></span></span><br><span class="line">        &gt;ae6e334f62fb5d989398deed87568c94</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>name属性的作用：</p>
<ul>
<li>没有name属性则无法看到表单提交的内容；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/026.png" alt="image-20200828175252659"></p>
<ul>
<li>onsubmit：<ul>
<li>onsubmit=”return f()” 固定格式，将函数返回值返回给表单，如果函数返回false，则不会跳转页面不会提交；</li>
<li>注意一下<code>&lt;button&gt;</code>标签中<code>type</code>属性的变化；</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return f()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>密  码：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;md5-password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;f()&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> uname = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;username&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;password&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> md5pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;md5-password&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(md5pwd.value);<span class="comment">//隐藏域的值自己设置，可以为空</span></span></span><br><span class="line">        md5pwd.value = md5(pwd.value);</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(md5pwd.value);<span class="comment">//经过md5算法之后可以改密</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="10-jQuery"><a href="#10-jQuery" class="headerlink" title="10.jQuery"></a>10.jQuery</h2><ul>
<li><p>jQuery是一个库，里面存在大量javaScript函数；</p>
</li>
<li><p>推荐一个jQuery文档工具站：</p>
<ul>
<li><a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a></li>
</ul>
</li>
</ul>
<h3 id="10-1-获取jQuery"><a href="#10-1-获取jQuery" class="headerlink" title="10.1 获取jQuery"></a>10.1 获取jQuery</h3><ul>
<li>下载jQuery文件；</li>
<li>外部cdn引入（具体请参考博客）：<ul>
<li><a href="https://www.cnblogs.com/Leophen/p/11134844.html">https://www.cnblogs.com/Leophen/p/11134844.html</a></li>
</ul>
</li>
</ul>
<h3 id="10-2-初步使用jQuery"><a href="#10-2-初步使用jQuery" class="headerlink" title="10.2 初步使用jQuery"></a>10.2 初步使用jQuery</h3><ul>
<li>两种引入方式，对应两种获取方式：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    1.外部引入在线cdn--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    2.内部导入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery使用：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    jQuery调用公式 $(selector).action()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test-jQuery&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// $ 符号代表jQuery对象，相当于前面所说的window对象，是一种自己创建的对象</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//此处selector选择器就是css中的选择器，有自动提示，后面的click()就是动作，而函数作为匿名参数传入动作内</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#test-jQuery&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="10-3-jQuery选择器"><a href="#10-3-jQuery选择器" class="headerlink" title="10.3 jQuery选择器"></a>10.3 jQuery选择器</h3><ul>
<li><code>jQuery</code>选择器与原生<code>javaScript</code>选择器比较：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生js，选择器少，麻烦不好记</span></span><br><span class="line"><span class="comment">//标签</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName();</span><br><span class="line"><span class="comment">//id</span></span><br><span class="line"><span class="built_in">document</span>.getElementById();</span><br><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery，css中的选择器都能用，多且简便</span></span><br><span class="line"><span class="comment">//标签</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).click();</span><br><span class="line"><span class="comment">//id</span></span><br><span class="line">$(<span class="string">&#x27;#id&#x27;</span>).click();</span><br><span class="line"><span class="comment">//class</span></span><br><span class="line">$(<span class="string">&#x27;.class&#x27;</span>).click();</span><br></pre></td></tr></table></figure>



<h3 id="10-4-jQuery事件"><a href="#10-4-jQuery事件" class="headerlink" title="10.4 jQuery事件"></a>10.4 jQuery事件</h3><ul>
<li><p>事件一般分为（细学自行去看前文文档网站）：</p>
<ul>
<li>鼠标事件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/028.png" alt="image-20200828195411498"></p>
<ul>
<li>键盘事件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/029.png" alt="image-20200828200054125"></p>
<ul>
<li>其它事件</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.事件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;mouseMove&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;divMove&quot;</span>&gt;</span></span><br><span class="line">在这里意动鼠标试试！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//当网页元素加载完毕之后响应事件</span></span></span><br><span class="line">    /*$(document).ready(function (e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)*/</span><br><span class="line"><span class="javascript">    <span class="comment">//上述是原始写法，简写为：</span></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;#divMove&#x27;</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="comment">//e即为得到的鼠标移动信息</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&#x27;#mouseMove&#x27;</span>).text(<span class="string">&#x27;mouse:    x:&#x27;</span>+e.pageX+<span class="string">&#x27;y:&#x27;</span>+e.pageY)</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/027.png" alt="image-20200828194948814"></p>
<h3 id="10-5-jQuery操作DOM"><a href="#10-5-jQuery操作DOM" class="headerlink" title="10.5 jQuery操作DOM"></a>10.5 jQuery操作DOM</h3><ul>
<li>节点文本操作：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[class=js]&#x27;</span>).text();				<span class="comment">//获得值</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul li[class=js]&#x27;</span>).text(<span class="string">&#x27;123456&#x27;</span>);		<span class="comment">//修改值</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;#test-ul&#x27;</span>).html();							<span class="comment">//获取值</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul&#x27;</span>).html(<span class="string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span>);		<span class="comment">//修改值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>css操作：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[class=js]&#x27;</span>).css(&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;red&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>元素的显示和隐藏：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[class=js]&#x27;</span>).show();</span><br><span class="line">$(<span class="string">&#x27;#test-ul li[class=js]&#x27;</span>).hide();</span><br><span class="line">$(<span class="string">&#x27;#test-ul li[class=js]&#x27;</span>).toggle();		<span class="comment">//显示和隐藏相互转换</span></span><br></pre></td></tr></table></figure>

<ul>
<li>娱乐：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).width();</span><br><span class="line">$(<span class="built_in">document</span>).width();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ajax()</code>就是研究事件的； </li>
</ul>
<h3 id="10-6-复习小技巧"><a href="#10-6-复习小技巧" class="headerlink" title="10.6 复习小技巧"></a>10.6 复习小技巧</h3><ul>
<li>巩固js、jQuery：<ul>
<li>看jQuery源码；</li>
<li>看游戏源码（源码之家）；</li>
</ul>
</li>
<li>巩固HTML、CSS：<ul>
<li>扒网站，对应效果删源码直到最简，复制html框架，再下载相应css、js文件；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>注解和反射</title>
    <url>/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>Annotation是从JDK5.0开始引入的新技术；</li>
<li>Annotation的作用：<ul>
<li>可以被其它程序（编译器等）读取；</li>
<li>不是程序本身，可以对程序作出解释（这一点和注释（comment）没什么区别）；</li>
</ul>
</li>
<li>Annotation格式：<ul>
<li>注解是以“@注释名”在代码中存在的，可以添加一些参数值，如：@SuppressWarnings(value=”unchecked”).</li>
</ul>
</li>
<li>Annotation在哪里使用：<ul>
<li>可以附加在package、class、method、filed等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问；</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul>
<li>@Override：定义在java.lang.Override中，此注解只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明；</li>
<li>@Deprecated：定义在java.lang.Deprecated中，此注解可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择；</li>
<li>@SupressWarnings：定义在java.lang.SupressWarnings中，用来抑制编译时的警告信息，此注解需要添加参数才能使用<ul>
<li>@SupressWarnings(“all”)</li>
<li>@SupressWarnings(“unchecked”)</li>
<li>@SupressWarnings(value = {“unchecked”,”deprecation”})</li>
</ul>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>负责解释其它注解，java中定义了四个标准的meta-annotation类型，被用来对其他annotation类型作说明；</li>
<li>这些类型和他们所支持的类在java.lang.annotation包中可以找到.(@Target, @Retention, @Decumented, @Inherited)<ul>
<li>@<strong>Target</strong>：用于描述注解的使用范围；</li>
<li>@<strong>Retention</strong>：表示需要在什么级别保存该注释信息，用于描述注解的生命周期<ul>
<li>（SOURCE &lt; CLASS &lt; <strong>RUNTIME</strong>）</li>
</ul>
</li>
<li>@Decumente：说明该注解被包含在javadoc里面；</li>
<li>@Inherited：说明子类可以继承父类中的该注解；</li>
</ul>
</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul>
<li>使用@interface自定义注解，自动继承java.lang.annotation.Annotation接口；</li>
<li>分析：<ul>
<li>@interface用来声明一个注解，格式：public @interface 注解名 {定义内容}；</li>
<li>其中的每一个方法实际上是声明了一个配置参数；</li>
<li>方法的名称就是参数的名称；</li>
<li>返回值类型就是参数的类型（返回值类型只能是基本类型Class、String、enum）;</li>
<li>可以通过default来声明参数的默认值；</li>
<li>如果只有一个参数成员，一般参数名为value，参数名为value可以省略；</li>
<li>注解元素必须要有值，定义注解元素时通常使用空字符串、0作为默认值；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation2()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation3(&quot; &quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">//注解的参数：参数类型+参数名（）;</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;<span class="comment">//默认值为-1代表不存在</span></span><br><span class="line"></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;清华&quot;</span>,<span class="string">&quot;北大&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation3&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h3><ul>
<li>Reflection是java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法；（连private属性都可以调用使用）；</li>
<li>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射；</li>
</ul>
<p><img src="/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/..%5CImg%5C013.png"></p>
<h4 id="java反射机制提供的功能"><a href="#java反射机制提供的功能" class="headerlink" title="java反射机制提供的功能"></a>java反射机制提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时获取泛型信息；</li>
<li>在运行时调用任意一个对象的成员变量和方法；</li>
<li>在运行时处理注解；</li>
<li>生成动态代理；</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点：可以实现动态创建对象和编译，体现出很大的灵活性；</li>
<li>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</li>
</ul>
<h4 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h4><ul>
<li>java.lang.Class：代表一个类；</li>
<li>java.lang.reflect.Method：代表类的方法；</li>
<li>java.lang.reflect.Filed：代表类的成员变量；</li>
<li>java.lang.reflect.Constructor：代表类的构造器；</li>
</ul>
<h3 id="获取反射对象"><a href="#获取反射对象" class="headerlink" title="获取反射对象"></a>获取反射对象</h3><ul>
<li>public final Class getClass( )方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即:可以通过对象反射求出类的名称。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//什么叫反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获取类的Class对象</span></span><br><span class="line"></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.kun.reflection.User&quot;</span>);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个类在内存中只有一个Class对象，即使通过多个对象实例也只能得到同一个类</span></span><br><span class="line">        <span class="comment">//一个类被加载后，整个类的结构都会被封装在Class对象中</span></span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;com.kun.reflection.User&quot;</span>);</span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.kun.reflection.User&quot;</span>);</span><br><span class="line">        Class c4 = Class.forName(<span class="string">&quot;com.kun.reflection.User&quot;</span>);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.kun.reflection.User</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ul>
<li><p>Class本身也是一个类</p>
</li>
<li><p>Class对象只能由系统建立对象</p>
</li>
<li><p>一个加载的类在JVM中只会有一个Class实例</p>
</li>
<li><p>一个Class对象对应的是一个加载到JVM中的一 个.class文件</p>
</li>
<li><p>每个类的实例都会记得自己是由哪个Class实例所生成</p>
</li>
<li><p>通过Class可以完整地得到一个类中的所有被加载的结构</p>
</li>
<li><p>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</p>
</li>
<li><p>Class类的常用方法：</p>
<ul>
<li><img src="/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/..%5CImg%5C014.png"></li>
</ul>
</li>
</ul>
<h3 id="如何获取Class类的实例"><a href="#如何获取Class类的实例" class="headerlink" title="如何获取Class类的实例"></a>如何获取Class类的实例</h3><ul>
<li><p>已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已知某个类的实例，调用该实例的getClass()方法获取Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = person.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;demo01.student&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置基本数据类型可以直接用 类名.Type</p>
</li>
<li><p>利用ClassLoader</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;这个人是：&quot;</span>+person.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：通过对象获得Class实例</span></span><br><span class="line">        Class c1 = person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line">        <span class="comment">//方式二：通过类名获得Class实例</span></span><br><span class="line">        Class c2 = Student.class;</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        <span class="comment">//方式三：通过包名获得Class实例</span></span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.kun.reflection.Student&quot;</span>);</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        <span class="comment">//方式四：通过内置基本数据类名获得Class实例</span></span><br><span class="line">        Class c4 = Integer.TYPE;</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到class实例对象之后，获得父类类型(类的其它属性)</span></span><br><span class="line">        Class c5 = c1.getSuperclass();</span><br><span class="line">        System.out.println(c5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;老师&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个人是：学生</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">1735600054</span></span><br><span class="line"><span class="comment">class com.kun.reflection.Person</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="哪些类型可有Class对象"><a href="#哪些类型可有Class对象" class="headerlink" title="哪些类型可有Class对象"></a>哪些类型可有Class对象</h3><ul>
<li>class:外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。</li>
<li>interface:接口</li>
<li>[]: 数组.</li>
<li>enum:枚举</li>
<li>annotation:注解@interface</li>
<li>primitive type:基本数据类型</li>
<li>void</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = Object.class;</span><br><span class="line">        Class c2 = Comparable.class;</span><br><span class="line">        Class c3 = String[].class;</span><br><span class="line">        Class c4 = <span class="keyword">int</span>[][].class;</span><br><span class="line">        Class c5 = Override.class;</span><br><span class="line">        Class c6 = ElementType.class;</span><br><span class="line">        Class c7 = Integer.class;</span><br><span class="line">        Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">        Class c9 = Class.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按住alt键选取多行同列数据</span></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要元素类型和维度一样，就是同一个Class</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        System.out.println(a.getClass().hashCode());</span><br><span class="line">        System.out.println(b.getClass().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class java.lang.Object</span></span><br><span class="line"><span class="comment">interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">class [Ljava.lang.String;</span></span><br><span class="line"><span class="comment">class [[I</span></span><br><span class="line"><span class="comment">interface java.lang.Override</span></span><br><span class="line"><span class="comment">class java.lang.annotation.ElementType</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">void</span></span><br><span class="line"><span class="comment">class java.lang.Class</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment">356573597</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="类加载分析"><a href="#类加载分析" class="headerlink" title="类加载分析"></a>类加载分析</h3><ul>
<li><p>加载:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象；</p>
</li>
<li><p>链接:将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
<ul>
<li>验证:确保加载的类信息符合JVM规范，没有安全方面的问题；</li>
<li>准备:正式为类变量(（static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配；</li>
<li>解析∶虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程；</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器是构造类信息的，不是构造该类对象的构造器）。</clinit></clinit></li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(A.m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ctrl+shift+/ ---- /**/</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.加载到内存，会产生一个类对应的Class对象</span></span><br><span class="line"><span class="comment">        2.链接，链接结束后初始化 m = 0</span></span><br><span class="line"><span class="comment">        3.初始化</span></span><br><span class="line"><span class="comment">            &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;A类静态代码块初始化&quot;);</span></span><br><span class="line"><span class="comment">                m = 300;</span></span><br><span class="line"><span class="comment">                m = 100;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            m = 100;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类静态代码块初始化&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类的无参构造初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A类静态代码块初始化</span></span><br><span class="line"><span class="comment">A类的无参构造初始化</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><ul>
<li><p>类的主动引用（一定会发生类的初始化)</p>
<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员(除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
</ul>
<ul>
<li><p>类的被动引用（不会发生类的初始化)</p>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如:当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.主动引用</span></span><br><span class="line">        <span class="comment">//Son son = new Son();</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Main类被加载</span></span><br><span class="line"><span class="comment">        父类被加载</span></span><br><span class="line"><span class="comment">        子类被加载</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射产生主动引用</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;com.kun.reflection.Son&quot;);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Main类被加载</span></span><br><span class="line"><span class="comment">        父类被加载</span></span><br><span class="line"><span class="comment">        子类被加载</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.被动引用（非初始化）</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.b);</span></span><br><span class="line">        <span class="comment">/*Main</span></span><br><span class="line"><span class="comment">        类被加载</span></span><br><span class="line"><span class="comment">        父类被加载</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Son[] array = new Son[5];</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Main类被加载</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Son.M);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Main类被加载</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<p><img src="/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/..%5CImg%5C015.png"></p>
<ul>
<li>类加载器作用是用来把类(class)装载进内存的。JVM规范定义了如下类型的类的加载器：<ul>
<li>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取；</li>
<li>扩展类加载器:负责jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库；</li>
<li>系统类加载器:负责java-classpath或-Djava.class.path所指的目录下的类与jar包装入工作，是最常用的加载器；</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/..%5CImg%5C016.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器的父类加载器--&gt;扩展类加载器</span></span><br><span class="line">        ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试当前类是由哪个类加载的</span></span><br><span class="line">        ClassLoader classLoader = Class.forName(<span class="string">&quot;com.kun.reflection.Demo06&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试JDK内置类是由哪个类加载的</span></span><br><span class="line">        classLoader = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">		sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"><span class="comment">		null</span></span><br><span class="line"><span class="comment">		sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">		null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//双亲委派机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\charsets.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\deploy.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\access-bridge-64.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\cldrdata.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\dnsns.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\jaccess.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\jfxrt.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\localedata.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\nashorn.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunec.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunjce_provider.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunmscapi.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunpkcs11.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\zipfs.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\javaws.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\jce.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\jfr.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\jfxswt.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\jsse.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\management-agent.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\plugin.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\resources.jar;</span></span><br><span class="line"><span class="comment">        C:\Program Files\Java\jdk1.8.0_144\jre\lib\rt.jar;</span></span><br><span class="line"><span class="comment">        C:\Users\Acer\Desktop\JavaStudy\Project\JavaAnnotation\out\production\Annotation;//学习实例部分</span></span><br><span class="line"><span class="comment">        D:\IntelliJ IDEA 2019.3\lib\idea_rt.jar</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h3><ul>
<li>通过反射获取运行时类的完整结构<ul>
<li>Field、Method、Constructor、Superclass、Interface、Annotation</li>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
<li>注解</li>
<li>……</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.kun.reflection.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获得 包名 + 类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获得 类名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">        Field[] fields = c1.getFields(); <span class="comment">//只能找到public属性</span></span><br><span class="line"></span><br><span class="line">        fields = c1.getDeclaredFields(); <span class="comment">//找到所有属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定属性的值</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">        Method[] methods = c1.getMethods(); <span class="comment">//获得本类及其父类所有public方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;public:&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        methods = c1.getDeclaredMethods(); <span class="comment">//获得本类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;all:&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定方法</span></span><br><span class="line">        <span class="comment">//需要传递参数.class,防止重载无法确定方法</span></span><br><span class="line">        Method getName = c1.getMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        Method setName = c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(getName);</span><br><span class="line">        System.out.println(setName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">        Constructor[] constructors = c1.getConstructors(); <span class="comment">//获得所有public构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructors = c1.getDeclaredConstructors(); <span class="comment">//获得所有构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#:&quot;</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定构造器</span></span><br><span class="line">        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor:&quot;</span>+declaredConstructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">com.kun.reflection.User</span></span><br><span class="line"><span class="comment">User</span></span><br><span class="line"><span class="comment">===================================</span></span><br><span class="line"><span class="comment">private java.lang.String com.kun.reflection.User.name</span></span><br><span class="line"><span class="comment">private int com.kun.reflection.User.id</span></span><br><span class="line"><span class="comment">private int com.kun.reflection.User.age</span></span><br><span class="line"><span class="comment">private java.lang.String com.kun.reflection.User.name</span></span><br><span class="line"><span class="comment">===================================</span></span><br><span class="line"><span class="comment">public:public java.lang.String com.kun.reflection.User.toString()</span></span><br><span class="line"><span class="comment">public:public java.lang.String com.kun.reflection.User.getName()</span></span><br><span class="line"><span class="comment">public:public int com.kun.reflection.User.getId()</span></span><br><span class="line"><span class="comment">public:public void com.kun.reflection.User.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">public:public void com.kun.reflection.User.setAge(int)</span></span><br><span class="line"><span class="comment">public:public int com.kun.reflection.User.getAge()</span></span><br><span class="line"><span class="comment">public:public void com.kun.reflection.User.setId(int)</span></span><br><span class="line"><span class="comment">public:public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public:public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public:public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public:public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public:public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public:public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public:public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public:public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">all:public java.lang.String com.kun.reflection.User.toString()</span></span><br><span class="line"><span class="comment">all:public java.lang.String com.kun.reflection.User.getName()</span></span><br><span class="line"><span class="comment">all:public int com.kun.reflection.User.getId()</span></span><br><span class="line"><span class="comment">all:public void com.kun.reflection.User.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">all:public void com.kun.reflection.User.setAge(int)</span></span><br><span class="line"><span class="comment">all:public int com.kun.reflection.User.getAge()</span></span><br><span class="line"><span class="comment">all:public void com.kun.reflection.User.setId(int)</span></span><br><span class="line"><span class="comment">public java.lang.String com.kun.reflection.User.getName()</span></span><br><span class="line"><span class="comment">public void com.kun.reflection.User.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">===================================</span></span><br><span class="line"><span class="comment">public com.kun.reflection.User()</span></span><br><span class="line"><span class="comment">public com.kun.reflection.User(java.lang.String,int,int)</span></span><br><span class="line"><span class="comment">#:public com.kun.reflection.User()</span></span><br><span class="line"><span class="comment">#:public com.kun.reflection.User(java.lang.String,int,int)</span></span><br><span class="line"><span class="comment">Constructor:public com.kun.reflection.User(java.lang.String,int,int)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h3><ul>
<li><p>创建类的对象∶</p>
<ul>
<li><p>调用Class对象的newInstance()方法</p>
<ul>
<li>类必须有一个无参数的构造器；</li>
<li>类的构造器的访问权限需要足够；</li>
</ul>
</li>
<li><p>通过有参构造器创建对象</p>
<ul>
<li>通过Class类的getDeclaredConstructor(Class …parameterTypes)取得本类的指定形参类型的构造器；</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数；</li>
<li>通过Constructor实例化对象；</li>
</ul>
</li>
</ul>
</li>
<li><p>调用指定的方法</p>
<ul>
<li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型；</li>
<li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息；</li>
</ul>
<p><img src="/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/..%5CImg%5C017.png"></p>
<ul>
<li>object invoke(Object obj,Object … args)<ul>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li>
<li>若原方法若为静态方法，此时形参Object obj可为null；</li>
<li>若原方法形参列表为空，则Object[] args为null；</li>
<li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的；</li>
<li>setAccessible(true)方法，将可访问private的方法；</li>
</ul>
</li>
</ul>
</li>
<li><p>setAccessible</p>
<ul>
<li><p>Method和Field、Constructor对象都有setAccessible()方法；</p>
</li>
<li><p>setAccessible作用是启动和禁用访问安全检查的开关；</p>
</li>
<li><p>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查；</p>
<ul>
<li><p>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true；</p>
</li>
<li><p>使得原本无法访问的私有成员也可以访问；</p>
</li>
</ul>
</li>
<li><p>参数值为false则指示反射的对象应该实施Java语言访问检查；</p>
</li>
<li><p>关闭安全检测才能调用private权限；</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射动态创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//获得class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.kun.reflection.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="comment">//1.1) 默认构造对象，实质是通过无参构造器构造对象,使用此方式原类不能没有无参构造器</span></span><br><span class="line">        User user = (User)c1.newInstance();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2) 通过构造器创建对象</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        User user2 = (User)constructor.newInstance(<span class="string">&quot;朝小闇&quot;</span>, <span class="number">001</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用方法并且初始化</span></span><br><span class="line">        <span class="comment">//2.1 通过反射调用普通方法</span></span><br><span class="line">        User user3 = (User)c1.newInstance();</span><br><span class="line">        <span class="comment">//2.2 通过反射获取一个方法</span></span><br><span class="line">        Method setName = c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.3 invoke 激活函数 (对象，“方法传入值”)</span></span><br><span class="line">        setName.invoke(user3,<span class="string">&quot;朝小闇&quot;</span>);</span><br><span class="line">        System.out.println(user3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.初始化属性</span></span><br><span class="line">        <span class="comment">//3.1 通过反射操作属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================================&quot;</span>);</span><br><span class="line">        User user4 = (User)c1.newInstance();</span><br><span class="line">        <span class="comment">//3.2 通过反射获取一个属性</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.3 确定取消安全监测才可以调用private权限的属性或方法 setAccessible(true)</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(user4,<span class="string">&quot;朝闇&quot;</span>);</span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User&#123;name=&#x27;null&#x27;, id=0, age=0&#125;</span></span><br><span class="line"><span class="comment">User&#123;name=&#x27;朝小闇&#x27;, id=1, age=20&#125;</span></span><br><span class="line"><span class="comment">朝小闇</span></span><br><span class="line"><span class="comment">=====================================</span></span><br><span class="line"><span class="comment">朝闇</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<ul>
<li>性能比对监测：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;普通方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭安全检测方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);<span class="comment">//只添加此语句</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;关闭安全检测方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">普通方式执行10亿次：4ms</span></span><br><span class="line"><span class="comment">反射方式执行10亿次：2774ms</span></span><br><span class="line"><span class="comment">关闭安全检测方式执行10亿次：1217ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>得出结论，使用反射方式执行方法时，最好关闭安全监测，性能可以得到很大提升</p>
</blockquote>
<h3 id="获取泛型信息"><a href="#获取泛型信息" class="headerlink" title="获取泛型信息"></a>获取泛型信息</h3><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除；</li>
<li>为了通过反射操作这些类型，Java新增了ParameterizedType , GenericArrayType ，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型；</li>
</ul>
<ul>
<li>ParameterizedType：表示一种参数化类型,比如Collection<String>；</String></li>
<li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型；</li>
<li>TypeVariable：是各种类型变量的公共父接口；</li>
<li>WildcardType：代表一种通配符类型表达式；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,User&gt; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Method method = Demo10.class.getMethod(&quot;test01&quot;, Map.class, List.class);</span><br><span class="line">        <span class="comment">//getGenericParameterTypes()获取参数型泛型</span></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span>+genericParameterType);</span><br><span class="line">            <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;<span class="comment">//判断genericParameterType是否是一种参数化类型</span></span><br><span class="line">                <span class="comment">//getActualTypeArguments()获取真实参数信息</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;$&quot;</span>+actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        method = Demo10.class.getMethod(&quot;test02&quot;, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//getGenericReturnType()获取返回值泛型</span></span><br><span class="line">        Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#java.util.Map&lt;java.lang.String, com.kun.reflection.User&gt;</span></span><br><span class="line"><span class="comment">$class java.lang.String</span></span><br><span class="line"><span class="comment">$class com.kun.reflection.User</span></span><br><span class="line"><span class="comment">#java.util.List&lt;com.kun.reflection.User&gt;</span></span><br><span class="line"><span class="comment">$class com.kun.reflection.User</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class com.kun.reflection.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.kun.reflection.Student02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得注解的value的值</span></span><br><span class="line">        TableAn tableAn = (TableAn)c1.getAnnotation(TableAn.class);</span><br><span class="line">        String value = tableAn.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得属性指定注解</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        FieLdAn annotation = name.getAnnotation(FieLdAn.class);</span><br><span class="line">        System.out.println(annotation.columbName());</span><br><span class="line">        System.out.println(annotation.length());</span><br><span class="line">        System.out.println(annotation.type());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableAn(&quot;db_student&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student02</span></span>&#123;</span><br><span class="line">    <span class="meta">@FieLdAn(columbName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@FieLdAn(columbName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@FieLdAn(columbName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 4)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student02</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student02&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类名注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableAn&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieLdAn&#123;</span><br><span class="line">    <span class="function">String <span class="title">columbName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@com.kun.reflection.TableAn(value=db_student)</span></span><br><span class="line"><span class="comment">db_student</span></span><br><span class="line"><span class="comment">db_name</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">varchar</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.bilibili.com/read/cv5702420">狂神说java b站视频链接</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解和反射</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下方法学习笔记（二）应用层</title>
    <url>/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0.%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h2><ul>
<li>研发网络应用程序的<strong>核心</strong>是写出能够运行在不同端系统和通过网络彼此通信的程序：<ul>
<li>Web应用程序中，有两个互相通信的不同的程序：运行在用户主机上的浏览器程序和运行在Web服务器主机上的Web服务器程序；</li>
<li>P2P文件共享系统，在参与文件共享的社区中的每台主机中都有一个程序；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/011.png" alt="image-20201013081228922"></p>
<h3 id="1-1-网络应用程序体系结构"><a href="#1-1-网络应用程序体系结构" class="headerlink" title="1.1 网络应用程序体系结构"></a>1.1 网络应用程序体系结构</h3><blockquote>
<p>应用程序体系结构由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序</p>
</blockquote>
<a id="more"></a>



<h4 id="1-11-客户-服务器体系结构"><a href="#1-11-客户-服务器体系结构" class="headerlink" title="1.11 客户-服务器体系结构"></a>1.11 客户-服务器体系结构</h4><ul>
<li>服务器：一个总是打开的主机，服务于来自客户（一般不止一个）的主机请求：<ul>
<li>由于一台单独的服务器主机无法处理所有的客户请求，因此常通过连接多台甚至数十万台主机主机服务器而形成的数据中心作为服务器集群来处理客户请求；</li>
<li>如Web服务器服务于来自浏览器（运行在客户主机上）的请求，当Web服务器接收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应；</li>
</ul>
</li>
<li>在该体系结构中，客户之间不能直接通信，客户只能与服务器直接通信；</li>
<li>服务器具有固定的、周知的IP地址，客户就可以通过该服务器的IP地址向其发送分组进而与其联系（因此服务器必须总是打开）；</li>
<li>应用程序：<ul>
<li>Web；</li>
<li>电子邮件；</li>
<li>Telnet；</li>
<li>FTP（文件传输协议，由FTP服务器和FTP客户端组成）；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/012.png" alt="image-20201013082809331"></p>
<h4 id="1-12-对等（P2P）体系结构"><a href="#1-12-对等（P2P）体系结构" class="headerlink" title="1.12 对等（P2P）体系结构"></a>1.12 对等（P2P）体系结构</h4><ul>
<li>该体系结构中对于数据中心的专用服务器依赖性很小，客户可以直接和客户通信而没有必要经过服务器的第三方进行间接通信；</li>
<li>对等方：应用程序在<strong>间断</strong>连接的主机对之间使用直接通信，这些主机被称为<strong>对等方</strong>，这些对等方并不为服务提供商所有；</li>
<li>应用程序（流量密集型应用）：<ul>
<li>文件共享（BitTorrent）；</li>
<li>对等方协助下载加速器（迅雷，[百度网盘有中间服务器]）；</li>
<li>因特网电话和视频会议（Skype）；</li>
</ul>
</li>
<li>P2P应用于高度非集中式结构，面临安全性、性能、和可靠性等挑战，但它也不需要庞大的服务器基础设施和服务器带宽，成本相对较低；</li>
<li>P2P<strong>自扩展性</strong>高，例如：在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作负载，但每个对等方通过向其它对等方分发文件，也为系统增加了服务功能；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/013.png" alt="image-20201013084536055"></p>
<blockquote>
<p>某些应用具有混合的体系结构，结合了客户-服务器和P2P的元素，例如：对于许多即时讯息应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送</p>
</blockquote>
<h3 id="1-2-进程通信"><a href="#1-2-进程通信" class="headerlink" title="1.2 进程通信"></a>1.2 进程通信</h3><blockquote>
<p>运行在多个端系统中的程序是如何进行通信的呢？进行通信的实际上是进程而不是程序。同一台计算机主机上的多个进程通过操作系统制定的通信规则在进程间相互通信，而不同端系统上的两个进程，则需要通过跨越计算机网络交换报文而相互通信</p>
</blockquote>
<h4 id="1-21-客户和服务器进程"><a href="#1-21-客户和服务器进程" class="headerlink" title="1.21 客户和服务器进程"></a>1.21 客户和服务器进程</h4><ul>
<li><p>客户：在一对进程通信会话场景中，发起通信的进程被标识为<strong>客户</strong>；</p>
</li>
<li><p>服务器：在一对进程通信会话场景中，在会话开始时等待联系的进程被标识为<strong>服务器</strong>；</p>
</li>
<li><p>而在P2P中，一个进程既能下载文件又能上传文件，即每一个对等方既是客户又是服务器，但是在单次通信会话过程中，服务器和客户都是唯一的；</p>
</li>
</ul>
<h4 id="1-22-进程与计算机网络之间的接口"><a href="#1-22-进程与计算机网络之间的接口" class="headerlink" title="1.22 进程与计算机网络之间的接口"></a>1.22 进程与计算机网络之间的接口</h4><blockquote>
<p>发送端的应用程序将报文推进套接字，运输层协议负责从接收进程的套接字中获取该报文</p>
</blockquote>
<ul>
<li><p>套接字：</p>
<ul>
<li>进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送报文和接收报文；</li>
<li>套接字是同一台主机内应用层和运输层之间的接口；</li>
<li>套接字是建立网络应用程序的可编程接口，也被称为应用程序和网络之间的应用程序编程接口（API）；</li>
<li>应用程序开发者可以控制套接字在应用层的一切，而对运输层的控制仅限于：<ul>
<li>选择运输层协议；</li>
<li>也许能设定几个运输层参数，如最大缓存和最大报文段长度；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/014.png" alt="image-20201013091501105"></p>
</li>
</ul>
<h4 id="1-23-进程寻址"><a href="#1-23-进程寻址" class="headerlink" title="1.23 进程寻址"></a>1.23 进程寻址</h4><ul>
<li>为了标识接收进程，需要定义两种信息：<ul>
<li>主机的地址：<ul>
<li>由IP地址标识；</li>
</ul>
</li>
<li>在目的主机中指定接收进程的标识符：<ul>
<li>由目的地<strong>端口号</strong>标识；</li>
<li>流行的应用已经分配好了固定的端口号；</li>
<li>例如：Web服务器端口号为80，邮件服务器进程（使用SMTP协议）用端口号25来标识；</li>
<li>标准端口号在该网址查看：<a href="http://www.iana.org/">http://www.iana.org</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-运输层协议提供的运输服务"><a href="#1-3-运输层协议提供的运输服务" class="headerlink" title="1.3 运输层协议提供的运输服务"></a>1.3 运输层协议提供的运输服务</h3><blockquote>
<p>运输层协议能够为调用它的程序提供四类通用运输服务：可靠数据传输、吞吐量、定时和安全性</p>
</blockquote>
<h4 id="1-31-可靠数据传输"><a href="#1-31-可靠数据传输" class="headerlink" title="1.31 可靠数据传输"></a>1.31 可靠数据传输</h4><ul>
<li>确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端的服务；</li>
<li>电子邮件、文件传输、远程主机访问、金融应用等应用需要可靠数据传输，而另一些应用如多媒体应用则容忍丢失部分数据；</li>
</ul>
<h4 id="1-32-吞吐量"><a href="#1-32-吞吐量" class="headerlink" title="1.32 吞吐量"></a>1.32 吞吐量</h4><ul>
<li>可用吞吐量就是发送进程能够向接收进程交付比特的速率，由于带宽共享，可用吞吐量将随时间产生波动；</li>
<li>运输层协议能够以某种特定的速率提供确保的可用吞吐量的服务：<ul>
<li>应用程序请求 r 比特/秒的吞吐量，则该运输层协议能够确保可用吞吐量总是为至少 r 比特/秒；</li>
</ul>
</li>
<li>具有吞吐量要求的应用被称为<strong>带宽敏感的应用</strong>，许多多媒体应用是带宽敏感的；</li>
</ul>
<h4 id="1-33-定时"><a href="#1-33-定时" class="headerlink" title="1.33 定时"></a>1.33 定时</h4><ul>
<li>运输层协议提供定时保证服务，比特传输具有最低时延；</li>
</ul>
<h4 id="1-34-安全性"><a href="#1-34-安全性" class="headerlink" title="1.34 安全性"></a>1.34 安全性</h4><ul>
<li>运输层协议为应用程序提供安全性服务，如加密解密数据、数据完整性和端点鉴别；</li>
</ul>
<h3 id="1-4-因特网提供的运输服务"><a href="#1-4-因特网提供的运输服务" class="headerlink" title="1.4 因特网提供的运输服务"></a>1.4 因特网提供的运输服务</h3><blockquote>
<p>具体考察由因特网提供的运输服务类型</p>
</blockquote>
<ul>
<li>因特网（TCP/IP网络）为应用程序提供两个运输层协议：TCP、UDP；</li>
</ul>
<h4 id="1-41-TCP服务"><a href="#1-41-TCP服务" class="headerlink" title="1.41 TCP服务"></a>1.41 TCP服务</h4><ul>
<li><p>TCP服务模型包括<strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong>；</p>
</li>
<li><p>面向连接服务：</p>
<ul>
<li>在应用层数据报文开始流动之前，TCP让客户和服务器交换运输层控制信息，该<strong>握手阶段</strong>提醒客户和服务器，大量分组即将到来；</li>
<li>握手阶段后，两个进程的套接字之间建立了一个<strong>TCP连接</strong>，这条连接时<strong>全双工</strong>的，连接双方的进程可以在此连接上同时进行报文收发；</li>
<li>应用程序结束报文发送后，必须拆除该连接；</li>
</ul>
</li>
<li><p>可靠数据传输服务：</p>
<ul>
<li>通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据；</li>
</ul>
</li>
<li><p>TCP还具有拥塞控制机制：</p>
<ul>
<li>能为因特网带来整体好处，而不一定给通信进程带来直接好处；</li>
<li>当发送方和接收方之间的网络出现拥塞现象时，TCP的拥塞控制机制会抑制发送进程；</li>
<li>TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的；</li>
</ul>
</li>
<li><p>TCP的加强版本SSL在应用层提供了安全性服务；</p>
</li>
</ul>
<h4 id="1-42-UDP服务"><a href="#1-42-UDP服务" class="headerlink" title="1.42 UDP服务"></a>1.42 UDP服务</h4><ul>
<li>UDP是一种不提供不必要服务的轻量级运输协议，仅提供最小服务；</li>
<li>UDP无连接、不可靠、且没有拥塞机制；</li>
</ul>
<h4 id="1-43-因特网运输协议不提供的服务"><a href="#1-43-因特网运输协议不提供的服务" class="headerlink" title="1.43 因特网运输协议不提供的服务"></a>1.43 因特网运输协议不提供的服务</h4><ul>
<li>因特网TCP协议和UDP协议都不提供定时或带宽保证，但当下的因特网能够为时间敏感应用提供满意的服务；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/015.png" alt="image-20201013144113724"></p>
<h3 id="1-5-应用层协议"><a href="#1-5-应用层协议" class="headerlink" title="1.5 应用层协议"></a>1.5 应用层协议</h3><blockquote>
<p>应用层协议定义了运行在不同端系统上的应用程序如何相互传递报文</p>
</blockquote>
<ul>
<li>定义：<ul>
<li>交换的报文类型，例如请求报文和响应报文；</li>
<li>各种报文类型的语法，如报文中的各个字段和这些字段是如何描述的；</li>
<li>字段的语义，即这些字段中的信息的含义；</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则；</li>
</ul>
</li>
<li>有些应用层协议是由RFC文档定义的，位于公共域中，例如HTTP协议就作为一个RFC可供使用：<ul>
<li>如果浏览器开发者遵从HTTP RFC规则，则该浏览器就能访问任何遵从该文档标准的Web服务器并获取相应的Web页面；</li>
</ul>
</li>
<li>网络应用组成：<ul>
<li>Web应用：<ul>
<li>文档格式标准（HTML）;</li>
<li>Web浏览器（Chrome等）；</li>
<li>Web服务器（Apache、Microsoft等）；</li>
<li>Web应用层协议（HTTP）；</li>
</ul>
</li>
<li>电子邮件应用：<ul>
<li>邮件服务器；</li>
<li>邮件客户程序；</li>
<li>定义电子邮件报文结构的标准；</li>
<li>邮件应用层协议（不止一个，主要是SMTP）；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Web和HTTP"><a href="#2-Web和HTTP" class="headerlink" title="2.Web和HTTP"></a>2.Web和HTTP</h2><h3 id="2-1-HTTP概况"><a href="#2-1-HTTP概况" class="headerlink" title="2.1 HTTP概况"></a>2.1 HTTP概况</h3><ul>
<li><p>HTTP全称为超文本传输协议，是Web的唯一应用层协议，也是Web的核心所在；</p>
</li>
<li><p>HTTP由两个程序实现：</p>
<ul>
<li>客户程序；</li>
<li>服务器程序；</li>
</ul>
</li>
<li><p>Web页面由<strong>对象</strong>组成，一个对象只是一个文件，例如一个HTML文件、一个JPEG图形、一个JAVA小程序等，其中除HTML基本文件外，其余对象都是<strong>引用对象</strong>，通过URL地址寻址的方式引用显示其它对象；</p>
</li>
<li><p>URL地址组成（以 <a href="http://jwglnew.hunnu.edu.cn/eams/home.action">http://jwglnew.hunnu.edu.cn/eams/home.action</a> 为例）：</p>
<ul>
<li>存放对象的服务器主机名，即 <a href="http://jwglnew.hunnu.edu.cn/">http://jwglnew.hunnu.edu.cn</a> ；</li>
<li>对象的路径名，即 /eams/home.action ；</li>
</ul>
</li>
<li><p>HTTP使用TCP作为它的支撑运输协议；</p>
</li>
<li><p>HTTP协议不担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节，这也是分层体系结构最大的优点；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/016.png" alt="image-20201013151721096"></p>
<ul>
<li>HTTP协议是一个无状态协议，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息；</li>
</ul>
<h3 id="2-2-非持续连接和持续连接"><a href="#2-2-非持续连接和持续连接" class="headerlink" title="2.2 非持续连接和持续连接"></a>2.2 非持续连接和持续连接</h3><ul>
<li><p>非持续连接：每个请求/响应对是经一个单独的TCP连接发送的；</p>
</li>
<li><p>持续连接：所有的请求/响应经过相同的一次TCP连接发送；</p>
</li>
<li><p>HTTP默认使用TCP持续连接，一段时间间隔未使用则自动关闭该TCP连接，该方式下，大部分浏览器打开5~10个并行的TCP连接，而每条连接处理一个请求响应事务，使用并行连接可以缩短响应时间；</p>
</li>
<li><p>往返时间（RTT）：一个短分组经客户-服务器-客户所花费的时间，包括分组传播时延、排队时延、分组处理时延；</p>
</li>
<li><p>请求并接收响应对象过程：</p>
<ul>
<li>客户想服务器发送一个小TCP报文段；</li>
<li>服务器用一个小TCP报文段做出确认和响应；</li>
<li>客户向服务器返回确认；</li>
<li>服务器在该TCP连接上发送HTML文件（响应对象）；</li>
<li>所以总响应时间就是两个RTT加上服务器传输HTML文件的时间；</li>
<li>非持续连接每次重新连接TCP需要多花费前面一次握手RTT时间；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/017.png" alt="image-20201013154326894"></p>
<h3 id="2-3-HTTP报文格式"><a href="#2-3-HTTP报文格式" class="headerlink" title="2.3 HTTP报文格式"></a>2.3 HTTP报文格式</h3><h4 id="2-31-HTTP请求报文"><a href="#2-31-HTTP请求报文" class="headerlink" title="2.31 HTTP请求报文"></a>2.31 HTTP请求报文</h4><ul>
<li>如图所示：<ul>
<li>每一行结尾都以“/r/n”回车和换行符结束，图中未标明，但实际操作中有显示；</li>
<li>请求行：请求报文的第一行，有三个字段：<ul>
<li>方法字段：取值包括GET、POST、HEAD、PUT、DELETE，一般为GET，功能为请求获取；</li>
<li>URL字段：请求对象的路径；</li>
<li>HTTP版本字段：浏览器实现的HTTP版本；</li>
</ul>
</li>
<li>首部行：请求报文的后续行，图例内容：<ul>
<li>Host：主机名；</li>
<li>Connection：是否持续连接，close的含义是要求服务器发送完请求之后就关闭连接；</li>
<li>User-agent：指名用户代理，即向服务器发送请求的浏览器的类型，此处浏览器类型为Mozilla/5.0，即Firefox浏览器；</li>
<li>Accept-language：用户想要接收的语言格式；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/018.png" alt="image-20201013155636786"></p>
<ul>
<li><p>请求报文的通用格式：</p>
<ul>
<li>实体体：使用GET方法时为空，使用POST方法时才使用，POST方法常在表单中使用，此时实体体中包含的就是用户在表单字段中的输入值；</li>
<li>表单使用GET方法时，假设两个字段填写值为“monkeys”和“bananas”，则提交时URL结构为：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/020.png" alt="image-20201013161223787"></p>
<ul>
<li><p>HEAD方法类似于GET方法，但响应报文并不返回请求结果，开发者用HEAD方法调试跟踪；</p>
</li>
<li><p>PUT方法常与Web发型工具联合使用，允许用户上传对象到指定的Web服务器上指定的路径；</p>
</li>
<li><p>DELETE方法允许用户或者应用程序删除Web服务器上的对象；</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/019.png" alt="image-20201013160733337"></p>
<h4 id="2-32-HTTP响应报文"><a href="#2-32-HTTP响应报文" class="headerlink" title="2.32 HTTP响应报文"></a>2.32 HTTP响应报文</h4><ul>
<li>如图所示：<ul>
<li>状态行：响应报文的第一行，有三个部分：<ul>
<li>协议版本字段：HTTP/1.1说明服务器使用的HTTP1.1版本；</li>
<li>状态码：200；</li>
<li>相应状态信息：OK；</li>
</ul>
</li>
<li>首部行：<ul>
<li>Connection：close，发送完报文即关闭TCP连接；</li>
<li>Date：服务器从文件系统中检索到该对象，将该对象插入到响应报文，并发送到响应报文的时间；</li>
<li>Server：对应于User-agent，Apache/2.2.3表示该报文由ApacheWeb服务器产生；</li>
<li>Last-Modified：对象创建或者最后一次修改时间；</li>
<li>Content-Length：被发送对象的字节数；</li>
<li>Content-Type：指示实体体中的对象格式是HTML文本；</li>
</ul>
</li>
<li>实体体：响应对象数据内容；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/021.png" alt="image-20201013161655775"></p>
<ul>
<li><p>响应报文的通用格式：</p>
<ul>
<li>状态码：<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/023.png" alt="image-20201013163522205"></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/022.png" alt="image-20201013163435628"></p>
<h3 id="2-4-cookie"><a href="#2-4-cookie" class="headerlink" title="2.4 cookie"></a>2.4 cookie</h3><ul>
<li>弥补HTTP无状态的缺点，允许站点对用户进行跟踪，即cookie可以标识一个用户；</li>
<li>cookie技术有四个组件：<ul>
<li>在HTTP响应报文中有一个cookie首部行；</li>
<li>在HTTP请求报文中有一个cookie首部行；</li>
<li>在用户端系统中有一个cookie文件，由用户的浏览器进行管理；</li>
<li>位于Web站点的一个后端数据库；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/024.png" alt="image-20201013164240271"></p>
<h3 id="2-5-Web缓存"><a href="#2-5-Web缓存" class="headerlink" title="2.5 Web缓存"></a>2.5 Web缓存</h3><ul>
<li>Web缓存器也叫做代理服务器，能够代表初始Web服务器来满足HTTP请求的网络实体，它具有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本；</li>
<li>Web缓存器既是服务器又是客户，它可以接收浏览器的请求并发送响应，也可以向初始服务器发送请求；</li>
<li>Web缓存器通常由ISP购买并安装，例如，一所大学可能在它的校园网上安装一台缓存器，并且将所有校园网上的用户浏览器配置为指向它；</li>
<li>部署Web缓存器有两个原因：<ul>
<li>Web缓存器可以大量减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时；</li>
<li>Web缓存器能够大量减少一个机构的接入链路到因特网的通信量，减少通信量就可以不急于增加带宽，降低费用；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/025.png" alt="image-20201013165414229"></p>
<ul>
<li>举例：假设对象的平均长度为1Mb，从机构内的浏览器对这些初始服务器的平均访问速率为每秒15个请求，且HTTP请求报文足够小而不会在网络中即接入链路产生通信量（无排队等时延），且从接入链路一侧转发HTTP请求报文到接收响应的平均因特网时延为2s：<ul>
<li>总响应时间 = 局域网时延 + 接入时延 + 因特网时延；</li>
<li>局域网流量强度：<ul>
<li>（15个请求/s）×（1Mb/请求）/（100Mbps）= 0.15；</li>
<li>0.15的通信量时延一般为几十毫秒，可以忽略；</li>
</ul>
</li>
<li>接入链路流量强度：<ul>
<li>（15个请求/s）×（1Mb/请求）/（15Mbps）= 1；</li>
<li>1的通信量时延非常大且会无限增长；</li>
</ul>
</li>
<li>解决方法：<ul>
<li>将接入链路速率由15Mbps升级到100Mbps，代价很高；</li>
<li>在机构网络中安装一个Web缓存器：<ul>
<li>一个缓存器所满足的请求的比率通常在0.2~0.7之间，假设平均命中率为0.4；</li>
<li>客户和缓存连接在同一个高速局域网上，这样40%的请求几乎立即完成响应，时延约在10ms以内；</li>
<li>剩下的60%请求由初始服务器来完成响应，而且流量强度从1减少为0.6，时延较小，可忽略；</li>
<li>一般而言，在15Mbps链路中，流量强度小于0.8时，时延较小，一般为几十毫秒；</li>
<li>此时平均时延为：0.4 ×（0.010秒）+ 0.6 ×（2.01秒）= 1.2秒</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/026.png" alt="image-20201013170942842"></p>
<h3 id="2-6-条件GET方法"><a href="#2-6-条件GET方法" class="headerlink" title="2.6 条件GET方法"></a>2.6 条件GET方法</h3><ul>
<li>上述Web缓存中存在问题：存放在缓存器中的对象副本可能是陈旧的，而条件GET方法则是用来解决这个问题的；</li>
<li>条件GET方法：<ul>
<li>请求报文使用GET方法；</li>
<li>请求报文中包含一个“If-Modified-Since：”首部行</li>
</ul>
</li>
<li>过程：<ul>
<li>代理缓存器代表一个请求浏览器向Web服务器发送一个请求报文；</li>
<li>Web服务器向缓存器发送具有被请求对象的响应报文；</li>
<li>一段时间后用户再次访问，但对象可能已经改变，缓存器通过发送一个条件GET执行最新检查，其中If-Modified-Since：首部行的值正好等于上一次发送过来的Last-Modified：首部行的值；</li>
<li>如果两个时间相同，没有修改时，Web服务器向该缓存器发送一个响应报文回来，但并不发送所请求的对象，并且状态行为304 Not Modified；</li>
</ul>
</li>
</ul>
<h2 id="3-因特网中的电子邮件"><a href="#3-因特网中的电子邮件" class="headerlink" title="3.因特网中的电子邮件"></a>3.因特网中的电子邮件</h2><ul>
<li>组成部分：<ul>
<li>用户代理：<ul>
<li>允许用户阅读、回复、转发、保存和撰写报文；</li>
</ul>
</li>
<li>邮件服务器：<ul>
<li>形成电子邮件体系结构的核心；</li>
</ul>
</li>
<li>简单邮件传输协议（SMTP）；</li>
</ul>
</li>
<li>一个典型的邮件发送过程：<ul>
<li>从发送方的用户代理开始，传输到发送方的邮件服务器；</li>
<li>再传输到接收方的邮件服务器；</li>
<li>在接收方的邮件服务器被分发到接收方的邮箱中；</li>
</ul>
</li>
</ul>
<h3 id="3-1-SMTP"><a href="#3-1-SMTP" class="headerlink" title="3.1 SMTP"></a>3.1 SMTP</h3><ul>
<li><p>是因特网电子邮件中主要的应用层协议，也是因特网电子邮件的核心，使用TCP可靠数据传输服务；</p>
</li>
<li><p>每台邮件服务器上既运行SMTP客户端，也运行SMTP服务器端，SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器；</p>
</li>
<li><p>缺陷：</p>
<ul>
<li>限制所有邮件报文的体部分只能采用简单的7比特ASCII码表示，在用SMTP传送邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应的ASCII码邮件解码还原为多媒体数据，而使用HTTP传送前不需要编码为ASCII码；</li>
</ul>
</li>
<li><p>SMTP一般不使用中间邮件服务器发送邮件，而是通过TCP直接连接，如果接收方邮件服务器没有开机，则该报文邮件会保存在发送方邮件客户端并等待进行新的连接请求尝试；</p>
</li>
<li><p>使用Telnet与一个SMTP服务器进行一次直接对话，使用命令：</p>
</li>
<li><pre><code class="bash">telnet SeverName 25
//25 是端口号</code></pre>
</li>
</ul>
<h3 id="3-2-与HTTP的对比"><a href="#3-2-与HTTP的对比" class="headerlink" title="3.2 与HTTP的对比"></a>3.2 与HTTP的对比</h3><ul>
<li>HTTP：<ul>
<li>从Web服务器向Web客户（通常是一个浏览器）传送文件；</li>
<li>主要是一个<strong>拉协议</strong>，在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息；</li>
<li>不受7比特ASCII编码协议限制；</li>
<li>处理既包含文本又包含图形的文档时，HTTP把每个对象封装到它自己的HTTP响应报文中；</li>
</ul>
</li>
<li>SMTP：<ul>
<li>从一个邮件服务器向另一个邮件服务器传送文件；</li>
<li>基本上是一个<strong>推协议</strong>，发送邮件服务器把文件推向接收邮件服务器，这个TCP连接由要发送该文件的机器发起的；</li>
<li>采用7比特ASCII字符编码发送；</li>
<li>处理既包含文本又包含图形的文档时，SMTP把所有报文对象放在一个报文之中；</li>
</ul>
</li>
</ul>
<h3 id="3-3-邮件报文格式"><a href="#3-3-邮件报文格式" class="headerlink" title="3.3 邮件报文格式"></a>3.3 邮件报文格式</h3><ul>
<li>必须包含的首部行：<ul>
<li>From：首部行；</li>
<li>To：首部行；</li>
<li>可能包含一个Subject：首部行；</li>
<li>首部之后接一个空白行；</li>
<li>再后面是一个以ASCII格式表示的报文体；</li>
</ul>
</li>
</ul>
<h3 id="3-4-邮件访问协议"><a href="#3-4-邮件访问协议" class="headerlink" title="3.4 邮件访问协议"></a>3.4 邮件访问协议</h3><ul>
<li><p>典型的用户通常在本地PC上运行一个用户代理程序，而它访问存储在总是保持开机的共享邮件服务器上的邮箱，该邮件服务器与其它用户共享，通常由用户的ISP进行维护（大学或公司）；</p>
</li>
<li><p>如图所示：</p>
<ul>
<li>问题一：发送方代理不能直接通过SMTP发送到接收方的邮件服务器，必须要考虑到目的地不可达时（是接收方服务器关机）情形，所以通过发送方邮件服务器进行中继，这样一来就可以一直重复发送，知道发送完毕为止；</li>
<li>问题二：SMTP是一个推协议，而从接收方代理主动获取邮件是一个拉操作，只能通过第三方的特殊邮件访问协议进行；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/027.png" alt="image-20201013222819767"></p>
<h4 id="3-41-POP3"><a href="#3-41-POP3" class="headerlink" title="3.41 POP3"></a>3.41 POP3</h4><ul>
<li>是一个极为简单的邮件访问协议，功能有限；</li>
<li>将邮件下载到本地主机；</li>
<li>工作的三个阶段：<ul>
<li>特许：用户代理鉴别用户；</li>
<li>事务处理：用户代理取回报文，对报文做或取消删除标记；</li>
<li>更新：客户发送quit命令之后，结束POP3会话，删除标记删除的报文；</li>
</ul>
</li>
</ul>
<h4 id="3-42-IMAP"><a href="#3-42-IMAP" class="headerlink" title="3.42 IMAP"></a>3.42 IMAP</h4><ul>
<li>IMAP协议服务器把每个报文与一个文件夹关联，可删除可移动可读取；</li>
<li>为用户提供了在远程文件夹中查询邮件的命令；</li>
<li>允许用户代理只获取报文某些部分；</li>
<li>维护了IMAP会话的用户状态信息；</li>
</ul>
<h4 id="3-43-基于Web的电子邮件（HTTP）"><a href="#3-43-基于Web的电子邮件（HTTP）" class="headerlink" title="3.43 基于Web的电子邮件（HTTP）"></a>3.43 基于Web的电子邮件（HTTP）</h4><ul>
<li>使用Web浏览器收发电子邮件；</li>
<li>使用这种服务时：<ul>
<li>用户代理就是普通的浏览器；</li>
<li>用户和他自己远程邮箱之间的通信则通过HTTP进行；</li>
</ul>
</li>
</ul>
<h2 id="4-DNS：因特网的目录服务（重点）"><a href="#4-DNS：因特网的目录服务（重点）" class="headerlink" title="4.DNS：因特网的目录服务（重点）"></a>4.DNS：因特网的目录服务（重点）</h2><ul>
<li>因特网上的主机可以使用多种方式进行标注：<ul>
<li>主机名（服务器域名）：很少或几乎不提供主机在因特网中改的位置，适合人类标识；</li>
<li>IP地址：从左到右扫描时能够获得越来越具体的关于主机在因特网中的位置，适合路由器标识；</li>
</ul>
</li>
</ul>
<h3 id="4-1-DNS提供的服务"><a href="#4-1-DNS提供的服务" class="headerlink" title="4.1 DNS提供的服务"></a>4.1 DNS提供的服务</h3><ul>
<li><p>DNS全称为域名系统，能够进行主机名到IP地址转换的目录服务；</p>
</li>
<li><p>DNS协议是应用层协议，但通常由其它协议使用，将用户提供的主机名解析为IP地址；</p>
</li>
<li><p>DNS：</p>
<ul>
<li>一个由分层的DNS服务器实现的分布式数据库；</li>
<li>一个使得主机能够查询分布式数据库的应用层协议；</li>
<li>DNS协议运行在UDP上，使用53号端口；</li>
</ul>
</li>
<li><p>浏览器调用DNS解析过程：</p>
<ul>
<li>DNS给使用它的因特网额外的时延；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/028.png" alt="image-20201013225715686"></p>
</li>
<li><p>其它服务：</p>
<ul>
<li>主机别名：应用程序可以调用DNS来获取主机别名对应的规范主机名以及主机的IP地址；</li>
<li>邮件服务器别名；</li>
<li>负载分配：用于在冗余的服务器之间进行负载分配；</li>
</ul>
</li>
</ul>
<h3 id="4-2-DNS工作机理（IP地址转换）"><a href="#4-2-DNS工作机理（IP地址转换）" class="headerlink" title="4.2 DNS工作机理（IP地址转换）"></a>4.2 DNS工作机理（IP地址转换）</h3><ul>
<li>集中式设计模型：整个因特网使用一个DNS服务器，该服务器包含所有映射，但是具有一定缺陷：<ul>
<li>单点故障；</li>
<li>通信容量；</li>
<li>远距离的集中式数据库；</li>
<li>维护；</li>
</ul>
</li>
<li>在单一DNS服务器上运行集中式数据库缺少可扩展能力；</li>
</ul>
<h4 id="4-21-分布式、层次数据库"><a href="#4-21-分布式、层次数据库" class="headerlink" title="4.21 分布式、层次数据库"></a>4.21 分布式、层次数据库</h4><p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/029.png" alt="image-20201014164122021"></p>
<ul>
<li><p>大量DNS以层次结构组织分布于全世界；</p>
</li>
<li><p>服务器类型：</p>
<ul>
<li>根DNS服务器；</li>
<li>顶级域服务器；</li>
<li>权威DNS服务器；</li>
</ul>
</li>
<li><p>举例分析获取 <a href="http://www.amazon.com/">www.amazon.com</a> IP地址：</p>
<ul>
<li>客户与根服务器之一联系，返回顶级域名 com 的TLD服务器IP地址；</li>
<li>客户与这些返回的TLD服务器之一联系，返回 amazon.com 权威服务器IP地址；</li>
<li>客户与 amazon.com 权威服务器之一联系，返回 <a href="http://www.amazon.com/">www.amazon.com</a> IP地址；</li>
</ul>
</li>
<li><p>除此之外，每个ISP都有一台本地DNS服务器，本地DNS服务器不属于DNS服务器层次结构；</p>
</li>
<li><p>举例分析主机 cse.nyu.edu 获取 gaia.cs.umass.edu 的IP地址：</p>
<ul>
<li>cse.nyu.edu 主机向它的本地DNS服务器 dns.nyu.edu 发送一个DNS查询报文；</li>
<li>本地DNS服务器将报文转发给根DNS服务器；</li>
<li>根DNS服务器注意到 edu 前缀并向本地DNS服务器返回负责 edu 的TLD的IP地址列表；</li>
<li>本地DNS服务器再次向这些TLD服务器之一发送查询报文；</li>
<li>该TLD服务器注意到umass.edu前缀，用权威DNS服务器 dns.umass.edu 的IP地址进行响应；</li>
<li>最后，本地DNS服务器直接向 dns.umass.edu 重发查询报文；</li>
<li>dns.umass.edu 使用 gaia.cs.umass.edu IP地址进行响应，即查询完毕；</li>
</ul>
</li>
<li><p>注意上述事例中，实际上TLD服务器并不一定知道目的主机的权威DNS服务器，而是知道中间的某个服务器，继续进行转换才能得到。上述例子的报文查询使用了递归查询和迭代查询的方式；</p>
</li>
</ul>
<h4 id="4-22-DNS缓存"><a href="#4-22-DNS缓存" class="headerlink" title="4.22 DNS缓存"></a>4.22 DNS缓存</h4><blockquote>
<p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术</p>
</blockquote>
<ul>
<li>DNS缓存原理：在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将映射缓存到本地DNS服务器，一段时间后再丢弃缓存的信息；</li>
<li>本地DNS服务器也能缓存TLD服务器的IP地址，因此允许本地DNS绕过查询链中的根DNS服务器；</li>
</ul>
<h3 id="4-3-DNS记录和报文"><a href="#4-3-DNS记录和报文" class="headerlink" title="4.3 DNS记录和报文"></a>4.3 DNS记录和报文</h3><ul>
<li>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（RR），RR提供了主机名到IP地址的映射；</li>
<li>资源记录是一个包含下列字段的四元组：<ul>
<li>(Name, Value, Type, TTL)；</li>
<li>TTL是该记录的生存时间，它决定了资源记录应该从缓存中删除的时间；</li>
<li>Name和Value的值取决于Type的值：<ul>
<li>Type = A，Name是主机名，Value是该主机名对应的IP地址；</li>
<li>Type = NS，Name是个域（如foo.com），Value是一个知道如何获取该域中主机IP地址的权威DNS服务器的主机名；</li>
<li>Type = CNAME，Value是别名为Name的主机对应的规范主机名；</li>
<li>Type = MX，Value是个别名为Name的邮件服务器的规范主机名；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-31-DNS报文"><a href="#4-31-DNS报文" class="headerlink" title="4.31 DNS报文"></a>4.31 DNS报文</h4><blockquote>
<p>DNS只有查询和回答报文，并且查询报文和回答报文格式相同</p>
</blockquote>
<ul>
<li>报文格式图示：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/030.png" alt="image-20201014180118935"></p>
<ul>
<li><p>前十二个字节是首部区域，有以下字段：</p>
<ul>
<li>标识符：16比特的数，用于表示该报文，查询报文中的标识符会被复制到回答报文中，以表示相匹配；</li>
<li>标志：1比特指出查询报文（0）或回答报文（1），其余自查</li>
<li>其余四个有关数量的字段，指出了在首部后的四类数据区域出现的数量；</li>
</ul>
</li>
<li><p>问题区域包含正在进行的查询信息：</p>
<ul>
<li>名字字段：主机名；</li>
<li>类型字段：该主机名正被询问的问题类型；</li>
</ul>
</li>
<li><p>回答区域是回答报文拥有的，包含了对最初请求的名字的资源记录：</p>
<ul>
<li>回答报文中可以有多条RR，意味着一个主机名能拥有多个IP地址（冗余Web服务器）；</li>
</ul>
</li>
<li><p>权威区域包含其它权威服务器的记录；</p>
</li>
<li><p>附加区域包含了其它有帮助的信息；</p>
</li>
<li><p>使用nslookup程序能够从正在工作的主机直接向某些DNS服务器发送一个查询报文；</p>
</li>
</ul>
<ul>
<li>除此之外，还可向DNS服务器插入资源记录；</li>
</ul>
<h2 id="5-P2P文件分发"><a href="#5-P2P文件分发" class="headerlink" title="5.P2P文件分发"></a>5.P2P文件分发</h2><ul>
<li>使用P2P体系结构，对总是打开的基础设施服务器具有最小的依赖：<ul>
<li>从单一服务器向大量主机（对等方）分发一个大文件，每个对等方能向任何其它对等方重新分发它已经收到的该文件的任何部分；</li>
</ul>
</li>
</ul>
<h3 id="5-1-P2P体系结构的扩展性"><a href="#5-1-P2P体系结构的扩展性" class="headerlink" title="5.1 P2P体系结构的扩展性"></a>5.1 P2P体系结构的扩展性</h3><ul>
<li>图示实例：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/031.png" alt="image-20201014210430123"></p>
<ul>
<li><p>将一个文件分发给固定对等方集合，u表示服务器或对等方接入链路的上载速率，d表示下载速率，被分发的文件长度为F（以比特为单位），N表示对等方数量，考虑所有理想化情形下，求其分发时间：</p>
<ul>
<li><p>客户-服务器体系结构：</p>
<ul>
<li>服务器必须向N个对等方每个传输该文件的一个副本，传输比特为N×F，由于服务器上载速率为u<sub>s</sub>，所以分发时间至少为N×F/u<sub>s</sub>；</li>
<li>令d<sub>min</sub>表示具有最小下载速率的对等方的下载速率，即d<sub>min</sub> = min{d<sub>1</sub>，d<sub>p</sub>，···，d<sub>N</sub>}，因此具有最小下载速率的对等方下载时间为F/d<sub>min</sub>；</li>
<li>综上，分发时间D<sub>cs</sub> &gt;= max{N×F/u<sub>s</sub>，F/d<sub>min</sub>}，而对于足够大的N，其分发时间由N×F/u<sub>s</sub>确定；</li>
</ul>
</li>
<li><p>P2P：</p>
<ul>
<li>在分发初始，服务器至少发送一次该文件，最小分发时间为F/u<sub>s</sub>；</li>
<li>具有最低下载速率的对等方获取文件最短分发时间为F/d<sub>min</sub>；</li>
<li>系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方的上载速率，即u<sub>total</sub> = u<sub>s</sub> + u<sub>1</sub> + ··· +u<sub>N</sub>，系统必须向N个对等方总共交付N×F比特，因此最小分发时间为N×F/u<sub>s</sub> + u<sub>1</sub> + ··· +u<sub>N</sub>；</li>
<li>综上，最小分发时间D<sub>P2P</sub> = max{F/u<sub>s</sub>，F/d<sub>min</sub>，N×F/u<sub>s</sub> + u<sub>1</sub> + ··· +u<sub>N</sub>}；</li>
</ul>
</li>
<li><p>效用关系如图：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/032.png" alt="image-20201014220402424"></p>
</li>
</ul>
<h3 id="5-2-BitTorrent"><a href="#5-2-BitTorrent" class="headerlink" title="5.2 BitTorrent"></a>5.2 BitTorrent</h3><blockquote>
<p>BitTorrent是一个用于文件分发的流行P2P协议</p>
</blockquote>
<ul>
<li>洪流：参与一个特定文件分发的所有对等方的集合，在一个洪流中的对等方彼此下载等长度的文件块，任何对等方能够随时进出该洪流；</li>
<li>追踪器：每个洪流具有的一个基础设施节点，在新对等方加入时注册标记，并且周期性地接收对等方的通知以确保对等方依然存在洪流中；</li>
<li>BitTorrent运行过程：<ul>
<li>一个新对等方加入洪流，追踪器随机从对等方集合中选择一个子集并将其IP地址发送给新对等方，使之与其创建TCP连接获取文件，创建TCP连接的对等方被称为新对等方的邻近对等方；</li>
<li>由于对等方随时能离开与加入，因此一个对等方的邻近对等方将随时间而波动；</li>
<li>该对等方能够使用<strong>最稀缺优先技术</strong>（最稀缺的块就是邻居中副本最少的块）首先请求最稀缺的块；</li>
<li>该对等方使用对换算法根据当前能够以最高速率向它提供数据的邻居给与优先响应权，例如，响应接收传输速率排名前4的对等方的请求，并且每过一段时间重新替换新的对换伴侣，这些对等方被称为疏通；</li>
</ul>
</li>
<li>另一种P2P应用——分布式散列表（DHT）：<ul>
<li>分布式散列表是一种简单的数据库，其数据库记录分布在一个P2P系统的多个对等方上；</li>
<li>DHT得到了广泛实现（如在BitTorrent中），并成为大量研究的主题；</li>
</ul>
</li>
</ul>
<h2 id="6-视频流和内容分发网"><a href="#6-视频流和内容分发网" class="headerlink" title="6.视频流和内容分发网"></a>6.视频流和内容分发网</h2><h3 id="6-1-因特网视频"><a href="#6-1-因特网视频" class="headerlink" title="6.1 因特网视频"></a>6.1 因特网视频</h3><ul>
<li>在流式存储视频应用中，基础的媒体是预先录制的视频；</li>
<li>视频是由一系列的图像，以一种恒定的速率（如每秒24张图像）来展现，而一幅未压缩、数字编码的图像由像素阵列组成，其中每个像素都是由一些比特编码来表示亮度和颜色；</li>
<li>视频的一个重要特征就是能够被压缩，因而可用比特率来权衡视频质量；</li>
<li>流式视频最为重要的性能度量是平均端到端吞吐量，为了提供连续不断的布局，网络必须为流式应用提供平均吞吐量，这个流式应用至少与压缩视频的比特率一样大；</li>
</ul>
<h3 id="6-2-HTTP流和DASH"><a href="#6-2-HTTP流和DASH" class="headerlink" title="6.2 HTTP流和DASH"></a>6.2 HTTP流和DASH</h3><ul>
<li>在HTTP流中，视频只是存储在HTTP服务器中的一个普通的文件，每个文件具有一个特定的URL，但HTTP流所有客户接受到的视频编码版本相同，也就是比特率相同，显然并没有考虑用户带宽的问题；</li>
<li>DASH解决了上述问题，DASH流中，将视频编码成几个不同的版本，每个版本具有不同的比特率，每一个版本都拥有属于自己的URL，DASH初始时根据用户带宽自定义选择一个版本的视频，并且允许用户更改版本；</li>
</ul>
<h3 id="6-3-内容分发网（CDN）"><a href="#6-3-内容分发网（CDN）" class="headerlink" title="6.3 内容分发网（CDN）"></a>6.3 内容分发网（CDN）</h3><ul>
<li>建立大型单一的大规模数据中心存储所有视频并且直接传输给用户存在三个问题：<ul>
<li>客户原理数据中心时，服务器到客户之间的其中一个通信链路提供的吞吐量如果小于视频消耗速率，则有强大的停滞时延；</li>
<li>流行的视频可能经过相同的链路发送很多次，既浪费宽带，又需向ISP支付更多费用；</li>
<li>单个数据中心可能发生单点故障；</li>
</ul>
</li>
<li>CDN管理分布在多个地理位置上的服务器，在它的服务器上存储视频（包括其它Web内容）的副本，并且视图将每个用户请求定向到一个能提供最好用户体验的CDN位置；</li>
<li>CDN两种类型：<ul>
<li>专用CDN：由内容提供商拥有；</li>
<li>第三方CDN，为多个内容提供商分发内容；</li>
</ul>
</li>
<li>CDN两种服务器安置原则：<ul>
<li>深入：<ul>
<li>由Akamai首创，通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中；</li>
<li>目的是靠近端用户，通过减少端用户和CDN集群之间链路和路由器的数量，从而改善用户感受的时延和吞吐量；</li>
<li>是一种高度分布式设计，维护和管理集群困难；</li>
</ul>
</li>
<li>邀请做客：<ul>
<li>由Limelight和其它CDN公司采用，通过在少量关键位置建造大集群来邀请ISP做客；</li>
<li>不是将集群放在接入ISP中，这些CDN通常将它们的集群放置在因特网交换点（IXP）；</li>
<li>产生较低的维护和管理开销，有可能以对端用户的较高时延和较低吞吐量为代价；</li>
</ul>
</li>
</ul>
</li>
<li>很多CDN没有将视频推入集群，而是通过一种简单的<strong>拉策略</strong>：<ul>
<li>如果客户向未存储该视频的集群请求视频，该集群从某种新仓库或另一个集群检索该视频，向客户发送的同时存储副本到本地；</li>
<li>存储器满时，删除不经常使用的视频；</li>
<li>这个拉策略和因特网缓存与分页机制很像；</li>
</ul>
</li>
</ul>
<h4 id="6-31-CDN操作"><a href="#6-31-CDN操作" class="headerlink" title="6.31 CDN操作"></a>6.31 CDN操作</h4><ul>
<li>当用户主机中的一个浏览器指令剑索一个特定视频（URL标识）时，CDN必须截获该请求：<ul>
<li>确定此时适合用于该用户的CDN服务器集群；</li>
<li>将客户的请求重定向到该集群的某台服务器；</li>
</ul>
</li>
<li>截获和重定向机制，步骤：<ul>
<li>用户访问视频网站；</li>
<li>用户点击视频链接，发送DNS请求；</li>
<li>用户本地DNS服务器（LDNS）将该请求中继到一台用于域名的权威DNS服务器，该权威CDN服务器返回CDN域的主机名；</li>
<li>用户本地DNS服务器向该主机名发起第二个请求，CDN服务器的DNS返回CDN内容服务器的IP响应；</li>
<li>用户本地DNS服务器向用户主机转发IP地址；</li>
<li>建立TCP连接并发出HTTP GET请求；</li>
<li>CDN响应；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/033.png" alt="image-20201014231944805"></p>
<h4 id="6-32-集群选择策略"><a href="#6-32-集群选择策略" class="headerlink" title="6.32 集群选择策略"></a>6.32 集群选择策略</h4><ul>
<li><p>CDN部署的核心就是集群选择策略，即动态地将客户定向到CDN中某个服务器集群或数据中心的机制；</p>
</li>
<li><p>CDN在得到客户的LDNS服务器的IP地址后，需要基于该IP地址选择一个适当的集群，并将其IP响应给LDNS；</p>
</li>
<li><p>策略：</p>
<ul>
<li>指派到地理上最为邻近的集群，但地理邻近未必网络传输路径短；</li>
<li>基于当前流量条件为客户决定最好的集群，CDN能够对其集群和客户之间的时延和丢包性能执行周期性的实时测量；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下方法</tag>
        <tag>理论学习</tag>
        <tag>教材</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下方法学习笔记（三）运输层</title>
    <url>/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="1-运输层概述"><a href="#1-运输层概述" class="headerlink" title="1.运输层概述"></a>1.运输层概述</h2><blockquote>
<p>运输层服务过程：在发送端（端系统），运输层将从发送端应用程序进程接收到的报文转换为运输层分组（报文段），进而传递给网络层，网络层将其封装成网络层分组（数据报）并向目的地发送；在接收端（端系统），网络层从数据报中提取运输层报文段，并根据该报文段（应用程序决定使用哪一个运输层协议）上交给运输层。</p>
</blockquote>
<h3 id="1-1-运输层和网络层的关系"><a href="#1-1-运输层和网络层的关系" class="headerlink" title="1.1 运输层和网络层的关系"></a>1.1 运输层和网络层的关系</h3><blockquote>
<p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供逻辑通信</p>
</blockquote>
<h3 id="1-2-因特网运输层概述"><a href="#1-2-因特网运输层概述" class="headerlink" title="1.2 因特网运输层概述"></a>1.2 因特网运输层概述</h3><p>因特网提供两种运输层协议：</p>
<ul>
<li>UDP：用户数据报协议，为应用程序提供不可靠、无连接的服务；</li>
<li>TCP：传输控制协议，为应用程序提供可靠的、面向连接的服务，除此之外提供附加服务：<ul>
<li>可靠数据传输服务，通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程；</li>
<li>拥塞控制服务，通过调节TCP连接的发送端发送进入网络的流量速率来防止任何一条TCP连接占用过多带宽；</li>
</ul>
</li>
<li>UDP和TCP最基本的功能是将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务，即应用层只考虑进程交互，而不必关心这两个进程的具体位置；<ul>
<li>该基本服务被称为运输层的<strong>多路复用</strong>和<strong>多路分解</strong>；</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2.多路复用和多路分解"></a>2.多路复用和多路分解</h2><ul>
<li><p>多路分解：在一个接收端将运输层报文段中的数据交付到正确的套接字的过程就是一次分解，每一个进程拥有一个或多个套接字，使用一个标识符特定申明其为TCP或UDP套接字，套接字收到报文段传输给自己的数据之后再传输给它所属的进程；</p>
</li>
<li><p>多路复用：在源主机上，从不同的套接字中收集数据块，并为每个数据块封装首部信息从而生成报文段，然后将报文段传递到网络层的整个过程；</p>
</li>
<li><p>报文段通过端口号字段标识需要交付的套接字：</p>
<ul>
<li>该特殊字段分为源端口号和目的端口号字段，每一个端口号是一个16比特的数，大小在0~65535之间：<ul>
<li>0~1023是周知端口号，这是受限制的，计算机主机保留给HTTP（80端口号）、FTP（21端口号）之类的周知应用层协议来使用的；</li>
<li>我们开发一个新的应用程序时，必须为其分配一个端口号，而主机上的每个套接字分配一个端口号；</li>
<li>运输层通过检查报文段中的目的端口号，将其定向到相应的套接字，然后报文段中的数据通过套接字进入其所连接的进程；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/034.png" alt="image-20201101143437667"></p>
</li>
</ul>
<h3 id="2-1-无连接的多路复用及多路分解（UDP）"><a href="#2-1-无连接的多路复用及多路分解（UDP）" class="headerlink" title="2.1 无连接的多路复用及多路分解（UDP）"></a>2.1 无连接的多路复用及多路分解（UDP）</h3><p>以整个过程为例解释说明：</p>
<ol>
<li>主机运行的程序创建一个UDP套接字，创建时运输层会从1024~65535范围内自动分配一个当前未被使用的端口号；</li>
<li>可以关联特定端口号，如果应用程序开发者所编写的代码实现的是一个周知协议的服务器端，则分配一个相应的周知端口号，通常，应用程序的客户端让运输层自动分配端口号，而服务器端则分配一个固定的端口号；</li>
<li>假定主机A上正在运行的进程具有UDP端口12345，需要发送数据给主机B上另一个具有UDP端口23456的进程；</li>
<li>主机A运输层创建一个运输层报文段，包括数据、源端口号（12345）、目的端口号（23456）和其它值；</li>
<li>运输层将得到的报文段传递到网络层；</li>
<li>网络层将该报文段封装在一个IP数据报中，并交付给接收主机B；</li>
<li>该报文段到达接收主机B，接收主机运输层检查报文段中的目的端口号（23456）并将该报文段交付给端口号23456所标识的套接字，注意：一个UDP套接字由二元组（目的IP地址，目的端口号）唯一标识，因此，如果两个UDP报文段有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程；</li>
<li>当B需要回发一个报文段给A时，就取用源报文段的源端口号作为新报文段的目的端口号；</li>
</ol>
<h3 id="2-2-面向连接的多路复用及多路分解（TCP）"><a href="#2-2-面向连接的多路复用及多路分解（TCP）" class="headerlink" title="2.2 面向连接的多路复用及多路分解（TCP）"></a>2.2 面向连接的多路复用及多路分解（TCP）</h3><blockquote>
<p>TCP套接字由四元组（源端口号、源IP地址、目的端口号、目的IP地址）唯一标识，当一个源主机向目的主机发送一个连接报文段请求TCP连接时，目的主机会根据该报文段中源端口号、源IP地址、目的端口号、目的IP地址创建一个TCP连接套接字，并在其四元组中通过这四个值来标识，之后到达的数据报文段只有四元组全部匹配才会被定向到该报文段，即一个套接字只与一个特定的进程联系</p>
</blockquote>
<h3 id="2-3-Web服务器和TCP"><a href="#2-3-Web服务器和TCP" class="headerlink" title="2.3 Web服务器和TCP"></a>2.3 Web服务器和TCP</h3><blockquote>
<p>一台Web服务器为每条连接生成一个新进程，每个进程都拥有自己的连接套接字，通过这些套接字可以接收到HTTP请求和发送HTTP响应</p>
</blockquote>
<p>连接套接字和进程之间并非总是一一对应，现在的高性能Web服务器只使用一个进程，但为每个新客户创建一个具有新连接套接字的新线程（线程可看做轻量级的子进程），对于这样一台服务器而言，套接字和进程就不是一一对应的。</p>
<ul>
<li>如果客户和服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由一个服务器套接字交换HTTP报文；</li>
<li>如果使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，这种套接字的频繁创建和关闭会严重影响一个繁忙的Web服务器的性能；</li>
</ul>
<h2 id="3-无连接运输：UDP"><a href="#3-无连接运输：UDP" class="headerlink" title="3.无连接运输：UDP"></a>3.无连接运输：UDP</h2><blockquote>
<p>UDP除了实现复用和分解功能及少量的差错检测外，几乎没有对IP增加别的东西，应用程序几乎时直接和IP协议打交道</p>
</blockquote>
<p>UDP优点：</p>
<ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细：<ul>
<li>只要应用进程将数据传输给UDP，UDP就会将其打包进入UDP报文段并立即发送给网络层；</li>
<li>而TCP拥塞机制不管可靠交付的时间，在拥塞时会自动延迟报文段的传送；</li>
</ul>
</li>
<li>无需建立连接：<ul>
<li>UDP不会引入建立连接的时延；</li>
<li>而TCP会在数据传输之前进行三次握手协议；</li>
</ul>
</li>
<li>无连接状态：<ul>
<li>TCP需要在端系统中维护一系列连接状态；</li>
<li>UDP不维护连接状态也不跟踪参数，当应用程序运行在UDP上时服务器能支持更多的活跃客户；</li>
</ul>
</li>
<li>分组首部开销小：<ul>
<li>每个TCP报文段有20字节的首部开销，而UDP只有8字节的首部开销；</li>
</ul>
</li>
</ul>
<p>如图所示：</p>
<ul>
<li>电子邮件、远程终端访问、Web及文件传输都运行在TCP协议上，因为它们都需要TCP的可靠传输服务；</li>
<li>UDP用于：<ul>
<li>承载网络管理数据，网络管理应用程序通常必须在网络重压状态时运行，而这个时候可靠的拥塞控制的数据传输难以实现；</li>
<li>多媒体应用程序，但在UDP上运行多媒体应用具有争议，因为没有拥塞控制，那么当很多人都启用流式高比特视频而不使用任何拥塞控制则会使得路由器中大量分组溢出，以至于非常少的UDP分组能够到达目的主机；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/035.png" alt="image-20201101160411184"></p>
<h3 id="3-1-UDP报文段结构"><a href="#3-1-UDP报文段结构" class="headerlink" title="3.1 UDP报文段结构"></a>3.1 UDP报文段结构</h3><p>如图所示：</p>
<ul>
<li>长度字段：指示了在UDP报文段中的字节数（首部加数据）；</li>
<li>检验和：接收方使用检验和来检查该报文段是否出现了差错；</li>
<li>首部四个字段，每个字段由两个字节组成；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/036.png" alt="image-20201101161512050"></p>
<h3 id="3-2-UDP检验和"><a href="#3-2-UDP检验和" class="headerlink" title="3.2 UDP检验和"></a>3.2 UDP检验和</h3><blockquote>
<p>UDP检验和提供了差错检测功能，用于确定当UDP报文段从源到达目的地移动时，其中比特是否发生变化</p>
</blockquote>
<ul>
<li>检验和计算过程：发送方的UDP对报文段中所有16比特的和进行反码运算，求和时遇到的任何溢出都回卷，得到的结果被放在UDP报文段中的检验和字段；</li>
</ul>
<p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/037.png" alt="image-20201101162908522"></p>
<ul>
<li>注意最后一次求和时高位比特有溢出现象，需要回卷到低位比特；</li>
<li>反码运算得<code>1011010100111101</code>，这个值就是检验和的值；</li>
<li>在接收方，全部的四个16比特的和比特必须全为1，如果比特之一为0，则分组中出现了差错；</li>
<li>虽然UDP提供差错检测，但它对差错恢复无能为力，一般措施是丢弃或者交给应用程序并给出警告；</li>
</ul>
<ul>
<li>端到端原则：某种功能必须基于端到端实现，如此时的差错检验；</li>
</ul>
<h2 id="4-可靠数据传输原理"><a href="#4-可靠数据传输原理" class="headerlink" title="4.可靠数据传输原理"></a>4.可靠数据传输原理</h2><blockquote>
<p>由于可靠数据传输的实现问题不仅出现在运输层，也会出现在链路层和应用层，其下层协议未必可靠，因此需要实现可靠传输，这里假定底层信道只能丢失分组而不会对分组进行重排（即<strong>顺序到达</strong>）。且本节仅考虑单向数据传输，即数据传输是从发送端到接收端的，但对于协议而言需要在发送端和接收端两个方向上传输分组。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/038.png" alt="image-20201102183101917" style="zoom:80%;">

<ul>
<li>其中<code>udt</code>表示不可靠数据传输，<code>rdt</code>表示可靠数据传输；</li>
</ul>
<h3 id="4-1-构造可靠数据传输协议"><a href="#4-1-构造可靠数据传输协议" class="headerlink" title="4.1 构造可靠数据传输协议"></a>4.1 构造可靠数据传输协议</h3><h4 id="4-11-经完全可靠信道的可靠数据传输：rdt1-0"><a href="#4-11-经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="4.11 经完全可靠信道的可靠数据传输：rdt1.0"></a>4.11 经完全可靠信道的可靠数据传输：rdt1.0</h4><blockquote>
<p>假定底层信道完全可靠情形</p>
</blockquote>
<p>看到如图所示rdt1.0发送方和接收方有限状态机（FSM）：</p>
<ul>
<li>圆框中为状态；</li>
<li>箭头指示协议从一个状态变迁到另一个状态；</li>
<li>横线上方指示引起变迁的事件；</li>
<li>横线下方指示事件发生时采取的动作，如果没有事件或动作则分别使用符号<code>Λ</code>表示；</li>
<li>虚线表示FSM的初始状态；</li>
<li>rdt1.0过程如下：<ul>
<li>在发送端，从初始状态【等待来自上层的调用】出发，通过<code>rdt_send(data)</code>事件接收来自较高层的数据，实质上<code>rdt_send(data)</code>事件是由较高层应用的过程调用产生的；</li>
<li>由<code>make_pkt(data)</code>动作产生一个分组<code>packet</code>，并通过<code>udt_send(packet)</code>将分组发送到信道中；</li>
<li>经过事件和动作后状态变迁，重回【等待来自上层的调用】状态；</li>
<li>在接收端，从初始状态【等待来自下层的调用】出发，<code>rdt</code>通过<code>rdt_rcv(packet)</code>事件从较低层信道接收一个分组，该事件由较低层协议的过程调用产生；</li>
<li>经过<code>extract(packet,data)</code>动作从分组中取出数据，并通过<code>deliver_data(data)</code>将数据上传给较高层；</li>
<li>经过事件和动作后状态变迁，重回【等待来自下层的调用】状态；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/039.png" alt="image-20201102183921310"></p>
<h4 id="4-12-经具有比特差错信道的可靠数据运输：rdt2-0"><a href="#4-12-经具有比特差错信道的可靠数据运输：rdt2-0" class="headerlink" title="4.12 经具有比特差错信道的可靠数据运输：rdt2.0"></a>4.12 经具有比特差错信道的可靠数据运输：rdt2.0</h4><blockquote>
<p>假定底层信道可能出现比特受损（不丢失分组）情形</p>
</blockquote>
<p>自动重传请求协议（ARQ）：基于报文肯定确认或否定确认反馈并进行重传的可靠数据传输协议。</p>
<p>ARQ协议需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li>差错检测；</li>
<li>接收方反馈；</li>
<li>重传；</li>
</ul>
<p>rdt2.0 FSM图示：</p>
<ul>
<li>使用检验和进行检验；</li>
<li>使用了停等协议，没有收到ACK肯定确认之前一直停等或重传；</li>
<li>该版本协议具有致命缺陷：ACK/NAK可能受损！</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/040.png" alt="image-20201102190427731" style="zoom:80%;">



<p>rdt2.1 FSM图示：</p>
<ul>
<li>使用一个比特位字段来存放序号，分组确认完整发送后变换序号，该序号是用来解决发送方未正确接收到肯定确认时进行重传引起的冗余分组；</li>
<li>协议状态反映出目前正发送的分组或希望接收的分组序号；</li>
<li>两种接收状态：<ul>
<li>接收到和上次不同序号的分组时，接收方发送肯定确认ACK；</li>
<li>接收到受损的分组，接收方发送一个否定确认NAK；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/041.png" alt="image-20201102191720662" style="zoom:70%;">



<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/042.png" alt="image-20201102191748791" style="zoom:70%;">



<p>rdt2.2 FSM图示：</p>
<ul>
<li>在2.1的基础上实现无NAK的可靠数据传输协议：<ul>
<li>接收到受损分组，接收方对上次正确接收的分组发送一个ACK，即实现NAK功能；</li>
<li>实现方法是在返回确认时增加参数分组序号，返回ACK 0或ACK 1；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/043.png" alt="image-20201102194613476" style="zoom:70%;">



<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/044.png" alt="image-20201102194631080" style="zoom:70%;">



<h4 id="4-13-经具有比特差错的丢包信道的可靠数据传输：rdt3-0"><a href="#4-13-经具有比特差错的丢包信道的可靠数据传输：rdt3-0" class="headerlink" title="4.13 经具有比特差错的丢包信道的可靠数据传输：rdt3.0"></a>4.13 经具有比特差错的丢包信道的可靠数据传输：rdt3.0</h4><blockquote>
<p>假定底层信道传输时比特可能受损也可能丢包情形</p>
</blockquote>
<p>两个问题：怎样检测丢包以及发生丢包后应该采取什么措施。</p>
<p>倒计数定时器：</p>
<ul>
<li>每次发送一个分组（包括第一次分组和重传分组）时，就启动一个定时器；</li>
<li>响应定时器中断并采取动作；</li>
<li>终止定时器；</li>
<li>发送方通过定时器进行等待，一旦定时器中断，就采用重传操作，有效解决两个问题；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/045.png" alt="image-20201103074201864" style="zoom:80%;">



<p>由于分组序号在0和1之间交替，rdt3.0又被称作比特交替协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/046.png" alt="image-20201103074248098"></p>
<h3 id="4-2-流水线可靠数据传输协议"><a href="#4-2-流水线可靠数据传输协议" class="headerlink" title="4.2 流水线可靠数据传输协议"></a>4.2 流水线可靠数据传输协议</h3><blockquote>
<p>rdt3.0协议的核心问题在于它是一个停等协议，虽然功能正确，但并不能运用到实际问题中，否则发送方信道的<strong>利用率</strong>会极低。因此提出一个简单的解决方案：不以停等方式运行，允许发送方发送多个分组而无需等待确认，这种技术被称作<strong>流水线</strong>。</p>
</blockquote>
<p>流水线操作：</p>
<ul>
<li>增加序号范围，每个输送中的分组必须有唯一的序号，也有多个在输送中的未确认报文；</li>
<li>协议的发送方和接收方缓存多个分组，最低限度要缓存已发送但未确认的分组，或许还要缓存一些已正确接收的分组；</li>
<li>所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</li>
<li>解决流水线差错恢复两种方式：<ul>
<li>回退N步；</li>
<li>选择重传；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/047.png" alt="image-20201103075310783"></p>
<h3 id="4-3-回退N步（GBN）"><a href="#4-3-回退N步（GBN）" class="headerlink" title="4.3 回退N步（GBN）"></a>4.3 回退N步（GBN）</h3><blockquote>
<p>允许发送方发送多个分组而不需要等待确认，其中未确认的分组数不能超过某个最大允许数N，N常被称作<strong>窗口长度</strong>，GBN协议也被称为<strong>滑动窗口协议</strong>，解决了停等协议中利用率低的问题</p>
</blockquote>
<p>序号：</p>
<ul>
<li>基序号（base）：最早未确认分组的序号；</li>
<li>下一个序号（nextseqnum）：最小的未使用序号；</li>
<li>序号范围：<ul>
<li>[0，base-1]段对应已发送并已被确认的分组；</li>
<li>[base，nextseqnum-1]段对应已发送尚未确认的分组；</li>
<li>[nextseqnum，base+N-1]段对应将要被发送的分组序号；</li>
<li>[base+N+1~]段需要到当前未被确认的分组得到确认为止才能使用；</li>
<li>一个序号承载在分组首部的一个固定长度字段中，序号空间看成长度为2<sup>k</sup>的闭环，序号2<sup>k</sup>-1紧接着序号0；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/048.png" alt="image-20201103084832055"></p>
<p>提出问题：为什么不能将有限N转换为无限呢？</p>
<ul>
<li>流量控制是原因之一；</li>
</ul>
<p>扩展FSM：</p>
<ul>
<li>基于ACK、无NAK的GBN协议的发送方和接收方的FSM描述，增加了变量base和nextseqnum；</li>
<li>GBN发送方必须响应三中类型的事件：<ul>
<li>上层调用：<ul>
<li>上层直接调用<code>rdt_send()</code>，发送方检查自身发送窗口是否已满：<ul>
<li>未满则产生分组并将其发送，并相应地更新变量；</li>
<li>已满则将数据返回给上层，隐式地指示上层该窗口已满；</li>
</ul>
</li>
<li>使用同步机制（信号量或标识），允许上层在仅当窗口不满时才可调用<code>rdt_send()</code>；</li>
<li>缓存而并不立刻发送该分组；</li>
</ul>
</li>
<li>收到一个ACK：<ul>
<li>正常<strong>累积确认</strong>，对序号为n的分组发送ACK，表明接收方已正确接收到序号为n及以前的未确认的所有分组；</li>
<li>对于收到失序（即丢包）、受损的分组，接收方发送上一次序号ACK，表示请求重传上一次序号之后的所有未确认分组；</li>
</ul>
</li>
<li>超时事件：<ul>
<li>对于最早未确认分组（base序号）使用一个定时器，如果丢失或者时延过长则重传所有未确认分组，并重新启动定时器；</li>
</ul>
</li>
</ul>
</li>
<li>GBN接收方：<ul>
<li>接收到失序或受损分组时丢弃该分组并发送上一次序号ACK；</li>
<li>直接对已正确接收的分组发送ACK；</li>
<li>丢弃所有失序分组：<ul>
<li>优点：接收缓存简单，接收方不需要缓存任何失序分组，只需要维护下一个按序接收的分组序号并将其值存于<code>expectedseqnum</code>变量中；</li>
<li>缺点：随后对该分组的重传也许会丢失会出错，即可能需要更多次的重传；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/049.png" alt="image-20201103090002171"></p>
<p>实例：窗口长度N为4的GBN协议运行情况：</p>
<ol>
<li>由于窗口长度限制，发送方只能先发送0~3序号的分组，然后进行等待；</li>
<li>接收到连续的ACK 0和ACK 1 之后才能继续发送序号为4和5的分组；</li>
<li>接收方分组2丢失，因此分组序号3、4、5被发现是失序分组并被丢弃，接收方重新发送ACK 1；</li>
<li>发送方重传分组2、3、4、5；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/050.png" alt="image-20201103092101884"></p>
<h3 id="4-4-选择重传（SR）"><a href="#4-4-选择重传（SR）" class="headerlink" title="4.4 选择重传（SR）"></a>4.4 选择重传（SR）</h3><blockquote>
<p>当窗口长度和带宽延时都很大时，流水线中分组过多，GBN对于单个分组的差错而引起的重传大量分组则显得极为过分，选择重传基于解决这部分问题而设置。SR通过让发送方仅重传那些可能出错的分组而避免不必要的重传，而这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。</p>
</blockquote>
<p>序号空间：</p>
<ul>
<li>使用窗口长度N限制流水线中未完成未被确认的分组数，但发送方能够收到窗口中某些分组的ACK；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/051.png" alt="image-20201103093226708"></p>
<p>SR发送方采取的动作：</p>
<ul>
<li>从上层收到数据：从上层接收到数据后，SR发送方检查下一个可用分组的序号，该序号位于发送方的窗口内部时将数据打包发送，否则和GBN相同处理；</li>
<li>超时：使用定时器防止分组丢失，但是是每个分组都需要拥有自己的逻辑定时器；</li>
<li>收到ACK：收到ACK时，若分组序号在窗口内，则将该序号分组标记为已接收；若序号等于<code>send_base</code>，则窗口基序号向前移动到最小序号的未接收分组处；如果窗口移动了而此时又有序号位于窗口内的未发送分组，则发送这些新分组；</li>
</ul>
<p>SR接收方采取的动作：SR接收方将确认一个正确接收的分组而不管其是否失序，如果失序则缓存直到所有丢失分组都被收到时统一交付给上层</p>
<ul>
<li>序号在[rcv_base，rcv_base+N-1]范围内的分组被正确接收：收到的分组落在接收方的窗口内，接收方发送回一个该序号的ACK<ul>
<li>如果该分组以前没有收到过，则缓存该分组；</li>
<li>如果该分组的序号等于接收窗口的基序号（rcv_base），则该分组以及以前缓存的序号连续的（起始于rcv_base的）分组交付给上层，然后接收窗口向前移动分组的编号；</li>
</ul>
</li>
<li>序号在[rcv_base-N，rcv_base-1]范围内的分组被正确接收：在此情况下（即原ACK可能在返回时丢失），必须产生一个ACK，即使该分组是接收方已经确认过的分组；</li>
<li>其它情况：忽略该分组；</li>
</ul>
<p>N=4的实例SR分组丢失操作图示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/052.png" alt="image-20201103104615086"></p>
<p>在序列号范围有限（或者说窗口长度接近序列号范围长度时），发送方和接收方窗口间缺乏同步会产生严重的后果！</p>
<p>举例：N=3，分组序号为0~3：</p>
<ul>
<li>假定发送了分组0~2，并在接收方被正确接收且确认了，此时，接收方期待分组序列落在4、5、6分组上，其对应序列分别为3、0、1：<ul>
<li>①如图a：对前三个分组的ACK丢失，因此发送方重传这些分组，而接收方下一步接收的序号为0的分组所对应的就是1号分组而非其期待接收的4号分组；</li>
<li>②如图b：前三个分组的ACK都正确交付，因此发送方向前移动窗口并发送4、5、6个分组，其序号对应为3、0、1，若此时序号为3的分组丢失，但序号为0的分组到达，则对应SR接收方动作中一二种情形等同，没有办法区分是第一个分组的重传还是第五个分组的初次传输；</li>
</ul>
</li>
<li>窗口长度必须小于或等于序列空间大小的一半；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/053.png" alt="image-20201103104823611"></p>
<p>可靠数据传输原理总结：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/054.png" alt="image-20201103110050615"></p>
<h2 id="5-面向连接的运输：TCP"><a href="#5-面向连接的运输：TCP" class="headerlink" title="5 面向连接的运输：TCP"></a>5 面向连接的运输：TCP</h2><h3 id="5-1-TCP连接"><a href="#5-1-TCP连接" class="headerlink" title="5.1 TCP连接"></a>5.1 TCP连接</h3><blockquote>
<p>TCP连接是一条逻辑连接，只在源和目的端系统中维持连接状态，而不会在中间网络元素中存留连接状态</p>
</blockquote>
<p>全双工服务：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在A、B进程之间双向流通。</p>
<p>点对点：每一次发送过程，都是在单个发送方和单个接收方之间的连接。</p>
<p>TCP连接建立的过程：</p>
<ol>
<li>客户应用进程通知客户运输层，它想与服务器上的一个进程建立一条连接：<ol>
<li>三次握手协议：客户-服务器-客户，只有第三次客户发送的响应报文才可承载有效载荷（应用层数据）；</li>
</ol>
</li>
<li>建立连接后，客户进程通过套接字传递数据流，TCP将这些数据流引导到<strong>该连接</strong>的<strong>发送缓存</strong>里，发送缓存是发送三次握手协议期间设置的缓存之一；</li>
<li>TCP在它方便的时候会从该连接的发送缓存中取出一块数据并配上TCP首部形成<strong>TCP报文段</strong>，再传递给网络层，也就是发送数据；</li>
<li>接收端接收到报文段后，该报文段的数据就被放入该TCP连接的<strong>接收缓存</strong>中；</li>
<li>应用程序通过套接字从接收缓存中读取数据；</li>
</ol>
<ul>
<li>注意：<ul>
<li>TCP可从发送缓存里取出并放入报文段中的数据数量受限于<strong>最大报文段长度（MSS）</strong>；</li>
<li>MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（<strong>最大传输单元（MTU）</strong>）来设置，且MSS是指在报文段里应用层数据的最大长度，而不是包括首部的TCP报文段的最大长度；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/055.png" alt="image-20201103123411798"></p>
<p>由此可知，TCP连接的组成包括：</p>
<ul>
<li>客户与服务器主机上的缓存、变量和与进程连接的套接字；</li>
</ul>
<h3 id="5-2-TCP报文段结构"><a href="#5-2-TCP报文段结构" class="headerlink" title="5.2 TCP报文段结构"></a>5.2 TCP报文段结构</h3><p>如图所示：TCP报文段由首部和一个数据字段组成，数据字段包含一块应用数据，而MSS限制了报文段数据字段的最大长度（交互式应用通常传送长度小于MSS的数据块），首部包含：</p>
<ul>
<li>源端口号：多路复用来自上层的数据；</li>
<li>目的端口号：多路分解将数据传输到上层；</li>
<li>检验和字段；</li>
<li>序号字段；</li>
<li>确认号字段；</li>
<li>接收窗口字段：16比特，用于指示接收方愿意接收的字节数量，控制流量；</li>
<li>首部长度字段：4比特，由于选项字段可变，TCP首部的长度也是可变的通常选项字段为空时首部长度为20字节；</li>
<li>选项字段：可选与变长；</li>
<li>标志字段：6比特，ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认，其它比特位后续讲到；</li>
<li>紧急数据指针字段；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/056.png" alt="image-20201103210636179"></p>
<h4 id="5-21-序号和确认号"><a href="#5-21-序号和确认号" class="headerlink" title="5.21 序号和确认号"></a>5.21 序号和确认号</h4><blockquote>
<p>TCP把数据看成一个无结构的、有序的字节流，<strong>序号</strong>建立在传送的数据的字节流上，每一个数据字节都拥有自己的序号，一个报文段的序号是该报文首字节的字节流编号</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/057.png" alt="image-20201103212015084"></p>
<p><strong>确认号</strong>：主机A向主机B发送报文段时，确认号是主机A期待主机B下一次能够向它发送字节流数据的序号，同时也是确认该流中到第一个丢失字节为止的序号。举例：主机A收到主机B给自己发送的序号为0-535和900-1000的两个报文段数据，那么当它向B发送数据时，确认号就是536，期望下一次主机B能够发送从536序号开始的字节流数据报文段。</p>
<p>在上述例子中产生问题：第三个报文段900-1000序号失序到达，这时接收方有两个选择：</p>
<ul>
<li>立即丢弃失序报文段，这可以简化设计；</li>
<li>保留失序字节，并等待缺少的字节，实践中一般采用此方法；</li>
</ul>
<p>且在一条TCP连接过程，连接双方可以随机选择初始序号，这样做可以减少可能出现的与旧报文序号相同的误会。</p>
<h4 id="5-22-序号和确认号的一个学习案例"><a href="#5-22-序号和确认号的一个学习案例" class="headerlink" title="5.22 序号和确认号的一个学习案例"></a>5.22 序号和确认号的一个学习案例</h4><p>会话过程：</p>
<ol>
<li>主机A（客户）数据初始序号为42，主机B（服务器）数据初始序号为79，TCP首先建立连接；</li>
<li>主机A向主机B发送第一个报文段，初始序号为42，确认号为79，数据内容为<code>C</code>；</li>
<li>主机B向主机A回显它收到的数据<code>C</code>，其初始序号为79，确认号为43；</li>
<li>主机A向主机B发送一个响应报文，申明自己已经收到数据，虽然没有数据，但是依然使用了43的序号，这是因为序号字段必须填入某个序号；</li>
</ol>
<p>其中，主机B向主机A发送的响应数据其实已经包含确认，这种确认号被装载在一个承载数据内容的报文段的确认被称为是<strong>捎带</strong>的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/058.png" alt="image-20201103214621223"></p>
<h3 id="5-3-往返时间的估计与超时"><a href="#5-3-往返时间的估计与超时" class="headerlink" title="5.3 往返时间的估计与超时"></a>5.3 往返时间的估计与超时</h3><blockquote>
<p>超时/重传机制最明显的一个问题就是超时间隔长度的设置，这一节讨论这个问题</p>
</blockquote>
<h4 id="5-31-估计往返时间"><a href="#5-31-估计往返时间" class="headerlink" title="5.31 估计往返时间"></a>5.31 估计往返时间</h4><p>报文段<strong>样本RTT（SampleRTT）</strong>：从某报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量，也就是<strong>估计往返时间</strong>。</p>
<ul>
<li>由于TCP一般只在某一个时刻做一次SampleRTT测量，所以这个样本估计量是不够准确的，因此以平均RTT的方式解决准确性问题；</li>
<li>TCP维持一个SampleRTT均值（EstimatedRTT），一旦获得一个新的SampleRTT时，TCP按照以下公式更新EstimatedRTT值：<ul>
<li>其中<code>α</code>推荐值是0.125；</li>
<li>这个加权平均对最近的样本赋予的权值要大于对旧样本赋予的权值，因为越近的样本越能反映当前网络的拥塞状况，这种平均又被称为<strong>指数加权移动平均</strong>；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/059.png" alt="image-20201104102754129"></p>
<p><strong>RTT偏差（DevRTT）</strong>：测量RTT的变化，估算SampleRTT一般会偏离EstimatedRTT的程度。</p>
<ul>
<li><code>β</code>的推荐值是0.25；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/060.png" alt="image-20201104103344966"></p>
<h4 id="5-32-设置和管理重传超时间隔"><a href="#5-32-设置和管理重传超时间隔" class="headerlink" title="5.32 设置和管理重传超时间隔"></a>5.32 设置和管理重传超时间隔</h4><blockquote>
<p>超时间隔设置为EstimatedRTT加上一定余量，且当SampleRTT值波动较大时，这个余量应该大些，当波动较小时，这个余量应该小些。</p>
</blockquote>
<p>超时间隔（TimeoutInterval）：初始值推荐为1秒</p>
<ul>
<li>出现超时后，TimeoutInterval值加倍；</li>
<li>一旦收到报文段并更新EstimatedRTT，就使用公式<code>TimeoutInterval=EstimatedRTT+4×DevRTT</code>计算；</li>
</ul>
<h3 id="5-4-可靠数据传输"><a href="#5-4-可靠数据传输" class="headerlink" title="5.4 可靠数据传输"></a>5.4 可靠数据传输</h3><p>定时器，前面研究可靠数据传输时假定每一个已发送但未确认接收的报文段都拥有一个独立的定时器，但由于这样一来定时器的开销太大，实际开发中，TCP定时器管理过程对多个已发送但未接收的报文段仅使用单一的重传定时器。</p>
<blockquote>
<p>TCP使用超时机制和冗余确认技术实现差错报文段的恢复</p>
</blockquote>
<p>超时机制：</p>
<ul>
<li>发送方三个与重传有关的主要事件：<ul>
<li>从上层应用程序接收数据：将接收到的数据封装到报文段并发送给IP，当报文段被传给IP时，TCP就启动定时器，该定时器的超时间隔为<code>TimeoutInterval</code>；</li>
<li>定时器超时：TCP通过重传引起超时的报文段来作为响应，并且重启定时器，超时间隔加倍；</li>
<li>收到ACK：发送方接收到来自接收方的确认报文段（ACK）时，TCP将ACK的<code>y</code>值与它的变量<code>SendBase</code>进行比较<ul>
<li><input checked disabled type="checkbox"> <code>SendBase</code>是最早未被确认的字节的序号；</li>
<li><input checked disabled type="checkbox"> TCP采用累积确认，所以<code>y</code>确认了字节序号在<code>y</code>之前的所有字节都已经正确收到；</li>
<li><input disabled type="checkbox"> 如果<code>y&gt;SendBase</code>，则该ACK是在确认一个或多个先前未被确认的报文段，发送方更新<code>SendBase</code>值；如果当前有未被确认的报文段，TCP重启定时器<code>?</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/061.png" alt="image-20201104222955779"></p>
<h4 id="5-41-简化模型特殊情形"><a href="#5-41-简化模型特殊情形" class="headerlink" title="5.41 简化模型特殊情形"></a>5.41 简化模型特殊情形</h4><p>讨论只采用超时机制的简化模型中三种特殊情形：</p>
<ol>
<li>主机A向主机B发送的报文段正确到达，但是主机B响应的确认ACK丢失了，超时后，主机A会重传上一次报文段，而主机B接收到后会直接丢弃重传的报文段；</li>
<li>主机A连续发送两个报文段，然而在超时之前没有任何一个确认ACK到达，那么主机A重传第一个报文段，并且重启定时器，只要在这一次超时之前第二个报文段的确认ACK到达，主机A就不会再重传第二个报文段；</li>
<li>主机A连续发送两个报文段，第一个报文段的确认ACK丢失，但第二个报文段的确认ACK按时到达，主机A就会知道第二个确认ACK序号之前的字节都已到达，所以主机A并不会重传任何一个报文段；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/062.png" alt="image-20201104224510503"></p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/063.png" alt="image-20201104224532551" style="zoom:80%;">



<h4 id="5-42-超时间隔加倍"><a href="#5-42-超时间隔加倍" class="headerlink" title="5.42 超时间隔加倍"></a>5.42 超时间隔加倍</h4><blockquote>
<p>定时器时限过期后，每次TCP重传时都会将下一次的超时间隔设置为前一次的两倍，而不会使用从EstimatedRTT和DevRTT推算出的值，一直循环重传直到收到确认。在这个过程中，只要定时器的另外两个事件收到上层的数据和收到ACK中任何一个启动，TimeoutInterval都会根据最近的EstimatedRTT和DevRTT重新修改值</p>
</blockquote>
<p>定时器时限过期一般都是由网络拥塞引起的。</p>
<h4 id="5-43-快速重传"><a href="#5-43-快速重传" class="headerlink" title="5.43 快速重传"></a>5.43 快速重传</h4><blockquote>
<p>超时触发重传存在的问题之一就是超时周期可能相对较长，端到端时延增加</p>
</blockquote>
<p><strong>冗余ACK</strong>：发送方收到对某一报文段的确认后再次收到该报文段的ACK确认，可以通过冗余ACK检测丢包情况。</p>
<ul>
<li>当TCP接收方收到一个序号大于下一个所期望的、按序的报文段，它就检测出中间数据流出现间隔，即报文段丢失，它就会对已经接受到的最后一个按序字节数据进行重复确认，即产生冗余ACK；</li>
<li>如果TCP发送方接收到对相同数据的三个冗余ACK，说明跟在这个已被确认过三次的报文段之后的报文段已经丢失，就执行<strong>快速重传</strong>操作，即在该报文段定时器过期之前重传该丢失的报文段；</li>
</ul>
<p>TCP接收方的ACK生成策略：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/064.png" alt="image-20201104225512504"></p>
<h4 id="5-44-是回退N步还是选择重传"><a href="#5-44-是回退N步还是选择重传" class="headerlink" title="5.44 是回退N步还是选择重传"></a>5.44 是回退N步还是选择重传</h4><blockquote>
<p>TCP是一个GBN协议还是SR协议？</p>
</blockquote>
<p>情形一：TCP发送方仅需维持已发送过但未被确认的字节的最小序号（SendBase）和下一个将要发送的字节的序号（NextSeqNum）；</p>
<p>情形二：TCP会将正确接受但失序到达的报文段缓存起来；</p>
<p>情形三：当发送方发送一组报文段1，2，···，N，并且所有的报文段都正确按序到达接收方，而分组<code>n&lt;N</code>的确认报文丢失，其余<code>N-1</code>个确认ACK全部在超时之前到达</p>
<ul>
<li>对于GBN而言，它会重传所有序号为n以及之后的报文段；</li>
<li>而TCP最多只会重传序号为n的一个报文段，甚至如果报文段n+1的确认报文在超时之前到达的话，TCP不会重传任何报文段；</li>
</ul>
<p>TCP提供了一种方案：<strong>选择确认</strong>，允许TCP接收方有选择地确认失序报文段，而不是累积确认最后一个接收的有序报文段；实质上TCP提供的可靠数据传输更像是一种GBN和SR的混合协议。</p>
<h3 id="5-5-流量控制"><a href="#5-5-流量控制" class="headerlink" title="5.5 流量控制"></a>5.5 流量控制</h3><blockquote>
<p>一条TCP连接的每一侧主机都拥有一块接收缓存和一块发送缓存（全双工），如果某应用程序读取数据相对缓慢，而发送方发送数据太多、太快，则有可能使得接收方的接收缓存溢出，流量控制主要针对这一情形</p>
</blockquote>
<p><strong>流量控制</strong>：是一个速度匹配服务，发送方的发送速率和接收方应用程序读取数据的速率要相匹配，以消除发送方使接收方接收缓存溢出的情形。</p>
<p><strong>拥塞控制</strong>：TCP发送方因为IP网络的拥塞而被遏制发送。</p>
<p>两者得到的结果都是控制，但产生的原因不一样。</p>
<p>解决方案，以主机A向主机B发送大文件为例：</p>
<ul>
<li>接收窗口（rwnd）：该接收方还剩下多少接收缓存空间，由接收方放入报文段接收窗口字段发送回发送方，发送方通过维持该值来了解接收缓存的剩余空间，并且控制速率；</li>
<li><code>LastByteRead</code>：主机B上的应用程序从缓存读出的数据流的最后一个字节的序号；</li>
<li><code>LastByteRcvd</code>：从网络中到达的并已被放入主机B接收缓存中的数据流的最后一个字节的序号；</li>
<li>接收缓存（RcvBuffer）;</li>
<li>则应该满足：<ul>
<li><code>rwnd = RcvBuffer - [LastByteRead - LastByteRcvd] &gt;=0</code></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/065.png" alt="image-20201104234730901"></p>
<p>主机A轮流跟踪两个变量<code>LastByteRead</code>和<code>LastByteRcvd</code>，注意<code>LastByteRead - LastByteRcvd</code>值为主机A发送到连接中但未被确认的数据量。</p>
<p>考虑一个问题：假设主机B的接收缓存已经存满，即rwnd=0，在将rwnd=0通告给主机A之后，主机B没有任何数据需要发送（而TCP仅当在它有数据需要发送或者有确认需要发送时才会发送报文段给主机A）。而主机B上的应用程序将接收缓存清空之后，接收缓存就已经没有数据了，而主机A依然会被阻塞而不能再发送数据给主机B。</p>
<p>解决方案：TCP规范要求当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这样主机B就会实时刷新rwnd值并传递给主机A，让主机A知道接收缓存的空间余量。</p>
<p>UDP和TCP不同，它并不提供流量控制服务，报文段由于缓存溢出就可能在接收方丢失。</p>
<h3 id="5-6-TCP连接管理"><a href="#5-6-TCP连接管理" class="headerlink" title="5.6 TCP连接管理"></a>5.6 TCP连接管理</h3><blockquote>
<p>观察如何建立和拆除一条TCP连接</p>
</blockquote>
<p>建立过程：</p>
<ul>
<li><p>客户应用首先通知客户TCP，说明它想建立一个与服务器之间某个进程之间的连接；</p>
</li>
<li><p>TCP通过<strong>三次握手</strong>协议与服务器TCP建立一条TCP连接：</p>
<ul>
<li>客户端TCP首先向服务器端TCP发送一个特殊的TCP报文段，该报文段不包含数据，但在其首部的一个标志位<code>SYN比特</code>被置为1（该报文段又被称为<strong>SYN报文段</strong>）。此外，客户随机选择一个初始序号（client_isn），并将此序号放置于该SYN报文段的序号字段中。</li>
<li>TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报提取SYN报文段并为TCP连接分配变量和缓存（易受到SYN洪泛攻击，有修改），同时向客户端TCP发送允许连接的<strong>SYNACK报文段</strong>，其不能包含数据但首部包含三个信息：<ul>
<li>SYN比特置为1；</li>
<li>确认号字段被置为<code>client_isn+1</code>；</li>
<li>服务器选择自己的初始序号（server_isn），并放置到报文段首部的序号字段；</li>
</ul>
</li>
<li>客户收到SYNACK报文段，给该TCP连接分配变量和缓存，并向服务器发送另一个报文段。该报文段可以承载数据，SYN比特被置为0，且确认号字段存放值<code>server_isn+1</code>；</li>
</ul>
<p>在以后的每一个报文段中，SYN比特都被置为0。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/066.png" alt="image-20201105003237246" style="zoom:80%;">



<p>拆除过程：双方都能终止该连接，连接结束后，主机中资源将被释放，假设客户打算关闭连接（一般都是客户主动关闭）</p>
<ul>
<li>客户TCP发送一个特殊的报文段，标志位FIN比特置为1；</li>
<li>服务器接收到客户报文段，回送一个确认报文段；</li>
<li>服务器再发送自己的终止报文段，标志位FIN比特置为1；</li>
<li>客户对服务器发送的终止报文段进行确认，之后两台主机上的资源都被释放；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/067.png" alt="image-20201105003343640"></p>
<p><strong>TCP状态</strong>：在一个TCP连接的生命周期内，运行在每台主机上的TCP协议在各种TCP状态中变迁。</p>
<p>客户TCP经历的典型TCP状态：</p>
<ul>
<li>客户TCP开始时处于<code>CLOSED</code>（关闭）状态；</li>
<li>发送过SYN报文段后，客户TCP进入<code>SYN_SENT</code>状态；</li>
<li>收到服务器报文段进行确认且SYN置为1，客户TCP进入<code>ESTABLISHED</code>（已建立）状态，在此状态下，TCP客户就能发送和接收包含有效载荷数据的TCP报文段了；</li>
<li>假设客户应用程序决定关闭该连接，客户TCP发送一个带有FIN比特被置为1的特殊报文段，进入<code>FIN_WAIT_1</code>状态；</li>
<li>客户收到来自服务器TCP的确认报文段，进入<code>FIN_WAIT_2</code>状态；</li>
<li>客户收到来自服务器TCP带有FIN被置为1的特殊报文段，客户TCP对服务器的报文进行确认，并进入<code>TIME_WAIT</code>状态；<ul>
<li>假定客户发送的确认ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文段；</li>
<li>TIME_WAIT状态消耗的时间与具体实现相关，典型的数值是30秒、1分钟、2分钟；</li>
<li>经过这段时间等待后，连接正式关闭，客户端所有资源（包括端口号）将被释放；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/068.png" alt="image-20201105003901345" style="zoom:80%;">



<p>服务器TCP经历的典型TCP状态（假设客户开始终止连接）：</p>
<p>没有描述某些不正常的情形（如当连接的双方同时发起或终止一条连接），具体如图：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/069.png" alt="image-20201105005036960" style="zoom:80%;">



<p>nmap端口扫描工具工作原理：</p>
<ul>
<li>假设探索特定的TCP端口6789，nmap将对那台主机的目的端口6789发送一个特殊的TCP SYN报文段，有三种可能输出：<ul>
<li>源主机从目标主机接收到一个TCP SYNACK报文段，这意味着在目标主机上一个应用程序使用TCP端口6789运行，nmap返回“打开”；</li>
<li>源主机从目标主机接收到一个TCP RST报文段，这意味着该SYN报文段到达了目标主机，但目标主机没有运行一个使用TCP端口为6789的应用程序；</li>
<li>源什么也没收到，这表明该SYN报文可能被中间的防火墙所阻挡，无法到达目标主机；</li>
</ul>
</li>
</ul>
<p>除此之外，扩展一下<strong>SYN洪泛攻击</strong>：</p>
<p>由于服务器在响应客户TCP SYN报文段时会分配并初始化连接变量和缓存，如果某客户不发送ACK来完成该三次握手的第三步，最终（在一分多钟后）服务器将终止该半开连接并回收资源。</p>
<ul>
<li>SYN洪泛攻击：攻击者发送大量的TCP SYN报文段，而不完成第三次握手协议，服务器不断为这些半开连接分配资源（但从未使用），导致服务器的连接资源被消耗殆尽；</li>
<li>SYN cookie：防御SYN洪泛攻击的一种手段，主要实现是服务器不会为SYN报文段的到来生成一个半开连接；</li>
</ul>
<h2 id="6-拥塞控制原理"><a href="#6-拥塞控制原理" class="headerlink" title="6.拥塞控制原理"></a>6.拥塞控制原理</h2><blockquote>
<p>分组重传是网络拥塞的象征，为了处理网络拥塞问题，需要一些机制以在面临网络拥塞时遏制发送方</p>
</blockquote>
<h3 id="6-1-拥塞原因与代价"><a href="#6-1-拥塞原因与代价" class="headerlink" title="6.1 拥塞原因与代价"></a>6.1 拥塞原因与代价</h3><h4 id="6-11-情形一：两个发送方和一台具有无限缓存的路由器"><a href="#6-11-情形一：两个发送方和一台具有无限缓存的路由器" class="headerlink" title="6.11 情形一：两个发送方和一台具有无限缓存的路由器"></a>6.11 情形一：两个发送方和一台具有无限缓存的路由器</h4><p>两台主机（A、B）都有一条连接，且这两条连接共享源与目的地之间的单跳路由：</p>
<ul>
<li>假设主机A、B中的应用程序以**λ<sub>in</sub>**字节每秒的平均速率将数据发送到连接中；</li>
<li>运输层协议使用UDP，不执行差错恢复、流量控制和拥塞控制；</li>
<li>忽略添加运输层和较低层首部的额外开销；</li>
<li>假设路由器缓存无限大；</li>
<li>过程分析：<ul>
<li>来自主机A、B的分组通过一台路由器，在一段容量为R的共享式链路上进行传输；</li>
<li>当分组到达速率超过输出链路的容量时存储“入分组”；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/070.png" alt="image-20201105075324553" style="zoom:80%;">

<p>主机A的连接性能图示：</p>
<ul>
<li>左边的图形描绘了接收方每秒接收的字节数与该连接发送速率之间的函数关系：<ul>
<li>当发送速率在0-R/2之间时，接收方吞吐量等于发送方的发送速率；</li>
<li>当发送速率大于R/2时，吞吐量依然只能达到R/2；</li>
<li>这个吞吐量上限R/2是由两条连接之间共享链路的容量决定的，链路完全不能以超过R/2的稳定状态速率向接收方交付分组；</li>
</ul>
</li>
<li>右边图形描绘了发送速率与时延的函数关系：<ul>
<li>当发送方发送速率接近R/2左右时，其平均时延就会越来越大；</li>
<li>当发送速率超过R/2时，路由器中的排队时延就会无限增大；</li>
</ul>
</li>
<li><strong>拥塞网络代价一</strong>：当分组的到达速率接近链路的容量时，分组会经历巨大的排队时延；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/071.png" alt="image-20201105100811705" style="zoom:80%;">



<h4 id="6-12-情形二：两个发送方和一台具有优先缓存的路由器"><a href="#6-12-情形二：两个发送方和一台具有优先缓存的路由器" class="headerlink" title="6.12 情形二：两个发送方和一台具有优先缓存的路由器"></a>6.12 情形二：两个发送方和一台具有优先缓存的路由器</h4><p>假定路由器缓存有限：</p>
<ul>
<li>分组到达一个已满的缓存时会被丢弃；</li>
<li>假定连接为TCP连接，即连接可靠，分组丢失可以被重传；</li>
<li>应用程序将初始数据以**λ<sub>in</sub>**字节每秒发送到套接字中；</li>
<li>运输层以<strong>λ’<sub>in</sub>**字节每秒向网络层发送报文段，该速率又被称为网络的</strong>供给载荷**；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/072.png" alt="image-20201105101709219" style="zoom:80%;">



<p>理想情况：不丢失分组</p>
<ul>
<li>主机A能够以某种方式确认路由器中的缓存是否空闲，再决定是否发送分组，这时不会产生丢包，<strong>λ<sub>in</sub>=λ’<sub>in</sub>**，连接的吞吐量也等于</strong>λ<sub>in</sub>**；</li>
<li>平均主机发送速率不能超过R/2；</li>
</ul>
<p>实际情况：进行重传</p>
<ul>
<li>供给载荷<strong>λ’<sub>in</sub>=R/2</strong>，此时数据被交付给接收方应用程序的速率为R/3，在所发送的0.5R单位数据中，平均而言，R/3字节每秒是初始数据，R/6字节每秒是重传数据<ul>
<li><strong>拥塞网络代价二</strong>：发送方必须执行重传以补偿因为缓存溢出而丢失的分组；</li>
</ul>
</li>
<li>接收方收到报文段，而发送方可能没能及时接收到ACK报文段，这时发送方重传的报文段数据接收即丢弃<ul>
<li><strong>拥塞网络代价三</strong>：发送方遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组；</li>
<li>图c假定每个分组被路由器平均转发两次时，吞吐量与供给载荷的对比情况：<ul>
<li>当供给载荷接近R/2时，其吞吐量渐进R/4；</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/073.png" alt="image-20201105102525147" style="zoom:80%;">



<h4 id="6-13-情形三：四个发送方和具有有限缓存的多台路由器及多跳链路"><a href="#6-13-情形三：四个发送方和具有有限缓存的多台路由器及多跳链路" class="headerlink" title="6.13 情形三：四个发送方和具有有限缓存的多台路由器及多跳链路"></a>6.13 情形三：四个发送方和具有有限缓存的多台路由器及多跳链路</h4><p>四台主机发送分组，每台都通过交叠的两跳链路传输：</p>
<ul>
<li>假定使用TCP连接，采用超时/重传机制实现可靠传输服务；</li>
<li>所有主机都有相同的**λ<sub>in</sub>**值，所有路由器的链路容量都是R字节每秒；</li>
<li>如图：<ul>
<li>A-C与D-B连接共享路由器R1；</li>
<li>A-C与B-D连接共享路由器R2；</li>
<li>对极小的**λ<sub>in</sub>**而言：<ul>
<li><strong>λ<sub>in</sub>**的增大会导致</strong>λ<sub>out</sub>**的增大</li>
<li>路由器缓存溢出很少；</li>
</ul>
</li>
<li>**λ<sub>in</sub>**（λ’<sub>in</sub>也增长）很大时：<ul>
<li>不管**λ<sub>in</sub>**的值多大，到达路由器R2的A-C流量的到达速率最大是R，这也是R1到R2的链路容量；</li>
<li><strong>λ<sub>in</sub>**很大，</strong>λ’<sub>in</sub>**对于所有连接都很大，那么在R2上，B-D流量的到达速率可能远大于A-C流量的到达速率<ul>
<li>A-C和B-D流量必须参与R2上的链路缓存的竞争；</li>
<li>来自B-D连接的供给载荷越大，A-C连接通过的流量就会越小；</li>
<li>极限情况下，R2的空闲缓存会被B-D连接的分组占满，A-C端到端吞吐量将趋向于0；</li>
<li>此时，第一跳路由器所使用的将分组转发到第二跳路由器的传输容量用来传输不同的分组可能更有效益；</li>
<li><strong>拥塞网络代价四</strong>：当一个分组沿一条路径被丢弃时，每个路由器用于转发该分组到丢弃该分组而使用的传输容量全部浪费了；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/074.png" alt="image-20201105103808051" style="zoom:80%;">



<h3 id="6-2-拥塞控制方法"><a href="#6-2-拥塞控制方法" class="headerlink" title="6.2 拥塞控制方法"></a>6.2 拥塞控制方法</h3><p>两种主要的拥塞控制方法：</p>
<ul>
<li>端到端拥塞控制：网络层不为运输层拥塞控制提供显性支持；</li>
<li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息，拥塞信息从网络反馈到发送方有两种方式：<ul>
<li>经由接收方的网络反馈；</li>
<li>直接网络反馈：<ul>
<li>由网络路由器发送，采用<strong>阻塞分组</strong>的形式；</li>
<li>更通用的是，路由器标记或更新从发送方流向接收方的分组中某个字段来指示拥塞的产生，至少要经过一个完整的往返时间；</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/075.png" alt="image-20201105105809022" style="zoom:80%;">



<h2 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="7.TCP拥塞控制"></a>7.TCP拥塞控制</h2><blockquote>
<p>由于IP层不向端系统提供显式的网络拥塞反馈，TCP必须使用端到端拥塞控制。TCP采用的方法是让每一个发送方根据所感应到的网络拥塞程度来限制其发送速率，但这个方法有三个极为重要的问题：</p>
</blockquote>
<p>问题一：TCP发送方如何限制它向接收方发送的速率？</p>
<ul>
<li>运行在发送端的TCP拥塞控制机制存在一个额外变量<strong>拥塞窗口（cwnd）</strong>，它对一个TCP能向路径上发送的速率进行了限制<ul>
<li><code>LastByteSent - LastByteAcked &lt;= min&#123;cwnd,rwnd&#125;</code>；</li>
<li>假设TCP接收缓存无限大，即可以忽略接收窗口（rwnd）的限制，并且假设发送方一直有数据需要发送，由于发送未确认报文段的存在，所以会限制发送方的发送速率；</li>
<li>考虑一个丢包和发送时延均可忽略不计的连接，在每个往返时间（RTT）的起始点，上述限制条件允许发送方向该连接发送cwnd个字节的数据，在该RTT结束时发送方接收到来自接收方的确认报文段，因此，该发送方的发送速率大概为 <code>cwnd/RTT</code> 字节每秒；</li>
<li>通过调节cwnd的值，发送方能够调节它相连接发送数据的速率；</li>
</ul>
</li>
</ul>
<p>问题二：TCP如何感知从它到目的地之间的路径上存在拥塞？</p>
<ul>
<li><p>将<strong>丢包事件</strong>（拥塞检测）定义为：出现超时，或者收到来自接收方的三个冗余ACK；</p>
</li>
<li><p>考虑网络没有拥塞的情形：</p>
<ul>
<li>TCP的发送方接收到对于以前未确认的报文段的确认，并使用该确认来增加窗口的长度（及其传输速率）；</li>
<li>如果确认以相当慢的速率到达，则该拥塞窗口以相当慢的速率增加，如果确认以高速率到达，则该拥塞窗口的速率快速增加；</li>
<li>由于TCP使用确认来触发增大它的拥塞窗口长度，所以TCP又被称为<strong>自计时</strong>的；</li>
</ul>
</li>
<li><p>TCP又应该怎样确定它应该以怎样的速率发送数据呢？</p>
<ul>
<li>一个丢失的报文段意味着拥塞，因此当丢失报文段时应该降低其发送速率；</li>
<li>一个确认报文段指示网路正在向接收方交付发送方的报文段，因此当到达一个未确认的确认报文段，增加其发送速率；</li>
<li>带宽探测：TCP调节其传输速率的策略是增加其速率以响应到达的ACK，仅出现丢包事件时，才减小发送速率；</li>
</ul>
</li>
</ul>
<p>问题三：当发送端感知到拥塞，又采用何种算法来改变其发送速率？</p>
<ul>
<li><strong>TCP拥塞控制算法</strong>：<ul>
<li>慢启动；</li>
<li>拥塞避免；</li>
<li>快速恢复；</li>
</ul>
</li>
</ul>
<p>其中，慢启动和拥塞避免是TCP强制必需部分，而快速恢复则只是推荐而非必需。</p>
<h3 id="7-01-慢启动"><a href="#7-01-慢启动" class="headerlink" title="7.01 慢启动"></a>7.01 慢启动</h3><blockquote>
<p>一条TCP连接开始时，cwnd的值通常初始化为一个MSS的较小值，初始发送速率约为MSS/RTT，例如MSS=500字节，RTT=200ms，则初始速率约为20kbps，这个速率相较于带宽而言要小得多</p>
</blockquote>
<p><strong>慢启动状态</strong>：cwnd的值以一个MSS开始并且每当报文段首次被确认就增加一个MSS（是发送方对每个确认报文段给拥塞窗口增加一个MSS，即呈指数增长），如图：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/076.png" alt="image-20201105215713739" style="zoom:80%;">

<p>何时结束慢启动状态呢？</p>
<ul>
<li>如果出现超时丢包事件，TCP发送方将cwnd设置为1并重新启动慢启动过程，还将第二个状态变量<code>ssthresh</code>的值设置为cwnd/2；</li>
<li>当cwnd的值等于ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式；</li>
<li>检测到三个冗余ACK时，TCP执行快速重传并进入快速恢复状态；</li>
</ul>
<p>以下是TCP拥塞控制算法的完整FSM描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/077.png" alt="image-20201105220553024"></p>
<h3 id="7-02-拥塞避免"><a href="#7-02-拥塞避免" class="headerlink" title="7.02 拥塞避免"></a>7.02 拥塞避免</h3><blockquote>
<p>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时值的一半。收到确认时，TCP也不会再每过一个RTT将cwnd的值翻番，而是每个RTT只将cwnd的值增加一个MSS</p>
</blockquote>
<p>何时结束拥塞避免的线性增长？</p>
<ul>
<li>出现丢包时，TCP将ssthresh的值记录为cwnd值的一半；</li>
<li>收到三个冗余ACK时，TCP将cwnd的值减半（但是收到的三个冗余ACK还是会线性增加三个MSS），再将ssthresh的值记录为cwnd值的一半，并且接下来进入快速恢复状态；</li>
</ul>
<h3 id="7-03-快速恢复"><a href="#7-03-快速恢复" class="headerlink" title="7.03 快速恢复"></a>7.03 快速恢复</h3><ul>
<li>进入快速恢复状态，重传之后当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态；</li>
<li>出现超时丢包事件，cwnd的值被设置为1个MSS，并将ssthresh的值设置为cwnd值的一半，并迁移到慢启动状态；</li>
</ul>
<h3 id="7-04-回顾TCP拥塞控制"><a href="#7-04-回顾TCP拥塞控制" class="headerlink" title="7.04 回顾TCP拥塞控制"></a>7.04 回顾TCP拥塞控制</h3><p>忽略一条TCP连接的初始慢启动阶段，考虑正常运行的一般状态，即拥塞避免时：</p>
<ul>
<li>此时TCP拥塞控制是：每个RTT内cwnd线性增加1MSS，出现3个冗余ACK时cwnd减半，这种拥塞控制又被称为<strong>加性增、乘性减（AIMD）</strong>；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/078.png" alt="image-20201105223325409" style="zoom:80%;">



<h3 id="7-05-对TCP吞吐量的宏观描述"><a href="#7-05-对TCP吞吐量的宏观描述" class="headerlink" title="7.05 对TCP吞吐量的宏观描述"></a>7.05 对TCP吞吐量的宏观描述</h3><p>对于TCP的锯齿状行为，考虑一个存活期长的TCP连接的平均吞吐量（忽略短暂的慢启动阶段）：</p>
<ul>
<li>在一个特定的往返间隔内，窗口长度为W字节，往返时间为RTT秒，TCP发送速率约为W/RTT；</li>
<li>TCP每经过1个RTT将为W增加一个MSS，直到发送丢包事件，并如此往复；</li>
<li>假设在持续连接期间RTT和W保持不变，那么TCP的传输速率在W/(2×RTT)到W/RTT之间；</li>
<li>这条假设导出TCP稳态行为高度简化的宏观模型：<ul>
<li>当速率增长到W/RTT时，网络丢弃来自连接的分组，发送速率减半，进而没过一个RTT发送速率就增加MSS/RTT，直到再次到达W/RTT，重复过程；</li>
<li>一条连接的平均吞吐量=0.75×W/RTT；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络自顶向下方法</category>
      </categories>
      <tags>
        <tag>计算机网络自顶向下方法</tag>
        <tag>理论学习</tag>
        <tag>教材</tag>
      </tags>
  </entry>
</search>
