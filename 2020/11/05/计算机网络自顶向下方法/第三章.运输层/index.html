<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/MuyunHui.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/MuyunHui.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/MuyunHui.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css">
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kunpw.cn","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="1.运输层概述 运输层服务过程：在发送端（端系统），运输层将从发送端应用程序进程接收到的报文转换为运输层分组（报文段），进而传递给网络层，网络层将其封装成网络层分组（数据报）并向目的地发送；在接收端（端系统），网络层从数据报中提取运输层报文段，并根据该报文段（应用程序决定使用哪一个运输层协议）上交给运输层。  1.1 运输层和网络层的关系 网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络自顶向下方法学习笔记（三）运输层">
<meta property="og:url" content="http://kunpw.cn/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="朝小闇的博客">
<meta property="og:description" content="1.运输层概述 运输层服务过程：在发送端（端系统），运输层将从发送端应用程序进程接收到的报文转换为运输层分组（报文段），进而传递给网络层，网络层将其封装成网络层分组（数据报）并向目的地发送；在接收端（端系统），网络层从数据报中提取运输层报文段，并根据该报文段（应用程序决定使用哪一个运输层协议）上交给运输层。  1.1 运输层和网络层的关系 网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/034.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/035.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/036.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/037.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/038.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/039.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/041.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/042.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/044.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/046.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/047.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/048.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/049.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/050.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/051.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/052.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/053.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/057.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/059.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/060.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/061.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/062.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/063.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/064.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/065.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/066.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/067.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/068.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/069.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/070.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/071.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/072.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/073.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/074.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/075.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/076.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/077.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/078.png">
<meta property="article:published_time" content="2020-11-05T14:54:05.891Z">
<meta property="article:modified_time" content="2020-11-05T14:57:18.355Z">
<meta property="article:author" content="Zhaoxiaoan">
<meta property="article:tag" content="计算机网络自顶向下方法">
<meta property="article:tag" content="理论学习">
<meta property="article:tag" content="教材">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/034.png">


<link rel="canonical" href="http://kunpw.cn/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络自顶向下方法学习笔记（三）运输层 | 朝小闇的博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  
	<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

<link rel="alternate" href="/atom.xml" title="朝小闇的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">朝小闇的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">海上月是天上月，眼前人是心上人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-essays">

    <a href="/essays" rel="section"><i class="fa fa-heart fa-fw"></i>随笔</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="nav-text">1.运输层概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">1.1 运输层和网络层的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%9B%A0%E7%89%B9%E7%BD%91%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="nav-text">1.2 因特网运输层概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="nav-text">2.多路复用和多路分解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8F%8A%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%EF%BC%88UDP%EF%BC%89"><span class="nav-text">2.1 无连接的多路复用及多路分解（UDP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8F%8A%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%EF%BC%88TCP%EF%BC%89"><span class="nav-text">2.2 面向连接的多路复用及多路分解（TCP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CTCP"><span class="nav-text">2.3 Web服务器和TCP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%97%A0%E8%BF%9E%E6%8E%A5%E8%BF%90%E8%BE%93%EF%BC%9AUDP"><span class="nav-text">3.无连接运输：UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="nav-text">3.1 UDP报文段结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-UDP%E6%A3%80%E9%AA%8C%E5%92%8C"><span class="nav-text">3.2 UDP检验和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86"><span class="nav-text">4.可靠数据传输原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%9E%84%E9%80%A0%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-text">4.1 构造可靠数据传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-%E7%BB%8F%E5%AE%8C%E5%85%A8%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9Ardt1-0"><span class="nav-text">4.11 经完全可靠信道的可靠数据传输：rdt1.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-12-%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E8%BF%90%E8%BE%93%EF%BC%9Ardt2-0"><span class="nav-text">4.12 经具有比特差错信道的可靠数据运输：rdt2.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-13-%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E7%9A%84%E4%B8%A2%E5%8C%85%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9Ardt3-0"><span class="nav-text">4.13 经具有比特差错的丢包信道的可靠数据传输：rdt3.0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-text">4.2 流水线可靠数据传输协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%9B%9E%E9%80%80N%E6%AD%A5%EF%BC%88GBN%EF%BC%89"><span class="nav-text">4.3 回退N步（GBN）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%EF%BC%88SR%EF%BC%89"><span class="nav-text">4.4 选择重传（SR）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%90%E8%BE%93%EF%BC%9ATCP"><span class="nav-text">5 面向连接的运输：TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-TCP%E8%BF%9E%E6%8E%A5"><span class="nav-text">5.1 TCP连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="nav-text">5.2 TCP报文段结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-21-%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="nav-text">5.21 序号和确认号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-22-%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B"><span class="nav-text">5.22 序号和确认号的一个学习案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%B0%E8%AE%A1%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="nav-text">5.3 往返时间的估计与超时</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-31-%E4%BC%B0%E8%AE%A1%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4"><span class="nav-text">5.31 估计往返时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-32-%E8%AE%BE%E7%BD%AE%E5%92%8C%E7%AE%A1%E7%90%86%E9%87%8D%E4%BC%A0%E8%B6%85%E6%97%B6%E9%97%B4%E9%9A%94"><span class="nav-text">5.32 设置和管理重传超时间隔</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text">5.4 可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-41-%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2"><span class="nav-text">5.41 简化模型特殊情形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-42-%E8%B6%85%E6%97%B6%E9%97%B4%E9%9A%94%E5%8A%A0%E5%80%8D"><span class="nav-text">5.42 超时间隔加倍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-43-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-text">5.43 快速重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-44-%E6%98%AF%E5%9B%9E%E9%80%80N%E6%AD%A5%E8%BF%98%E6%98%AF%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0"><span class="nav-text">5.44 是回退N步还是选择重传</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">5.5 流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text">5.6 TCP连接管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-text">6.拥塞控制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%8B%A5%E5%A1%9E%E5%8E%9F%E5%9B%A0%E4%B8%8E%E4%BB%A3%E4%BB%B7"><span class="nav-text">6.1 拥塞原因与代价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-11-%E6%83%85%E5%BD%A2%E4%B8%80%EF%BC%9A%E4%B8%A4%E4%B8%AA%E5%8F%91%E9%80%81%E6%96%B9%E5%92%8C%E4%B8%80%E5%8F%B0%E5%85%B7%E6%9C%89%E6%97%A0%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="nav-text">6.11 情形一：两个发送方和一台具有无限缓存的路由器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-12-%E6%83%85%E5%BD%A2%E4%BA%8C%EF%BC%9A%E4%B8%A4%E4%B8%AA%E5%8F%91%E9%80%81%E6%96%B9%E5%92%8C%E4%B8%80%E5%8F%B0%E5%85%B7%E6%9C%89%E4%BC%98%E5%85%88%E7%BC%93%E5%AD%98%E7%9A%84%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="nav-text">6.12 情形二：两个发送方和一台具有优先缓存的路由器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-13-%E6%83%85%E5%BD%A2%E4%B8%89%EF%BC%9A%E5%9B%9B%E4%B8%AA%E5%8F%91%E9%80%81%E6%96%B9%E5%92%8C%E5%85%B7%E6%9C%89%E6%9C%89%E9%99%90%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%9A%E5%8F%B0%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%8A%E5%A4%9A%E8%B7%B3%E9%93%BE%E8%B7%AF"><span class="nav-text">6.13 情形三：四个发送方和具有有限缓存的多台路由器及多跳链路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-text">6.2 拥塞控制方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">7.TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-01-%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-text">7.01 慢启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-02-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-text">7.02 拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-03-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="nav-text">7.03 快速恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-04-%E5%9B%9E%E9%A1%BETCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">7.04 回顾TCP拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-05-%E5%AF%B9TCP%E5%90%9E%E5%90%90%E9%87%8F%E7%9A%84%E5%AE%8F%E8%A7%82%E6%8F%8F%E8%BF%B0"><span class="nav-text">7.05 对TCP吞吐量的宏观描述</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhaoxiaoan"
      src="/images/PubuLan.png">
  <p class="site-author-name" itemprop="name">Zhaoxiaoan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>


  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ZHAOXIAOAN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZHAOXIAOAN" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0.%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/" title="计算机网络自顶向下方法学习笔记（四）网络层：数据平面" target="_blank">计算机网络自顶向下方法学习笔记（四）网络层：数据平面</a>
          </li>
        
          <li>
            <a href="/2020/11/14/Python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="使用Python数据分析遇到的部分问题" target="_blank">使用Python数据分析遇到的部分问题</a>
          </li>
        
          <li>
            <a href="/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/" title="计算机网络自顶向下方法学习笔记（三）运输层" target="_blank">计算机网络自顶向下方法学习笔记（三）运输层</a>
          </li>
        
          <li>
            <a href="/2020/10/23/SpringBoot/SpringBoot%EF%BC%88%E4%B8%80%EF%BC%89/" title="SpringBoot(一)" target="_blank">SpringBoot(一)</a>
          </li>
        
          <li>
            <a href="/2020/10/23/java/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" title="注解和反射" target="_blank">注解和反射</a>
          </li>
        
      </ul>
    </div>


      </section><div>
  <canvas id="canvasDiyBlock" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas><script src="/js/custom/clock.js"></script>
</div>


    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kunpw.cn/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/PubuLan.png">
      <meta itemprop="name" content="Zhaoxiaoan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝小闇的博客">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络自顶向下方法学习笔记（三）运输层
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-11-05 22:54:05 / 修改时间：22:57:18" itemprop="dateCreated datePublished" datetime="2020-11-05T22:54:05+08:00">2020-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">计算机网络自顶向下方法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="1-运输层概述"><a href="#1-运输层概述" class="headerlink" title="1.运输层概述"></a>1.运输层概述</h2><blockquote>
<p>运输层服务过程：在发送端（端系统），运输层将从发送端应用程序进程接收到的报文转换为运输层分组（报文段），进而传递给网络层，网络层将其封装成网络层分组（数据报）并向目的地发送；在接收端（端系统），网络层从数据报中提取运输层报文段，并根据该报文段（应用程序决定使用哪一个运输层协议）上交给运输层。</p>
</blockquote>
<h3 id="1-1-运输层和网络层的关系"><a href="#1-1-运输层和网络层的关系" class="headerlink" title="1.1 运输层和网络层的关系"></a>1.1 运输层和网络层的关系</h3><blockquote>
<p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供逻辑通信</p>
</blockquote>
<h3 id="1-2-因特网运输层概述"><a href="#1-2-因特网运输层概述" class="headerlink" title="1.2 因特网运输层概述"></a>1.2 因特网运输层概述</h3><p>因特网提供两种运输层协议：</p>
<ul>
<li>UDP：用户数据报协议，为应用程序提供不可靠、无连接的服务；</li>
<li>TCP：传输控制协议，为应用程序提供可靠的、面向连接的服务，除此之外提供附加服务：<ul>
<li>可靠数据传输服务，通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程；</li>
<li>拥塞控制服务，通过调节TCP连接的发送端发送进入网络的流量速率来防止任何一条TCP连接占用过多带宽；</li>
</ul>
</li>
<li>UDP和TCP最基本的功能是将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务，即应用层只考虑进程交互，而不必关心这两个进程的具体位置；<ul>
<li>该基本服务被称为运输层的<strong>多路复用</strong>和<strong>多路分解</strong>；</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2.多路复用和多路分解"></a>2.多路复用和多路分解</h2><ul>
<li><p>多路分解：在一个接收端将运输层报文段中的数据交付到正确的套接字的过程就是一次分解，每一个进程拥有一个或多个套接字，使用一个标识符特定申明其为TCP或UDP套接字，套接字收到报文段传输给自己的数据之后再传输给它所属的进程；</p>
</li>
<li><p>多路复用：在源主机上，从不同的套接字中收集数据块，并为每个数据块封装首部信息从而生成报文段，然后将报文段传递到网络层的整个过程；</p>
</li>
<li><p>报文段通过端口号字段标识需要交付的套接字：</p>
<ul>
<li>该特殊字段分为源端口号和目的端口号字段，每一个端口号是一个16比特的数，大小在0~65535之间：<ul>
<li>0~1023是周知端口号，这是受限制的，计算机主机保留给HTTP（80端口号）、FTP（21端口号）之类的周知应用层协议来使用的；</li>
<li>我们开发一个新的应用程序时，必须为其分配一个端口号，而主机上的每个套接字分配一个端口号；</li>
<li>运输层通过检查报文段中的目的端口号，将其定向到相应的套接字，然后报文段中的数据通过套接字进入其所连接的进程；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/034.png" alt="image-20201101143437667"></p>
</li>
</ul>
<h3 id="2-1-无连接的多路复用及多路分解（UDP）"><a href="#2-1-无连接的多路复用及多路分解（UDP）" class="headerlink" title="2.1 无连接的多路复用及多路分解（UDP）"></a>2.1 无连接的多路复用及多路分解（UDP）</h3><p>以整个过程为例解释说明：</p>
<ol>
<li>主机运行的程序创建一个UDP套接字，创建时运输层会从1024~65535范围内自动分配一个当前未被使用的端口号；</li>
<li>可以关联特定端口号，如果应用程序开发者所编写的代码实现的是一个周知协议的服务器端，则分配一个相应的周知端口号，通常，应用程序的客户端让运输层自动分配端口号，而服务器端则分配一个固定的端口号；</li>
<li>假定主机A上正在运行的进程具有UDP端口12345，需要发送数据给主机B上另一个具有UDP端口23456的进程；</li>
<li>主机A运输层创建一个运输层报文段，包括数据、源端口号（12345）、目的端口号（23456）和其它值；</li>
<li>运输层将得到的报文段传递到网络层；</li>
<li>网络层将该报文段封装在一个IP数据报中，并交付给接收主机B；</li>
<li>该报文段到达接收主机B，接收主机运输层检查报文段中的目的端口号（23456）并将该报文段交付给端口号23456所标识的套接字，注意：一个UDP套接字由二元组（目的IP地址，目的端口号）唯一标识，因此，如果两个UDP报文段有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程；</li>
<li>当B需要回发一个报文段给A时，就取用源报文段的源端口号作为新报文段的目的端口号；</li>
</ol>
<h3 id="2-2-面向连接的多路复用及多路分解（TCP）"><a href="#2-2-面向连接的多路复用及多路分解（TCP）" class="headerlink" title="2.2 面向连接的多路复用及多路分解（TCP）"></a>2.2 面向连接的多路复用及多路分解（TCP）</h3><blockquote>
<p>TCP套接字由四元组（源端口号、源IP地址、目的端口号、目的IP地址）唯一标识，当一个源主机向目的主机发送一个连接报文段请求TCP连接时，目的主机会根据该报文段中源端口号、源IP地址、目的端口号、目的IP地址创建一个TCP连接套接字，并在其四元组中通过这四个值来标识，之后到达的数据报文段只有四元组全部匹配才会被定向到该报文段，即一个套接字只与一个特定的进程联系</p>
</blockquote>
<h3 id="2-3-Web服务器和TCP"><a href="#2-3-Web服务器和TCP" class="headerlink" title="2.3 Web服务器和TCP"></a>2.3 Web服务器和TCP</h3><blockquote>
<p>一台Web服务器为每条连接生成一个新进程，每个进程都拥有自己的连接套接字，通过这些套接字可以接收到HTTP请求和发送HTTP响应</p>
</blockquote>
<p>连接套接字和进程之间并非总是一一对应，现在的高性能Web服务器只使用一个进程，但为每个新客户创建一个具有新连接套接字的新线程（线程可看做轻量级的子进程），对于这样一台服务器而言，套接字和进程就不是一一对应的。</p>
<ul>
<li>如果客户和服务器使用持续HTTP，则在整条连接持续期间，客户与服务器之间经由一个服务器套接字交换HTTP报文；</li>
<li>如果使用非持续HTTP，则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，这种套接字的频繁创建和关闭会严重影响一个繁忙的Web服务器的性能；</li>
</ul>
<h2 id="3-无连接运输：UDP"><a href="#3-无连接运输：UDP" class="headerlink" title="3.无连接运输：UDP"></a>3.无连接运输：UDP</h2><blockquote>
<p>UDP除了实现复用和分解功能及少量的差错检测外，几乎没有对IP增加别的东西，应用程序几乎时直接和IP协议打交道</p>
</blockquote>
<p>UDP优点：</p>
<ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细：<ul>
<li>只要应用进程将数据传输给UDP，UDP就会将其打包进入UDP报文段并立即发送给网络层；</li>
<li>而TCP拥塞机制不管可靠交付的时间，在拥塞时会自动延迟报文段的传送；</li>
</ul>
</li>
<li>无需建立连接：<ul>
<li>UDP不会引入建立连接的时延；</li>
<li>而TCP会在数据传输之前进行三次握手协议；</li>
</ul>
</li>
<li>无连接状态：<ul>
<li>TCP需要在端系统中维护一系列连接状态；</li>
<li>UDP不维护连接状态也不跟踪参数，当应用程序运行在UDP上时服务器能支持更多的活跃客户；</li>
</ul>
</li>
<li>分组首部开销小：<ul>
<li>每个TCP报文段有20字节的首部开销，而UDP只有8字节的首部开销；</li>
</ul>
</li>
</ul>
<p>如图所示：</p>
<ul>
<li>电子邮件、远程终端访问、Web及文件传输都运行在TCP协议上，因为它们都需要TCP的可靠传输服务；</li>
<li>UDP用于：<ul>
<li>承载网络管理数据，网络管理应用程序通常必须在网络重压状态时运行，而这个时候可靠的拥塞控制的数据传输难以实现；</li>
<li>多媒体应用程序，但在UDP上运行多媒体应用具有争议，因为没有拥塞控制，那么当很多人都启用流式高比特视频而不使用任何拥塞控制则会使得路由器中大量分组溢出，以至于非常少的UDP分组能够到达目的主机；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/035.png" alt="image-20201101160411184"></p>
<h3 id="3-1-UDP报文段结构"><a href="#3-1-UDP报文段结构" class="headerlink" title="3.1 UDP报文段结构"></a>3.1 UDP报文段结构</h3><p>如图所示：</p>
<ul>
<li>长度字段：指示了在UDP报文段中的字节数（首部加数据）；</li>
<li>检验和：接收方使用检验和来检查该报文段是否出现了差错；</li>
<li>首部四个字段，每个字段由两个字节组成；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/036.png" alt="image-20201101161512050"></p>
<h3 id="3-2-UDP检验和"><a href="#3-2-UDP检验和" class="headerlink" title="3.2 UDP检验和"></a>3.2 UDP检验和</h3><blockquote>
<p>UDP检验和提供了差错检测功能，用于确定当UDP报文段从源到达目的地移动时，其中比特是否发生变化</p>
</blockquote>
<ul>
<li>检验和计算过程：发送方的UDP对报文段中所有16比特的和进行反码运算，求和时遇到的任何溢出都回卷，得到的结果被放在UDP报文段中的检验和字段；</li>
</ul>
<p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/037.png" alt="image-20201101162908522"></p>
<ul>
<li>注意最后一次求和时高位比特有溢出现象，需要回卷到低位比特；</li>
<li>反码运算得<code>1011010100111101</code>，这个值就是检验和的值；</li>
<li>在接收方，全部的四个16比特的和比特必须全为1，如果比特之一为0，则分组中出现了差错；</li>
<li>虽然UDP提供差错检测，但它对差错恢复无能为力，一般措施是丢弃或者交给应用程序并给出警告；</li>
</ul>
<ul>
<li>端到端原则：某种功能必须基于端到端实现，如此时的差错检验；</li>
</ul>
<h2 id="4-可靠数据传输原理"><a href="#4-可靠数据传输原理" class="headerlink" title="4.可靠数据传输原理"></a>4.可靠数据传输原理</h2><blockquote>
<p>由于可靠数据传输的实现问题不仅出现在运输层，也会出现在链路层和应用层，其下层协议未必可靠，因此需要实现可靠传输，这里假定底层信道只能丢失分组而不会对分组进行重排（即<strong>顺序到达</strong>）。且本节仅考虑单向数据传输，即数据传输是从发送端到接收端的，但对于协议而言需要在发送端和接收端两个方向上传输分组。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/038.png" alt="image-20201102183101917" style="zoom:80%;">

<ul>
<li>其中<code>udt</code>表示不可靠数据传输，<code>rdt</code>表示可靠数据传输；</li>
</ul>
<h3 id="4-1-构造可靠数据传输协议"><a href="#4-1-构造可靠数据传输协议" class="headerlink" title="4.1 构造可靠数据传输协议"></a>4.1 构造可靠数据传输协议</h3><h4 id="4-11-经完全可靠信道的可靠数据传输：rdt1-0"><a href="#4-11-经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="4.11 经完全可靠信道的可靠数据传输：rdt1.0"></a>4.11 经完全可靠信道的可靠数据传输：rdt1.0</h4><blockquote>
<p>假定底层信道完全可靠情形</p>
</blockquote>
<p>看到如图所示rdt1.0发送方和接收方有限状态机（FSM）：</p>
<ul>
<li>圆框中为状态；</li>
<li>箭头指示协议从一个状态变迁到另一个状态；</li>
<li>横线上方指示引起变迁的事件；</li>
<li>横线下方指示事件发生时采取的动作，如果没有事件或动作则分别使用符号<code>Λ</code>表示；</li>
<li>虚线表示FSM的初始状态；</li>
<li>rdt1.0过程如下：<ul>
<li>在发送端，从初始状态【等待来自上层的调用】出发，通过<code>rdt_send(data)</code>事件接收来自较高层的数据，实质上<code>rdt_send(data)</code>事件是由较高层应用的过程调用产生的；</li>
<li>由<code>make_pkt(data)</code>动作产生一个分组<code>packet</code>，并通过<code>udt_send(packet)</code>将分组发送到信道中；</li>
<li>经过事件和动作后状态变迁，重回【等待来自上层的调用】状态；</li>
<li>在接收端，从初始状态【等待来自下层的调用】出发，<code>rdt</code>通过<code>rdt_rcv(packet)</code>事件从较低层信道接收一个分组，该事件由较低层协议的过程调用产生；</li>
<li>经过<code>extract(packet,data)</code>动作从分组中取出数据，并通过<code>deliver_data(data)</code>将数据上传给较高层；</li>
<li>经过事件和动作后状态变迁，重回【等待来自下层的调用】状态；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/039.png" alt="image-20201102183921310"></p>
<h4 id="4-12-经具有比特差错信道的可靠数据运输：rdt2-0"><a href="#4-12-经具有比特差错信道的可靠数据运输：rdt2-0" class="headerlink" title="4.12 经具有比特差错信道的可靠数据运输：rdt2.0"></a>4.12 经具有比特差错信道的可靠数据运输：rdt2.0</h4><blockquote>
<p>假定底层信道可能出现比特受损（不丢失分组）情形</p>
</blockquote>
<p>自动重传请求协议（ARQ）：基于报文肯定确认或否定确认反馈并进行重传的可靠数据传输协议。</p>
<p>ARQ协议需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li>差错检测；</li>
<li>接收方反馈；</li>
<li>重传；</li>
</ul>
<p>rdt2.0 FSM图示：</p>
<ul>
<li>使用检验和进行检验；</li>
<li>使用了停等协议，没有收到ACK肯定确认之前一直停等或重传；</li>
<li>该版本协议具有致命缺陷：ACK/NAK可能受损！</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/040.png" alt="image-20201102190427731" style="zoom:80%;">



<p>rdt2.1 FSM图示：</p>
<ul>
<li>使用一个比特位字段来存放序号，分组确认完整发送后变换序号，该序号是用来解决发送方未正确接收到肯定确认时进行重传引起的冗余分组；</li>
<li>协议状态反映出目前正发送的分组或希望接收的分组序号；</li>
<li>两种接收状态：<ul>
<li>接收到和上次不同序号的分组时，接收方发送肯定确认ACK；</li>
<li>接收到受损的分组，接收方发送一个否定确认NAK；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/041.png" alt="image-20201102191720662" style="zoom:70%;">



<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/042.png" alt="image-20201102191748791" style="zoom:70%;">



<p>rdt2.2 FSM图示：</p>
<ul>
<li>在2.1的基础上实现无NAK的可靠数据传输协议：<ul>
<li>接收到受损分组，接收方对上次正确接收的分组发送一个ACK，即实现NAK功能；</li>
<li>实现方法是在返回确认时增加参数分组序号，返回ACK 0或ACK 1；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/043.png" alt="image-20201102194613476" style="zoom:70%;">



<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/044.png" alt="image-20201102194631080" style="zoom:70%;">



<h4 id="4-13-经具有比特差错的丢包信道的可靠数据传输：rdt3-0"><a href="#4-13-经具有比特差错的丢包信道的可靠数据传输：rdt3-0" class="headerlink" title="4.13 经具有比特差错的丢包信道的可靠数据传输：rdt3.0"></a>4.13 经具有比特差错的丢包信道的可靠数据传输：rdt3.0</h4><blockquote>
<p>假定底层信道传输时比特可能受损也可能丢包情形</p>
</blockquote>
<p>两个问题：怎样检测丢包以及发生丢包后应该采取什么措施。</p>
<p>倒计数定时器：</p>
<ul>
<li>每次发送一个分组（包括第一次分组和重传分组）时，就启动一个定时器；</li>
<li>响应定时器中断并采取动作；</li>
<li>终止定时器；</li>
<li>发送方通过定时器进行等待，一旦定时器中断，就采用重传操作，有效解决两个问题；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/045.png" alt="image-20201103074201864" style="zoom:80%;">



<p>由于分组序号在0和1之间交替，rdt3.0又被称作比特交替协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/046.png" alt="image-20201103074248098"></p>
<h3 id="4-2-流水线可靠数据传输协议"><a href="#4-2-流水线可靠数据传输协议" class="headerlink" title="4.2 流水线可靠数据传输协议"></a>4.2 流水线可靠数据传输协议</h3><blockquote>
<p>rdt3.0协议的核心问题在于它是一个停等协议，虽然功能正确，但并不能运用到实际问题中，否则发送方信道的<strong>利用率</strong>会极低。因此提出一个简单的解决方案：不以停等方式运行，允许发送方发送多个分组而无需等待确认，这种技术被称作<strong>流水线</strong>。</p>
</blockquote>
<p>流水线操作：</p>
<ul>
<li>增加序号范围，每个输送中的分组必须有唯一的序号，也有多个在输送中的未确认报文；</li>
<li>协议的发送方和接收方缓存多个分组，最低限度要缓存已发送但未确认的分组，或许还要缓存一些已正确接收的分组；</li>
<li>所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</li>
<li>解决流水线差错恢复两种方式：<ul>
<li>回退N步；</li>
<li>选择重传；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/047.png" alt="image-20201103075310783"></p>
<h3 id="4-3-回退N步（GBN）"><a href="#4-3-回退N步（GBN）" class="headerlink" title="4.3 回退N步（GBN）"></a>4.3 回退N步（GBN）</h3><blockquote>
<p>允许发送方发送多个分组而不需要等待确认，其中未确认的分组数不能超过某个最大允许数N，N常被称作<strong>窗口长度</strong>，GBN协议也被称为<strong>滑动窗口协议</strong>，解决了停等协议中利用率低的问题</p>
</blockquote>
<p>序号：</p>
<ul>
<li>基序号（base）：最早未确认分组的序号；</li>
<li>下一个序号（nextseqnum）：最小的未使用序号；</li>
<li>序号范围：<ul>
<li>[0，base-1]段对应已发送并已被确认的分组；</li>
<li>[base，nextseqnum-1]段对应已发送尚未确认的分组；</li>
<li>[nextseqnum，base+N-1]段对应将要被发送的分组序号；</li>
<li>[base+N+1~]段需要到当前未被确认的分组得到确认为止才能使用；</li>
<li>一个序号承载在分组首部的一个固定长度字段中，序号空间看成长度为2<sup>k</sup>的闭环，序号2<sup>k</sup>-1紧接着序号0；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/048.png" alt="image-20201103084832055"></p>
<p>提出问题：为什么不能将有限N转换为无限呢？</p>
<ul>
<li>流量控制是原因之一；</li>
</ul>
<p>扩展FSM：</p>
<ul>
<li>基于ACK、无NAK的GBN协议的发送方和接收方的FSM描述，增加了变量base和nextseqnum；</li>
<li>GBN发送方必须响应三中类型的事件：<ul>
<li>上层调用：<ul>
<li>上层直接调用<code>rdt_send()</code>，发送方检查自身发送窗口是否已满：<ul>
<li>未满则产生分组并将其发送，并相应地更新变量；</li>
<li>已满则将数据返回给上层，隐式地指示上层该窗口已满；</li>
</ul>
</li>
<li>使用同步机制（信号量或标识），允许上层在仅当窗口不满时才可调用<code>rdt_send()</code>；</li>
<li>缓存而并不立刻发送该分组；</li>
</ul>
</li>
<li>收到一个ACK：<ul>
<li>正常<strong>累积确认</strong>，对序号为n的分组发送ACK，表明接收方已正确接收到序号为n及以前的未确认的所有分组；</li>
<li>对于收到失序（即丢包）、受损的分组，接收方发送上一次序号ACK，表示请求重传上一次序号之后的所有未确认分组；</li>
</ul>
</li>
<li>超时事件：<ul>
<li>对于最早未确认分组（base序号）使用一个定时器，如果丢失或者时延过长则重传所有未确认分组，并重新启动定时器；</li>
</ul>
</li>
</ul>
</li>
<li>GBN接收方：<ul>
<li>接收到失序或受损分组时丢弃该分组并发送上一次序号ACK；</li>
<li>直接对已正确接收的分组发送ACK；</li>
<li>丢弃所有失序分组：<ul>
<li>优点：接收缓存简单，接收方不需要缓存任何失序分组，只需要维护下一个按序接收的分组序号并将其值存于<code>expectedseqnum</code>变量中；</li>
<li>缺点：随后对该分组的重传也许会丢失会出错，即可能需要更多次的重传；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/049.png" alt="image-20201103090002171"></p>
<p>实例：窗口长度N为4的GBN协议运行情况：</p>
<ol>
<li>由于窗口长度限制，发送方只能先发送0~3序号的分组，然后进行等待；</li>
<li>接收到连续的ACK 0和ACK 1 之后才能继续发送序号为4和5的分组；</li>
<li>接收方分组2丢失，因此分组序号3、4、5被发现是失序分组并被丢弃，接收方重新发送ACK 1；</li>
<li>发送方重传分组2、3、4、5；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/050.png" alt="image-20201103092101884"></p>
<h3 id="4-4-选择重传（SR）"><a href="#4-4-选择重传（SR）" class="headerlink" title="4.4 选择重传（SR）"></a>4.4 选择重传（SR）</h3><blockquote>
<p>当窗口长度和带宽延时都很大时，流水线中分组过多，GBN对于单个分组的差错而引起的重传大量分组则显得极为过分，选择重传基于解决这部分问题而设置。SR通过让发送方仅重传那些可能出错的分组而避免不必要的重传，而这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。</p>
</blockquote>
<p>序号空间：</p>
<ul>
<li>使用窗口长度N限制流水线中未完成未被确认的分组数，但发送方能够收到窗口中某些分组的ACK；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/051.png" alt="image-20201103093226708"></p>
<p>SR发送方采取的动作：</p>
<ul>
<li>从上层收到数据：从上层接收到数据后，SR发送方检查下一个可用分组的序号，该序号位于发送方的窗口内部时将数据打包发送，否则和GBN相同处理；</li>
<li>超时：使用定时器防止分组丢失，但是是每个分组都需要拥有自己的逻辑定时器；</li>
<li>收到ACK：收到ACK时，若分组序号在窗口内，则将该序号分组标记为已接收；若序号等于<code>send_base</code>，则窗口基序号向前移动到最小序号的未接收分组处；如果窗口移动了而此时又有序号位于窗口内的未发送分组，则发送这些新分组；</li>
</ul>
<p>SR接收方采取的动作：SR接收方将确认一个正确接收的分组而不管其是否失序，如果失序则缓存直到所有丢失分组都被收到时统一交付给上层</p>
<ul>
<li>序号在[rcv_base，rcv_base+N-1]范围内的分组被正确接收：收到的分组落在接收方的窗口内，接收方发送回一个该序号的ACK<ul>
<li>如果该分组以前没有收到过，则缓存该分组；</li>
<li>如果该分组的序号等于接收窗口的基序号（rcv_base），则该分组以及以前缓存的序号连续的（起始于rcv_base的）分组交付给上层，然后接收窗口向前移动分组的编号；</li>
</ul>
</li>
<li>序号在[rcv_base-N，rcv_base-1]范围内的分组被正确接收：在此情况下（即原ACK可能在返回时丢失），必须产生一个ACK，即使该分组是接收方已经确认过的分组；</li>
<li>其它情况：忽略该分组；</li>
</ul>
<p>N=4的实例SR分组丢失操作图示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/052.png" alt="image-20201103104615086"></p>
<p>在序列号范围有限（或者说窗口长度接近序列号范围长度时），发送方和接收方窗口间缺乏同步会产生严重的后果！</p>
<p>举例：N=3，分组序号为0~3：</p>
<ul>
<li>假定发送了分组0~2，并在接收方被正确接收且确认了，此时，接收方期待分组序列落在4、5、6分组上，其对应序列分别为3、0、1：<ul>
<li>①如图a：对前三个分组的ACK丢失，因此发送方重传这些分组，而接收方下一步接收的序号为0的分组所对应的就是1号分组而非其期待接收的4号分组；</li>
<li>②如图b：前三个分组的ACK都正确交付，因此发送方向前移动窗口并发送4、5、6个分组，其序号对应为3、0、1，若此时序号为3的分组丢失，但序号为0的分组到达，则对应SR接收方动作中一二种情形等同，没有办法区分是第一个分组的重传还是第五个分组的初次传输；</li>
</ul>
</li>
<li>窗口长度必须小于或等于序列空间大小的一半；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/053.png" alt="image-20201103104823611"></p>
<p>可靠数据传输原理总结：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/054.png" alt="image-20201103110050615"></p>
<h2 id="5-面向连接的运输：TCP"><a href="#5-面向连接的运输：TCP" class="headerlink" title="5 面向连接的运输：TCP"></a>5 面向连接的运输：TCP</h2><h3 id="5-1-TCP连接"><a href="#5-1-TCP连接" class="headerlink" title="5.1 TCP连接"></a>5.1 TCP连接</h3><blockquote>
<p>TCP连接是一条逻辑连接，只在源和目的端系统中维持连接状态，而不会在中间网络元素中存留连接状态</p>
</blockquote>
<p>全双工服务：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在A、B进程之间双向流通。</p>
<p>点对点：每一次发送过程，都是在单个发送方和单个接收方之间的连接。</p>
<p>TCP连接建立的过程：</p>
<ol>
<li>客户应用进程通知客户运输层，它想与服务器上的一个进程建立一条连接：<ol>
<li>三次握手协议：客户-服务器-客户，只有第三次客户发送的响应报文才可承载有效载荷（应用层数据）；</li>
</ol>
</li>
<li>建立连接后，客户进程通过套接字传递数据流，TCP将这些数据流引导到<strong>该连接</strong>的<strong>发送缓存</strong>里，发送缓存是发送三次握手协议期间设置的缓存之一；</li>
<li>TCP在它方便的时候会从该连接的发送缓存中取出一块数据并配上TCP首部形成<strong>TCP报文段</strong>，再传递给网络层，也就是发送数据；</li>
<li>接收端接收到报文段后，该报文段的数据就被放入该TCP连接的<strong>接收缓存</strong>中；</li>
<li>应用程序通过套接字从接收缓存中读取数据；</li>
</ol>
<ul>
<li>注意：<ul>
<li>TCP可从发送缓存里取出并放入报文段中的数据数量受限于<strong>最大报文段长度（MSS）</strong>；</li>
<li>MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（<strong>最大传输单元（MTU）</strong>）来设置，且MSS是指在报文段里应用层数据的最大长度，而不是包括首部的TCP报文段的最大长度；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/055.png" alt="image-20201103123411798"></p>
<p>由此可知，TCP连接的组成包括：</p>
<ul>
<li>客户与服务器主机上的缓存、变量和与进程连接的套接字；</li>
</ul>
<h3 id="5-2-TCP报文段结构"><a href="#5-2-TCP报文段结构" class="headerlink" title="5.2 TCP报文段结构"></a>5.2 TCP报文段结构</h3><p>如图所示：TCP报文段由首部和一个数据字段组成，数据字段包含一块应用数据，而MSS限制了报文段数据字段的最大长度（交互式应用通常传送长度小于MSS的数据块），首部包含：</p>
<ul>
<li>源端口号：多路复用来自上层的数据；</li>
<li>目的端口号：多路分解将数据传输到上层；</li>
<li>检验和字段；</li>
<li>序号字段；</li>
<li>确认号字段；</li>
<li>接收窗口字段：16比特，用于指示接收方愿意接收的字节数量，控制流量；</li>
<li>首部长度字段：4比特，由于选项字段可变，TCP首部的长度也是可变的通常选项字段为空时首部长度为20字节；</li>
<li>选项字段：可选与变长；</li>
<li>标志字段：6比特，ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认，其它比特位后续讲到；</li>
<li>紧急数据指针字段；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/056.png" alt="image-20201103210636179"></p>
<h4 id="5-21-序号和确认号"><a href="#5-21-序号和确认号" class="headerlink" title="5.21 序号和确认号"></a>5.21 序号和确认号</h4><blockquote>
<p>TCP把数据看成一个无结构的、有序的字节流，<strong>序号</strong>建立在传送的数据的字节流上，每一个数据字节都拥有自己的序号，一个报文段的序号是该报文首字节的字节流编号</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/057.png" alt="image-20201103212015084"></p>
<p><strong>确认号</strong>：主机A向主机B发送报文段时，确认号是主机A期待主机B下一次能够向它发送字节流数据的序号，同时也是确认该流中到第一个丢失字节为止的序号。举例：主机A收到主机B给自己发送的序号为0-535和900-1000的两个报文段数据，那么当它向B发送数据时，确认号就是536，期望下一次主机B能够发送从536序号开始的字节流数据报文段。</p>
<p>在上述例子中产生问题：第三个报文段900-1000序号失序到达，这时接收方有两个选择：</p>
<ul>
<li>立即丢弃失序报文段，这可以简化设计；</li>
<li>保留失序字节，并等待缺少的字节，实践中一般采用此方法；</li>
</ul>
<p>且在一条TCP连接过程，连接双方可以随机选择初始序号，这样做可以减少可能出现的与旧报文序号相同的误会。</p>
<h4 id="5-22-序号和确认号的一个学习案例"><a href="#5-22-序号和确认号的一个学习案例" class="headerlink" title="5.22 序号和确认号的一个学习案例"></a>5.22 序号和确认号的一个学习案例</h4><p>会话过程：</p>
<ol>
<li>主机A（客户）数据初始序号为42，主机B（服务器）数据初始序号为79，TCP首先建立连接；</li>
<li>主机A向主机B发送第一个报文段，初始序号为42，确认号为79，数据内容为<code>C</code>；</li>
<li>主机B向主机A回显它收到的数据<code>C</code>，其初始序号为79，确认号为43；</li>
<li>主机A向主机B发送一个响应报文，申明自己已经收到数据，虽然没有数据，但是依然使用了43的序号，这是因为序号字段必须填入某个序号；</li>
</ol>
<p>其中，主机B向主机A发送的响应数据其实已经包含确认，这种确认号被装载在一个承载数据内容的报文段的确认被称为是<strong>捎带</strong>的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/058.png" alt="image-20201103214621223"></p>
<h3 id="5-3-往返时间的估计与超时"><a href="#5-3-往返时间的估计与超时" class="headerlink" title="5.3 往返时间的估计与超时"></a>5.3 往返时间的估计与超时</h3><blockquote>
<p>超时/重传机制最明显的一个问题就是超时间隔长度的设置，这一节讨论这个问题</p>
</blockquote>
<h4 id="5-31-估计往返时间"><a href="#5-31-估计往返时间" class="headerlink" title="5.31 估计往返时间"></a>5.31 估计往返时间</h4><p>报文段<strong>样本RTT（SampleRTT）</strong>：从某报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量，也就是<strong>估计往返时间</strong>。</p>
<ul>
<li>由于TCP一般只在某一个时刻做一次SampleRTT测量，所以这个样本估计量是不够准确的，因此以平均RTT的方式解决准确性问题；</li>
<li>TCP维持一个SampleRTT均值（EstimatedRTT），一旦获得一个新的SampleRTT时，TCP按照以下公式更新EstimatedRTT值：<ul>
<li>其中<code>α</code>推荐值是0.125；</li>
<li>这个加权平均对最近的样本赋予的权值要大于对旧样本赋予的权值，因为越近的样本越能反映当前网络的拥塞状况，这种平均又被称为<strong>指数加权移动平均</strong>；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/059.png" alt="image-20201104102754129"></p>
<p><strong>RTT偏差（DevRTT）</strong>：测量RTT的变化，估算SampleRTT一般会偏离EstimatedRTT的程度。</p>
<ul>
<li><code>β</code>的推荐值是0.25；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/060.png" alt="image-20201104103344966"></p>
<h4 id="5-32-设置和管理重传超时间隔"><a href="#5-32-设置和管理重传超时间隔" class="headerlink" title="5.32 设置和管理重传超时间隔"></a>5.32 设置和管理重传超时间隔</h4><blockquote>
<p>超时间隔设置为EstimatedRTT加上一定余量，且当SampleRTT值波动较大时，这个余量应该大些，当波动较小时，这个余量应该小些。</p>
</blockquote>
<p>超时间隔（TimeoutInterval）：初始值推荐为1秒</p>
<ul>
<li>出现超时后，TimeoutInterval值加倍；</li>
<li>一旦收到报文段并更新EstimatedRTT，就使用公式<code>TimeoutInterval=EstimatedRTT+4×DevRTT</code>计算；</li>
</ul>
<h3 id="5-4-可靠数据传输"><a href="#5-4-可靠数据传输" class="headerlink" title="5.4 可靠数据传输"></a>5.4 可靠数据传输</h3><p>定时器，前面研究可靠数据传输时假定每一个已发送但未确认接收的报文段都拥有一个独立的定时器，但由于这样一来定时器的开销太大，实际开发中，TCP定时器管理过程对多个已发送但未接收的报文段仅使用单一的重传定时器。</p>
<blockquote>
<p>TCP使用超时机制和冗余确认技术实现差错报文段的恢复</p>
</blockquote>
<p>超时机制：</p>
<ul>
<li>发送方三个与重传有关的主要事件：<ul>
<li>从上层应用程序接收数据：将接收到的数据封装到报文段并发送给IP，当报文段被传给IP时，TCP就启动定时器，该定时器的超时间隔为<code>TimeoutInterval</code>；</li>
<li>定时器超时：TCP通过重传引起超时的报文段来作为响应，并且重启定时器，超时间隔加倍；</li>
<li>收到ACK：发送方接收到来自接收方的确认报文段（ACK）时，TCP将ACK的<code>y</code>值与它的变量<code>SendBase</code>进行比较<ul>
<li><input checked disabled type="checkbox"> <code>SendBase</code>是最早未被确认的字节的序号；</li>
<li><input checked disabled type="checkbox"> TCP采用累积确认，所以<code>y</code>确认了字节序号在<code>y</code>之前的所有字节都已经正确收到；</li>
<li><input disabled type="checkbox"> 如果<code>y&gt;SendBase</code>，则该ACK是在确认一个或多个先前未被确认的报文段，发送方更新<code>SendBase</code>值；如果当前有未被确认的报文段，TCP重启定时器<code>?</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/061.png" alt="image-20201104222955779"></p>
<h4 id="5-41-简化模型特殊情形"><a href="#5-41-简化模型特殊情形" class="headerlink" title="5.41 简化模型特殊情形"></a>5.41 简化模型特殊情形</h4><p>讨论只采用超时机制的简化模型中三种特殊情形：</p>
<ol>
<li>主机A向主机B发送的报文段正确到达，但是主机B响应的确认ACK丢失了，超时后，主机A会重传上一次报文段，而主机B接收到后会直接丢弃重传的报文段；</li>
<li>主机A连续发送两个报文段，然而在超时之前没有任何一个确认ACK到达，那么主机A重传第一个报文段，并且重启定时器，只要在这一次超时之前第二个报文段的确认ACK到达，主机A就不会再重传第二个报文段；</li>
<li>主机A连续发送两个报文段，第一个报文段的确认ACK丢失，但第二个报文段的确认ACK按时到达，主机A就会知道第二个确认ACK序号之前的字节都已到达，所以主机A并不会重传任何一个报文段；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/062.png" alt="image-20201104224510503"></p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/063.png" alt="image-20201104224532551" style="zoom:80%;">



<h4 id="5-42-超时间隔加倍"><a href="#5-42-超时间隔加倍" class="headerlink" title="5.42 超时间隔加倍"></a>5.42 超时间隔加倍</h4><blockquote>
<p>定时器时限过期后，每次TCP重传时都会将下一次的超时间隔设置为前一次的两倍，而不会使用从EstimatedRTT和DevRTT推算出的值，一直循环重传直到收到确认。在这个过程中，只要定时器的另外两个事件收到上层的数据和收到ACK中任何一个启动，TimeoutInterval都会根据最近的EstimatedRTT和DevRTT重新修改值</p>
</blockquote>
<p>定时器时限过期一般都是由网络拥塞引起的。</p>
<h4 id="5-43-快速重传"><a href="#5-43-快速重传" class="headerlink" title="5.43 快速重传"></a>5.43 快速重传</h4><blockquote>
<p>超时触发重传存在的问题之一就是超时周期可能相对较长，端到端时延增加</p>
</blockquote>
<p><strong>冗余ACK</strong>：发送方收到对某一报文段的确认后再次收到该报文段的ACK确认，可以通过冗余ACK检测丢包情况。</p>
<ul>
<li>当TCP接收方收到一个序号大于下一个所期望的、按序的报文段，它就检测出中间数据流出现间隔，即报文段丢失，它就会对已经接受到的最后一个按序字节数据进行重复确认，即产生冗余ACK；</li>
<li>如果TCP发送方接收到对相同数据的三个冗余ACK，说明跟在这个已被确认过三次的报文段之后的报文段已经丢失，就执行<strong>快速重传</strong>操作，即在该报文段定时器过期之前重传该丢失的报文段；</li>
</ul>
<p>TCP接收方的ACK生成策略：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/064.png" alt="image-20201104225512504"></p>
<h4 id="5-44-是回退N步还是选择重传"><a href="#5-44-是回退N步还是选择重传" class="headerlink" title="5.44 是回退N步还是选择重传"></a>5.44 是回退N步还是选择重传</h4><blockquote>
<p>TCP是一个GBN协议还是SR协议？</p>
</blockquote>
<p>情形一：TCP发送方仅需维持已发送过但未被确认的字节的最小序号（SendBase）和下一个将要发送的字节的序号（NextSeqNum）；</p>
<p>情形二：TCP会将正确接受但失序到达的报文段缓存起来；</p>
<p>情形三：当发送方发送一组报文段1，2，···，N，并且所有的报文段都正确按序到达接收方，而分组<code>n&lt;N</code>的确认报文丢失，其余<code>N-1</code>个确认ACK全部在超时之前到达</p>
<ul>
<li>对于GBN而言，它会重传所有序号为n以及之后的报文段；</li>
<li>而TCP最多只会重传序号为n的一个报文段，甚至如果报文段n+1的确认报文在超时之前到达的话，TCP不会重传任何报文段；</li>
</ul>
<p>TCP提供了一种方案：<strong>选择确认</strong>，允许TCP接收方有选择地确认失序报文段，而不是累积确认最后一个接收的有序报文段；实质上TCP提供的可靠数据传输更像是一种GBN和SR的混合协议。</p>
<h3 id="5-5-流量控制"><a href="#5-5-流量控制" class="headerlink" title="5.5 流量控制"></a>5.5 流量控制</h3><blockquote>
<p>一条TCP连接的每一侧主机都拥有一块接收缓存和一块发送缓存（全双工），如果某应用程序读取数据相对缓慢，而发送方发送数据太多、太快，则有可能使得接收方的接收缓存溢出，流量控制主要针对这一情形</p>
</blockquote>
<p><strong>流量控制</strong>：是一个速度匹配服务，发送方的发送速率和接收方应用程序读取数据的速率要相匹配，以消除发送方使接收方接收缓存溢出的情形。</p>
<p><strong>拥塞控制</strong>：TCP发送方因为IP网络的拥塞而被遏制发送。</p>
<p>两者得到的结果都是控制，但产生的原因不一样。</p>
<p>解决方案，以主机A向主机B发送大文件为例：</p>
<ul>
<li>接收窗口（rwnd）：该接收方还剩下多少接收缓存空间，由接收方放入报文段接收窗口字段发送回发送方，发送方通过维持该值来了解接收缓存的剩余空间，并且控制速率；</li>
<li><code>LastByteRead</code>：主机B上的应用程序从缓存读出的数据流的最后一个字节的序号；</li>
<li><code>LastByteRcvd</code>：从网络中到达的并已被放入主机B接收缓存中的数据流的最后一个字节的序号；</li>
<li>接收缓存（RcvBuffer）;</li>
<li>则应该满足：<ul>
<li><code>rwnd = RcvBuffer - [LastByteRead - LastByteRcvd] &gt;=0</code></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/065.png" alt="image-20201104234730901"></p>
<p>主机A轮流跟踪两个变量<code>LastByteRead</code>和<code>LastByteRcvd</code>，注意<code>LastByteRead - LastByteRcvd</code>值为主机A发送到连接中但未被确认的数据量。</p>
<p>考虑一个问题：假设主机B的接收缓存已经存满，即rwnd=0，在将rwnd=0通告给主机A之后，主机B没有任何数据需要发送（而TCP仅当在它有数据需要发送或者有确认需要发送时才会发送报文段给主机A）。而主机B上的应用程序将接收缓存清空之后，接收缓存就已经没有数据了，而主机A依然会被阻塞而不能再发送数据给主机B。</p>
<p>解决方案：TCP规范要求当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这样主机B就会实时刷新rwnd值并传递给主机A，让主机A知道接收缓存的空间余量。</p>
<p>UDP和TCP不同，它并不提供流量控制服务，报文段由于缓存溢出就可能在接收方丢失。</p>
<h3 id="5-6-TCP连接管理"><a href="#5-6-TCP连接管理" class="headerlink" title="5.6 TCP连接管理"></a>5.6 TCP连接管理</h3><blockquote>
<p>观察如何建立和拆除一条TCP连接</p>
</blockquote>
<p>建立过程：</p>
<ul>
<li><p>客户应用首先通知客户TCP，说明它想建立一个与服务器之间某个进程之间的连接；</p>
</li>
<li><p>TCP通过<strong>三次握手</strong>协议与服务器TCP建立一条TCP连接：</p>
<ul>
<li>客户端TCP首先向服务器端TCP发送一个特殊的TCP报文段，该报文段不包含数据，但在其首部的一个标志位<code>SYN比特</code>被置为1（该报文段又被称为<strong>SYN报文段</strong>）。此外，客户随机选择一个初始序号（client_isn），并将此序号放置于该SYN报文段的序号字段中。</li>
<li>TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报提取SYN报文段并为TCP连接分配变量和缓存（易受到SYN洪泛攻击，有修改），同时向客户端TCP发送允许连接的<strong>SYNACK报文段</strong>，其不能包含数据但首部包含三个信息：<ul>
<li>SYN比特置为1；</li>
<li>确认号字段被置为<code>client_isn+1</code>；</li>
<li>服务器选择自己的初始序号（server_isn），并放置到报文段首部的序号字段；</li>
</ul>
</li>
<li>客户收到SYNACK报文段，给该TCP连接分配变量和缓存，并向服务器发送另一个报文段。该报文段可以承载数据，SYN比特被置为0，且确认号字段存放值<code>server_isn+1</code>；</li>
</ul>
<p>在以后的每一个报文段中，SYN比特都被置为0。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/066.png" alt="image-20201105003237246" style="zoom:80%;">



<p>拆除过程：双方都能终止该连接，连接结束后，主机中资源将被释放，假设客户打算关闭连接（一般都是客户主动关闭）</p>
<ul>
<li>客户TCP发送一个特殊的报文段，标志位FIN比特置为1；</li>
<li>服务器接收到客户报文段，回送一个确认报文段；</li>
<li>服务器再发送自己的终止报文段，标志位FIN比特置为1；</li>
<li>客户对服务器发送的终止报文段进行确认，之后两台主机上的资源都被释放；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/067.png" alt="image-20201105003343640"></p>
<p><strong>TCP状态</strong>：在一个TCP连接的生命周期内，运行在每台主机上的TCP协议在各种TCP状态中变迁。</p>
<p>客户TCP经历的典型TCP状态：</p>
<ul>
<li>客户TCP开始时处于<code>CLOSED</code>（关闭）状态；</li>
<li>发送过SYN报文段后，客户TCP进入<code>SYN_SENT</code>状态；</li>
<li>收到服务器报文段进行确认且SYN置为1，客户TCP进入<code>ESTABLISHED</code>（已建立）状态，在此状态下，TCP客户就能发送和接收包含有效载荷数据的TCP报文段了；</li>
<li>假设客户应用程序决定关闭该连接，客户TCP发送一个带有FIN比特被置为1的特殊报文段，进入<code>FIN_WAIT_1</code>状态；</li>
<li>客户收到来自服务器TCP的确认报文段，进入<code>FIN_WAIT_2</code>状态；</li>
<li>客户收到来自服务器TCP带有FIN被置为1的特殊报文段，客户TCP对服务器的报文进行确认，并进入<code>TIME_WAIT</code>状态；<ul>
<li>假定客户发送的确认ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文段；</li>
<li>TIME_WAIT状态消耗的时间与具体实现相关，典型的数值是30秒、1分钟、2分钟；</li>
<li>经过这段时间等待后，连接正式关闭，客户端所有资源（包括端口号）将被释放；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/068.png" alt="image-20201105003901345" style="zoom:80%;">



<p>服务器TCP经历的典型TCP状态（假设客户开始终止连接）：</p>
<p>没有描述某些不正常的情形（如当连接的双方同时发起或终止一条连接），具体如图：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/069.png" alt="image-20201105005036960" style="zoom:80%;">



<p>nmap端口扫描工具工作原理：</p>
<ul>
<li>假设探索特定的TCP端口6789，nmap将对那台主机的目的端口6789发送一个特殊的TCP SYN报文段，有三种可能输出：<ul>
<li>源主机从目标主机接收到一个TCP SYNACK报文段，这意味着在目标主机上一个应用程序使用TCP端口6789运行，nmap返回“打开”；</li>
<li>源主机从目标主机接收到一个TCP RST报文段，这意味着该SYN报文段到达了目标主机，但目标主机没有运行一个使用TCP端口为6789的应用程序；</li>
<li>源什么也没收到，这表明该SYN报文可能被中间的防火墙所阻挡，无法到达目标主机；</li>
</ul>
</li>
</ul>
<p>除此之外，扩展一下<strong>SYN洪泛攻击</strong>：</p>
<p>由于服务器在响应客户TCP SYN报文段时会分配并初始化连接变量和缓存，如果某客户不发送ACK来完成该三次握手的第三步，最终（在一分多钟后）服务器将终止该半开连接并回收资源。</p>
<ul>
<li>SYN洪泛攻击：攻击者发送大量的TCP SYN报文段，而不完成第三次握手协议，服务器不断为这些半开连接分配资源（但从未使用），导致服务器的连接资源被消耗殆尽；</li>
<li>SYN cookie：防御SYN洪泛攻击的一种手段，主要实现是服务器不会为SYN报文段的到来生成一个半开连接；</li>
</ul>
<h2 id="6-拥塞控制原理"><a href="#6-拥塞控制原理" class="headerlink" title="6.拥塞控制原理"></a>6.拥塞控制原理</h2><blockquote>
<p>分组重传是网络拥塞的象征，为了处理网络拥塞问题，需要一些机制以在面临网络拥塞时遏制发送方</p>
</blockquote>
<h3 id="6-1-拥塞原因与代价"><a href="#6-1-拥塞原因与代价" class="headerlink" title="6.1 拥塞原因与代价"></a>6.1 拥塞原因与代价</h3><h4 id="6-11-情形一：两个发送方和一台具有无限缓存的路由器"><a href="#6-11-情形一：两个发送方和一台具有无限缓存的路由器" class="headerlink" title="6.11 情形一：两个发送方和一台具有无限缓存的路由器"></a>6.11 情形一：两个发送方和一台具有无限缓存的路由器</h4><p>两台主机（A、B）都有一条连接，且这两条连接共享源与目的地之间的单跳路由：</p>
<ul>
<li>假设主机A、B中的应用程序以**λ<sub>in</sub>**字节每秒的平均速率将数据发送到连接中；</li>
<li>运输层协议使用UDP，不执行差错恢复、流量控制和拥塞控制；</li>
<li>忽略添加运输层和较低层首部的额外开销；</li>
<li>假设路由器缓存无限大；</li>
<li>过程分析：<ul>
<li>来自主机A、B的分组通过一台路由器，在一段容量为R的共享式链路上进行传输；</li>
<li>当分组到达速率超过输出链路的容量时存储“入分组”；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/070.png" alt="image-20201105075324553" style="zoom:80%;">

<p>主机A的连接性能图示：</p>
<ul>
<li>左边的图形描绘了接收方每秒接收的字节数与该连接发送速率之间的函数关系：<ul>
<li>当发送速率在0-R/2之间时，接收方吞吐量等于发送方的发送速率；</li>
<li>当发送速率大于R/2时，吞吐量依然只能达到R/2；</li>
<li>这个吞吐量上限R/2是由两条连接之间共享链路的容量决定的，链路完全不能以超过R/2的稳定状态速率向接收方交付分组；</li>
</ul>
</li>
<li>右边图形描绘了发送速率与时延的函数关系：<ul>
<li>当发送方发送速率接近R/2左右时，其平均时延就会越来越大；</li>
<li>当发送速率超过R/2时，路由器中的排队时延就会无限增大；</li>
</ul>
</li>
<li><strong>拥塞网络代价一</strong>：当分组的到达速率接近链路的容量时，分组会经历巨大的排队时延；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/071.png" alt="image-20201105100811705" style="zoom:80%;">



<h4 id="6-12-情形二：两个发送方和一台具有优先缓存的路由器"><a href="#6-12-情形二：两个发送方和一台具有优先缓存的路由器" class="headerlink" title="6.12 情形二：两个发送方和一台具有优先缓存的路由器"></a>6.12 情形二：两个发送方和一台具有优先缓存的路由器</h4><p>假定路由器缓存有限：</p>
<ul>
<li>分组到达一个已满的缓存时会被丢弃；</li>
<li>假定连接为TCP连接，即连接可靠，分组丢失可以被重传；</li>
<li>应用程序将初始数据以**λ<sub>in</sub>**字节每秒发送到套接字中；</li>
<li>运输层以<strong>λ’<sub>in</sub>**字节每秒向网络层发送报文段，该速率又被称为网络的</strong>供给载荷**；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/072.png" alt="image-20201105101709219" style="zoom:80%;">



<p>理想情况：不丢失分组</p>
<ul>
<li>主机A能够以某种方式确认路由器中的缓存是否空闲，再决定是否发送分组，这时不会产生丢包，<strong>λ<sub>in</sub>=λ’<sub>in</sub>**，连接的吞吐量也等于</strong>λ<sub>in</sub>**；</li>
<li>平均主机发送速率不能超过R/2；</li>
</ul>
<p>实际情况：进行重传</p>
<ul>
<li>供给载荷<strong>λ’<sub>in</sub>=R/2</strong>，此时数据被交付给接收方应用程序的速率为R/3，在所发送的0.5R单位数据中，平均而言，R/3字节每秒是初始数据，R/6字节每秒是重传数据<ul>
<li><strong>拥塞网络代价二</strong>：发送方必须执行重传以补偿因为缓存溢出而丢失的分组；</li>
</ul>
</li>
<li>接收方收到报文段，而发送方可能没能及时接收到ACK报文段，这时发送方重传的报文段数据接收即丢弃<ul>
<li><strong>拥塞网络代价三</strong>：发送方遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组；</li>
<li>图c假定每个分组被路由器平均转发两次时，吞吐量与供给载荷的对比情况：<ul>
<li>当供给载荷接近R/2时，其吞吐量渐进R/4；</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/073.png" alt="image-20201105102525147" style="zoom:80%;">



<h4 id="6-13-情形三：四个发送方和具有有限缓存的多台路由器及多跳链路"><a href="#6-13-情形三：四个发送方和具有有限缓存的多台路由器及多跳链路" class="headerlink" title="6.13 情形三：四个发送方和具有有限缓存的多台路由器及多跳链路"></a>6.13 情形三：四个发送方和具有有限缓存的多台路由器及多跳链路</h4><p>四台主机发送分组，每台都通过交叠的两跳链路传输：</p>
<ul>
<li>假定使用TCP连接，采用超时/重传机制实现可靠传输服务；</li>
<li>所有主机都有相同的**λ<sub>in</sub>**值，所有路由器的链路容量都是R字节每秒；</li>
<li>如图：<ul>
<li>A-C与D-B连接共享路由器R1；</li>
<li>A-C与B-D连接共享路由器R2；</li>
<li>对极小的**λ<sub>in</sub>**而言：<ul>
<li><strong>λ<sub>in</sub>**的增大会导致</strong>λ<sub>out</sub>**的增大</li>
<li>路由器缓存溢出很少；</li>
</ul>
</li>
<li>**λ<sub>in</sub>**（λ’<sub>in</sub>也增长）很大时：<ul>
<li>不管**λ<sub>in</sub>**的值多大，到达路由器R2的A-C流量的到达速率最大是R，这也是R1到R2的链路容量；</li>
<li><strong>λ<sub>in</sub>**很大，</strong>λ’<sub>in</sub>**对于所有连接都很大，那么在R2上，B-D流量的到达速率可能远大于A-C流量的到达速率<ul>
<li>A-C和B-D流量必须参与R2上的链路缓存的竞争；</li>
<li>来自B-D连接的供给载荷越大，A-C连接通过的流量就会越小；</li>
<li>极限情况下，R2的空闲缓存会被B-D连接的分组占满，A-C端到端吞吐量将趋向于0；</li>
<li>此时，第一跳路由器所使用的将分组转发到第二跳路由器的传输容量用来传输不同的分组可能更有效益；</li>
<li><strong>拥塞网络代价四</strong>：当一个分组沿一条路径被丢弃时，每个路由器用于转发该分组到丢弃该分组而使用的传输容量全部浪费了；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/074.png" alt="image-20201105103808051" style="zoom:80%;">



<h3 id="6-2-拥塞控制方法"><a href="#6-2-拥塞控制方法" class="headerlink" title="6.2 拥塞控制方法"></a>6.2 拥塞控制方法</h3><p>两种主要的拥塞控制方法：</p>
<ul>
<li>端到端拥塞控制：网络层不为运输层拥塞控制提供显性支持；</li>
<li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息，拥塞信息从网络反馈到发送方有两种方式：<ul>
<li>经由接收方的网络反馈；</li>
<li>直接网络反馈：<ul>
<li>由网络路由器发送，采用<strong>阻塞分组</strong>的形式；</li>
<li>更通用的是，路由器标记或更新从发送方流向接收方的分组中某个字段来指示拥塞的产生，至少要经过一个完整的往返时间；</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/075.png" alt="image-20201105105809022" style="zoom:80%;">



<h2 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="7.TCP拥塞控制"></a>7.TCP拥塞控制</h2><blockquote>
<p>由于IP层不向端系统提供显式的网络拥塞反馈，TCP必须使用端到端拥塞控制。TCP采用的方法是让每一个发送方根据所感应到的网络拥塞程度来限制其发送速率，但这个方法有三个极为重要的问题：</p>
</blockquote>
<p>问题一：TCP发送方如何限制它向接收方发送的速率？</p>
<ul>
<li>运行在发送端的TCP拥塞控制机制存在一个额外变量<strong>拥塞窗口（cwnd）</strong>，它对一个TCP能向路径上发送的速率进行了限制<ul>
<li><code>LastByteSent - LastByteAcked &lt;= min&#123;cwnd,rwnd&#125;</code>；</li>
<li>假设TCP接收缓存无限大，即可以忽略接收窗口（rwnd）的限制，并且假设发送方一直有数据需要发送，由于发送未确认报文段的存在，所以会限制发送方的发送速率；</li>
<li>考虑一个丢包和发送时延均可忽略不计的连接，在每个往返时间（RTT）的起始点，上述限制条件允许发送方向该连接发送cwnd个字节的数据，在该RTT结束时发送方接收到来自接收方的确认报文段，因此，该发送方的发送速率大概为 <code>cwnd/RTT</code> 字节每秒；</li>
<li>通过调节cwnd的值，发送方能够调节它相连接发送数据的速率；</li>
</ul>
</li>
</ul>
<p>问题二：TCP如何感知从它到目的地之间的路径上存在拥塞？</p>
<ul>
<li><p>将<strong>丢包事件</strong>（拥塞检测）定义为：出现超时，或者收到来自接收方的三个冗余ACK；</p>
</li>
<li><p>考虑网络没有拥塞的情形：</p>
<ul>
<li>TCP的发送方接收到对于以前未确认的报文段的确认，并使用该确认来增加窗口的长度（及其传输速率）；</li>
<li>如果确认以相当慢的速率到达，则该拥塞窗口以相当慢的速率增加，如果确认以高速率到达，则该拥塞窗口的速率快速增加；</li>
<li>由于TCP使用确认来触发增大它的拥塞窗口长度，所以TCP又被称为<strong>自计时</strong>的；</li>
</ul>
</li>
<li><p>TCP又应该怎样确定它应该以怎样的速率发送数据呢？</p>
<ul>
<li>一个丢失的报文段意味着拥塞，因此当丢失报文段时应该降低其发送速率；</li>
<li>一个确认报文段指示网路正在向接收方交付发送方的报文段，因此当到达一个未确认的确认报文段，增加其发送速率；</li>
<li>带宽探测：TCP调节其传输速率的策略是增加其速率以响应到达的ACK，仅出现丢包事件时，才减小发送速率；</li>
</ul>
</li>
</ul>
<p>问题三：当发送端感知到拥塞，又采用何种算法来改变其发送速率？</p>
<ul>
<li><strong>TCP拥塞控制算法</strong>：<ul>
<li>慢启动；</li>
<li>拥塞避免；</li>
<li>快速恢复；</li>
</ul>
</li>
</ul>
<p>其中，慢启动和拥塞避免是TCP强制必需部分，而快速恢复则只是推荐而非必需。</p>
<h3 id="7-01-慢启动"><a href="#7-01-慢启动" class="headerlink" title="7.01 慢启动"></a>7.01 慢启动</h3><blockquote>
<p>一条TCP连接开始时，cwnd的值通常初始化为一个MSS的较小值，初始发送速率约为MSS/RTT，例如MSS=500字节，RTT=200ms，则初始速率约为20kbps，这个速率相较于带宽而言要小得多</p>
</blockquote>
<p><strong>慢启动状态</strong>：cwnd的值以一个MSS开始并且每当报文段首次被确认就增加一个MSS（是发送方对每个确认报文段给拥塞窗口增加一个MSS，即呈指数增长），如图：</p>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/076.png" alt="image-20201105215713739" style="zoom:80%;">

<p>何时结束慢启动状态呢？</p>
<ul>
<li>如果出现超时丢包事件，TCP发送方将cwnd设置为1并重新启动慢启动过程，还将第二个状态变量<code>ssthresh</code>的值设置为cwnd/2；</li>
<li>当cwnd的值等于ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式；</li>
<li>检测到三个冗余ACK时，TCP执行快速重传并进入快速恢复状态；</li>
</ul>
<p>以下是TCP拥塞控制算法的完整FSM描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/077.png" alt="image-20201105220553024"></p>
<h3 id="7-02-拥塞避免"><a href="#7-02-拥塞避免" class="headerlink" title="7.02 拥塞避免"></a>7.02 拥塞避免</h3><blockquote>
<p>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时值的一半。收到确认时，TCP也不会再每过一个RTT将cwnd的值翻番，而是每个RTT只将cwnd的值增加一个MSS</p>
</blockquote>
<p>何时结束拥塞避免的线性增长？</p>
<ul>
<li>出现丢包时，TCP将ssthresh的值记录为cwnd值的一半；</li>
<li>收到三个冗余ACK时，TCP将cwnd的值减半（但是收到的三个冗余ACK还是会线性增加三个MSS），再将ssthresh的值记录为cwnd值的一半，并且接下来进入快速恢复状态；</li>
</ul>
<h3 id="7-03-快速恢复"><a href="#7-03-快速恢复" class="headerlink" title="7.03 快速恢复"></a>7.03 快速恢复</h3><ul>
<li>进入快速恢复状态，重传之后当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态；</li>
<li>出现超时丢包事件，cwnd的值被设置为1个MSS，并将ssthresh的值设置为cwnd值的一半，并迁移到慢启动状态；</li>
</ul>
<h3 id="7-04-回顾TCP拥塞控制"><a href="#7-04-回顾TCP拥塞控制" class="headerlink" title="7.04 回顾TCP拥塞控制"></a>7.04 回顾TCP拥塞控制</h3><p>忽略一条TCP连接的初始慢启动阶段，考虑正常运行的一般状态，即拥塞避免时：</p>
<ul>
<li>此时TCP拥塞控制是：每个RTT内cwnd线性增加1MSS，出现3个冗余ACK时cwnd减半，这种拥塞控制又被称为<strong>加性增、乘性减（AIMD）</strong>；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ZHAOXIAOAN/CDNBlog/Img/ComputerNetWorking/078.png" alt="image-20201105223325409" style="zoom:80%;">



<h3 id="7-05-对TCP吞吐量的宏观描述"><a href="#7-05-对TCP吞吐量的宏观描述" class="headerlink" title="7.05 对TCP吞吐量的宏观描述"></a>7.05 对TCP吞吐量的宏观描述</h3><p>对于TCP的锯齿状行为，考虑一个存活期长的TCP连接的平均吞吐量（忽略短暂的慢启动阶段）：</p>
<ul>
<li>在一个特定的往返间隔内，窗口长度为W字节，往返时间为RTT秒，TCP发送速率约为W/RTT；</li>
<li>TCP每经过1个RTT将为W增加一个MSS，直到发送丢包事件，并如此往复；</li>
<li>假设在持续连接期间RTT和W保持不变，那么TCP的传输速率在W/(2×RTT)到W/RTT之间；</li>
<li>这条假设导出TCP稳态行为高度简化的宏观模型：<ul>
<li>当速率增长到W/RTT时，网络丢弃来自连接的分组，发送速率减半，进而没过一个RTT发送速率就增加MSS/RTT，直到再次到达W/RTT，重复过程；</li>
<li>一条连接的平均吞吐量=0.75×W/RTT；</li>
</ul>
</li>
</ul>

    </div>

    
    
    

  
         <div>
           <div>
  
    <div style="text-align:center;color:#bfbfbf;font-size:16px;">
      <span>-------- 本文结束 </span>
      <i class="fa fa-paw"></i>
      <span> 感谢阅读 --------</span>
    </div>
  
</div>

         </div>
       
      
  <div class="popular-posts-header">相关文章推荐# Custom header, leave empty to use the default one</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\09\30\计算机网络自顶向下方法\第一章.因特网\" rel="bookmark">计算机网络自顶向下方法学习笔记（一）因特网</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\11\18\计算机网络自顶向下方法\第四章.网络层：数据平面\" rel="bookmark">计算机网络自顶向下方法学习笔记（四）网络层：数据平面</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\10\14\计算机网络自顶向下方法\第二章.应用层\" rel="bookmark">计算机网络自顶向下方法学习笔记（二）应用层</a></div>
    </li>
  </ul>





    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Zhaoxiaoan
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://kunpw.cn/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/" title="计算机网络自顶向下方法学习笔记（三）运输层">http://kunpw.cn/2020/11/05/计算机网络自顶向下方法/第三章.运输层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 计算机网络自顶向下方法</a>
              <a href="/tags/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 理论学习</a>
              <a href="/tags/%E6%95%99%E6%9D%90/" rel="tag"><i class="fa fa-tag"></i> 教材</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/23/SpringBoot/SpringBoot%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="SpringBoot(一)">
                  <i class="fa fa-chevron-left"></i> SpringBoot(一)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/14/Python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" rel="next" title="使用Python数据分析遇到的部分问题">
                  使用Python数据分析遇到的部分问题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>

  
  
  



      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<span id="timeDate" style="color: green;">载入天数...</span>
<span id="times" style="color: green;">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("09/06/2020 13:38:49");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>



<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhaoxiaoan</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">161k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:26</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>












  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








    <div class="pjax">
  

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: "/2020/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E8%BF%90%E8%BE%93%E5%B1%82/",
    }, {"enable":true,"appId":"9JxB7GVqlwRNk6oWQAWRFukK-MdYXbMMI","appKey":"0FRspDasEAKCPOgl62bwPGJ6","placeholder":"评论区走一波","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null,"enableQQ":false,"requiredFields":[],"emoticonUrl":["https://cdn.jsdelivr.net/npm/alus@latest","https://cdn.jsdelivr.net/gh/MiniValine/qq@latest","https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest","https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest","https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest","https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"]}
    ));
  }, window.Valine);
});
</script>



<script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<script type="text/javascript">
jinrishici.load(function(result) {
	var jrsc_plac =  result.data.content + "\n「" + result.data.origin.title + "」" + result.data.origin.dynasty + " · " + result.data.origin.author
	document.getElementById("veditor").setAttribute("placeholder",jrsc_plac);
});
</script>


  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/write/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>


    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>
